"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createReduxStore;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _redux = require("redux");

var _lodash = require("lodash");

var _turboCombineReducers = _interopRequireDefault(require("turbo-combine-reducers"));

var _equivalentKeyMap = _interopRequireDefault(require("equivalent-key-map"));

var _reduxRoutine = _interopRequireDefault(require("@wordpress/redux-routine"));

var _controls = require("../controls");

var _promiseMiddleware = _interopRequireDefault(require("../promise-middleware"));

var _resolversCacheMiddleware = _interopRequireDefault(require("../resolvers-cache-middleware"));

var _thunkMiddleware = _interopRequireDefault(require("./thunk-middleware"));

var _reducer = _interopRequireDefault(require("./metadata/reducer"));

var metadataSelectors = _interopRequireWildcard(require("./metadata/selectors"));

var metadataActions = _interopRequireWildcard(require("./metadata/actions"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @typedef {import('../types').WPDataRegistry} WPDataRegistry */

/** @typedef {import('../types').WPDataStore} WPDataStore */

/** @typedef {import('../types').WPDataReduxStoreConfig} WPDataReduxStoreConfig */

/**
 * Create a cache to track whether resolvers started running or not.
 *
 * @return {Object} Resolvers Cache.
 */
function createResolversCache() {
  var cache = {};
  return {
    isRunning: function isRunning(selectorName, args) {
      return cache[selectorName] && cache[selectorName].get(args);
    },
    clear: function clear(selectorName, args) {
      if (cache[selectorName]) {
        cache[selectorName].delete(args);
      }
    },
    markAsRunning: function markAsRunning(selectorName, args) {
      if (!cache[selectorName]) {
        cache[selectorName] = new _equivalentKeyMap.default();
      }

      cache[selectorName].set(args, true);
    }
  };
}
/**
 * Creates a data store definition for the provided Redux store options containing
 * properties describing reducer, actions, selectors, controls and resolvers.
 *
 * @example
 * ```js
 * import { createReduxStore } from '@wordpress/data';
 *
 * const store = createReduxStore( 'demo', {
 *     reducer: ( state = 'OK' ) => state,
 *     selectors: {
 *         getValue: ( state ) => state,
 *     },
 * } );
 * ```
 *
 * @param {string}                 key      Unique namespace identifier.
 * @param {WPDataReduxStoreConfig} options  Registered store options, with properties
 *                                          describing reducer, actions, selectors,
 *                                          and resolvers.
 *
 * @return {WPDataStore} Store Object.
 */


function createReduxStore(key, options) {
  return {
    name: key,
    instantiate: function instantiate(registry) {
      var reducer = options.reducer;
      var thunkArgs = {
        registry: registry,

        get dispatch() {
          return Object.assign(function (action) {
            return store.dispatch(action);
          }, getActions());
        },

        get select() {
          return Object.assign(function (selector) {
            return selector(store.__unstableOriginalGetState());
          }, getSelectors());
        },

        get resolveSelect() {
          return getResolveSelectors();
        }

      };
      var store = instantiateReduxStore(key, options, registry, thunkArgs);
      var resolversCache = createResolversCache();
      var resolvers;
      var actions = mapActions(_objectSpread(_objectSpread({}, metadataActions), options.actions), store);
      var selectors = mapSelectors(_objectSpread(_objectSpread({}, (0, _lodash.mapValues)(metadataSelectors, function (selector) {
        return function (state) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return selector.apply(void 0, [state.metadata].concat(args));
        };
      })), (0, _lodash.mapValues)(options.selectors, function (selector) {
        if (selector.isRegistrySelector) {
          selector.registry = registry;
        }

        return function (state) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return selector.apply(void 0, [state.root].concat(args));
        };
      })), store);

      if (options.resolvers) {
        var result = mapResolvers(options.resolvers, selectors, store, resolversCache);
        resolvers = result.resolvers;
        selectors = result.selectors;
      }

      var resolveSelectors = mapResolveSelectors(selectors, store);

      var getSelectors = function getSelectors() {
        return selectors;
      };

      var getActions = function getActions() {
        return actions;
      };

      var getResolveSelectors = function getResolveSelectors() {
        return resolveSelectors;
      }; // We have some modules monkey-patching the store object
      // It's wrong to do so but until we refactor all of our effects to controls
      // We need to keep the same "store" instance here.


      store.__unstableOriginalGetState = store.getState;

      store.getState = function () {
        return store.__unstableOriginalGetState().root;
      }; // Customize subscribe behavior to call listeners only on effective change,
      // not on every dispatch.


      var subscribe = store && function (listener) {
        var lastState = store.__unstableOriginalGetState();

        return store.subscribe(function () {
          var state = store.__unstableOriginalGetState();

          var hasChanged = state !== lastState;
          lastState = state;

          if (hasChanged) {
            listener();
          }
        });
      }; // This can be simplified to just { subscribe, getSelectors, getActions }
      // Once we remove the use function.


      return {
        reducer: reducer,
        store: store,
        actions: actions,
        selectors: selectors,
        resolvers: resolvers,
        getSelectors: getSelectors,
        getResolveSelectors: getResolveSelectors,
        getActions: getActions,
        subscribe: subscribe
      };
    }
  };
}
/**
 * Creates a redux store for a namespace.
 *
 * @param {string}         key      Unique namespace identifier.
 * @param {Object}         options  Registered store options, with properties
 *                                  describing reducer, actions, selectors,
 *                                  and resolvers.
 * @param {WPDataRegistry} registry Registry reference.
 * @param {Object} thunkArgs        Argument object for the thunk middleware.
 * @return {Object} Newly created redux store.
 */


function instantiateReduxStore(key, options, registry, thunkArgs) {
  var controls = _objectSpread(_objectSpread({}, options.controls), _controls.builtinControls);

  var normalizedControls = (0, _lodash.mapValues)(controls, function (control) {
    return control.isRegistryControl ? control(registry) : control;
  });
  var middlewares = [(0, _resolversCacheMiddleware.default)(registry, key), _promiseMiddleware.default, (0, _reduxRoutine.default)(normalizedControls)];

  if (options.__experimentalUseThunks) {
    middlewares.push((0, _thunkMiddleware.default)(thunkArgs));
  }

  var enhancers = [_redux.applyMiddleware.apply(void 0, middlewares)];

  if (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
    enhancers.push(window.__REDUX_DEVTOOLS_EXTENSION__({
      name: key,
      instanceId: key
    }));
  }

  var reducer = options.reducer,
      initialState = options.initialState;
  var enhancedReducer = (0, _turboCombineReducers.default)({
    metadata: _reducer.default,
    root: reducer
  });
  return (0, _redux.createStore)(enhancedReducer, {
    root: initialState
  }, (0, _lodash.flowRight)(enhancers));
}
/**
 * Maps selectors to a store.
 *
 * @param {Object} selectors Selectors to register. Keys will be used as the
 *                           public facing API. Selectors will get passed the
 *                           state as first argument.
 * @param {Object} store     The store to which the selectors should be mapped.
 * @return {Object} Selectors mapped to the provided store.
 */


function mapSelectors(selectors, store) {
  var createStateSelector = function createStateSelector(registrySelector) {
    var selector = function runSelector() {
      // This function is an optimized implementation of:
      //
      //   selector( store.getState(), ...arguments )
      //
      // Where the above would incur an `Array#concat` in its application,
      // the logic here instead efficiently constructs an arguments array via
      // direct assignment.
      var argsLength = arguments.length;
      var args = new Array(argsLength + 1);
      args[0] = store.__unstableOriginalGetState();

      for (var i = 0; i < argsLength; i++) {
        args[i + 1] = arguments[i];
      }

      return registrySelector.apply(void 0, args);
    };

    selector.hasResolver = false;
    return selector;
  };

  return (0, _lodash.mapValues)(selectors, createStateSelector);
}
/**
 * Maps actions to dispatch from a given store.
 *
 * @param {Object} actions    Actions to register.
 * @param {Object} store      The redux store to which the actions should be mapped.
 * @return {Object}           Actions mapped to the redux store provided.
 */


function mapActions(actions, store) {
  var createBoundAction = function createBoundAction(action) {
    return function () {
      return Promise.resolve(store.dispatch(action.apply(void 0, arguments)));
    };
  };

  return (0, _lodash.mapValues)(actions, createBoundAction);
}
/**
 * Maps selectors to functions that return a resolution promise for them
 *
 * @param {Object} selectors Selectors to map.
 * @param {Object} store     The redux store the selectors select from.
 * @return {Object}          Selectors mapped to their resolution functions.
 */


function mapResolveSelectors(selectors, store) {
  return (0, _lodash.mapValues)((0, _lodash.omit)(selectors, ['getIsResolving', 'hasStartedResolution', 'hasFinishedResolution', 'isResolving', 'getCachedResolvers']), function (selector, selectorName) {
    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return new Promise(function (resolve) {
        var hasFinished = function hasFinished() {
          return selectors.hasFinishedResolution(selectorName, args);
        };

        var getResult = function getResult() {
          return selector.apply(null, args);
        }; // trigger the selector (to trigger the resolver)


        var result = getResult();

        if (hasFinished()) {
          return resolve(result);
        }

        var unsubscribe = store.subscribe(function () {
          if (hasFinished()) {
            unsubscribe();
            resolve(getResult());
          }
        });
      });
    };
  });
}
/**
 * Returns resolvers with matched selectors for a given namespace.
 * Resolvers are side effects invoked once per argument set of a given selector call,
 * used in ensuring that the data needs for the selector are satisfied.
 *
 * @param {Object} resolvers      Resolvers to register.
 * @param {Object} selectors      The current selectors to be modified.
 * @param {Object} store          The redux store to which the resolvers should be mapped.
 * @param {Object} resolversCache Resolvers Cache.
 */


function mapResolvers(resolvers, selectors, store, resolversCache) {
  // The `resolver` can be either a function that does the resolution, or, in more advanced
  // cases, an object with a `fullfill` method and other optional methods like `isFulfilled`.
  // Here we normalize the `resolver` function to an object with `fulfill` method.
  var mappedResolvers = (0, _lodash.mapValues)(resolvers, function (resolver) {
    if (resolver.fulfill) {
      return resolver;
    }

    return _objectSpread(_objectSpread({}, resolver), {}, {
      // copy the enumerable properties of the resolver function
      fulfill: resolver // add the fulfill method

    });
  });

  var mapSelector = function mapSelector(selector, selectorName) {
    var resolver = resolvers[selectorName];

    if (!resolver) {
      selector.hasResolver = false;
      return selector;
    }

    var selectorResolver = function selectorResolver() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      function fulfillSelector() {
        return _fulfillSelector.apply(this, arguments);
      }

      function _fulfillSelector() {
        _fulfillSelector = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
          var state, _store$__unstableOrig, metadata;

          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  state = store.getState();

                  if (!(resolversCache.isRunning(selectorName, args) || typeof resolver.isFulfilled === 'function' && resolver.isFulfilled.apply(resolver, [state].concat(args)))) {
                    _context2.next = 3;
                    break;
                  }

                  return _context2.abrupt("return");

                case 3:
                  _store$__unstableOrig = store.__unstableOriginalGetState(), metadata = _store$__unstableOrig.metadata;

                  if (!metadataSelectors.hasStartedResolution(metadata, selectorName, args)) {
                    _context2.next = 6;
                    break;
                  }

                  return _context2.abrupt("return");

                case 6:
                  resolversCache.markAsRunning(selectorName, args);
                  setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
                    return _regenerator.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            resolversCache.clear(selectorName, args);
                            store.dispatch(metadataActions.startResolution(selectorName, args));
                            _context.next = 4;
                            return fulfillResolver.apply(void 0, [store, mappedResolvers, selectorName].concat(args));

                          case 4:
                            store.dispatch(metadataActions.finishResolution(selectorName, args));

                          case 5:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  })));

                case 8:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        return _fulfillSelector.apply(this, arguments);
      }

      fulfillSelector.apply(void 0, args);
      return selector.apply(void 0, args);
    };

    selectorResolver.hasResolver = true;
    return selectorResolver;
  };

  return {
    resolvers: mappedResolvers,
    selectors: (0, _lodash.mapValues)(selectors, mapSelector)
  };
}
/**
 * Calls a resolver given arguments
 *
 * @param {Object} store        Store reference, for fulfilling via resolvers
 * @param {Object} resolvers    Store Resolvers
 * @param {string} selectorName Selector name to fulfill.
 * @param {Array} args          Selector Arguments.
 */


function fulfillResolver(_x, _x2, _x3) {
  return _fulfillResolver.apply(this, arguments);
}

function _fulfillResolver() {
  _fulfillResolver = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(store, resolvers, selectorName) {
    var resolver,
        _len5,
        args,
        _key5,
        action,
        _args3 = arguments;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            resolver = (0, _lodash.get)(resolvers, [selectorName]);

            if (resolver) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return");

          case 3:
            for (_len5 = _args3.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {
              args[_key5 - 3] = _args3[_key5];
            }

            action = resolver.fulfill.apply(resolver, args);

            if (!action) {
              _context3.next = 8;
              break;
            }

            _context3.next = 8;
            return store.dispatch(action);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fulfillResolver.apply(this, arguments);
}
//# sourceMappingURL=index.js.map