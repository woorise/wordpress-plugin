import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";

var _builtinControls;

/**
 * Internal dependencies
 */
import { createRegistryControl } from './factory';
var SELECT = '@@data/SELECT';
var RESOLVE_SELECT = '@@data/RESOLVE_SELECT';
var DISPATCH = '@@data/DISPATCH';
/**
 * Dispatches a control action for triggering a synchronous registry select.
 *
 * Note: This control synchronously returns the current selector value, triggering the
 * resolution, but not waiting for it.
 *
 * @param {string} storeKey     The key for the store the selector belongs to.
 * @param {string} selectorName The name of the selector.
 * @param {Array}  args         Arguments for the selector.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data';
 *
 * // Action generator using `select`.
 * export function* myAction() {
 *   const isEditorSideBarOpened = yield controls.select( 'core/edit-post', 'isEditorSideBarOpened' );
 *   // Do stuff with the result from the `select`.
 * }
 * ```
 *
 * @return {Object} The control descriptor.
 */

function select(storeKey, selectorName) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return {
    type: SELECT,
    storeKey: storeKey,
    selectorName: selectorName,
    args: args
  };
}
/**
 * Dispatches a control action for triggering and resolving a registry select.
 *
 * Note: when this control action is handled, it automatically considers
 * selectors that may have a resolver. In such case, it will return a `Promise` that resolves
 * after the selector finishes resolving, with the final result value.
 *
 * @param {string} storeKey      The key for the store the selector belongs to
 * @param {string} selectorName  The name of the selector
 * @param {Array}  args          Arguments for the selector.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data';
 *
 * // Action generator using resolveSelect
 * export function* myAction() {
 * 	const isSidebarOpened = yield controls.resolveSelect( 'core/edit-post', 'isEditorSideBarOpened' );
 * 	// do stuff with the result from the select.
 * }
 * ```
 *
 * @return {Object} The control descriptor.
 */


function resolveSelect(storeKey, selectorName) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  return {
    type: RESOLVE_SELECT,
    storeKey: storeKey,
    selectorName: selectorName,
    args: args
  };
}
/**
 * Dispatches a control action for triggering a registry dispatch.
 *
 * @param {string} storeKey    The key for the store the action belongs to
 * @param {string} actionName  The name of the action to dispatch
 * @param {Array}  args        Arguments for the dispatch action.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data-controls';
 *
 * // Action generator using dispatch
 * export function* myAction() {
 *   yield controls.dispatch( 'core/edit-post', 'togglePublishSidebar' );
 *   // do some other things.
 * }
 * ```
 *
 * @return {Object}  The control descriptor.
 */


function dispatch(storeKey, actionName) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    args[_key3 - 2] = arguments[_key3];
  }

  return {
    type: DISPATCH,
    storeKey: storeKey,
    actionName: actionName,
    args: args
  };
}

export var controls = {
  select: select,
  resolveSelect: resolveSelect,
  dispatch: dispatch
};
export var builtinControls = (_builtinControls = {}, _defineProperty(_builtinControls, SELECT, createRegistryControl(function (registry) {
  return function (_ref) {
    var _registry$select;

    var storeKey = _ref.storeKey,
        selectorName = _ref.selectorName,
        args = _ref.args;
    return (_registry$select = registry.select(storeKey))[selectorName].apply(_registry$select, _toConsumableArray(args));
  };
})), _defineProperty(_builtinControls, RESOLVE_SELECT, createRegistryControl(function (registry) {
  return function (_ref2) {
    var _registry$method;

    var storeKey = _ref2.storeKey,
        selectorName = _ref2.selectorName,
        args = _ref2.args;
    var method = registry.select(storeKey)[selectorName].hasResolver ? 'resolveSelect' : 'select';
    return (_registry$method = registry[method](storeKey))[selectorName].apply(_registry$method, _toConsumableArray(args));
  };
})), _defineProperty(_builtinControls, DISPATCH, createRegistryControl(function (registry) {
  return function (_ref3) {
    var _registry$dispatch;

    var storeKey = _ref3.storeKey,
        actionName = _ref3.actionName,
        args = _ref3.args;
    return (_registry$dispatch = registry.dispatch(storeKey))[actionName].apply(_registry$dispatch, _toConsumableArray(args));
  };
})), _builtinControls);
//# sourceMappingURL=controls.js.map