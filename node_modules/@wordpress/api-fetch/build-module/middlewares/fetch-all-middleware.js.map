{"version":3,"sources":["@wordpress/api-fetch/src/middlewares/fetch-all-middleware.js"],"names":["addQueryArgs","apiFetch","modifyQuery","queryArgs","path","url","options","parseResponse","response","json","Promise","reject","parseLinkHeader","linkHeader","match","next","getNextPageUrl","headers","get","requestContainsUnboundedQuery","pathIsUnbounded","indexOf","urlIsUnbounded","fetchAllMiddleware","parse","per_page","results","Array","isArray","nextPage","mergedResults","concat","undefined","nextResponse","nextResults"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { addQueryArgs } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport apiFetch from '..';\n\n/**\n * Apply query arguments to both URL and Path, whichever is present.\n *\n * @param {import('../types').ApiFetchRequestProps} props\n * @param {Record<string, string | number>} queryArgs\n * @return {import('../types').ApiFetchRequestProps} The request with the modified query args\n */\nconst modifyQuery = ( { path, url, ...options }, queryArgs ) => ( {\n\t...options,\n\turl: url && addQueryArgs( url, queryArgs ),\n\tpath: path && addQueryArgs( path, queryArgs ),\n} );\n\n/**\n * Duplicates parsing functionality from apiFetch.\n *\n * @param {Response} response\n * @return {Promise<any>} Parsed response json.\n */\nconst parseResponse = ( response ) =>\n\tresponse.json ? response.json() : Promise.reject( response );\n\n/**\n * @param {string | null} linkHeader\n * @return {{ next?: string }} The parsed link header.\n */\nconst parseLinkHeader = ( linkHeader ) => {\n\tif ( ! linkHeader ) {\n\t\treturn {};\n\t}\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\n\treturn match\n\t\t? {\n\t\t\t\tnext: match[ 1 ],\n\t\t  }\n\t\t: {};\n};\n\n/**\n * @param {Response} response\n * @return {string | undefined} The next page URL.\n */\nconst getNextPageUrl = ( response ) => {\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\n\treturn next;\n};\n\n/**\n * @param {import('../types').ApiFetchRequestProps} options\n * @return {boolean} True if the request contains an unbounded query.\n */\nconst requestContainsUnboundedQuery = ( options ) => {\n\tconst pathIsUnbounded =\n\t\t!! options.path && options.path.indexOf( 'per_page=-1' ) !== -1;\n\tconst urlIsUnbounded =\n\t\t!! options.url && options.url.indexOf( 'per_page=-1' ) !== -1;\n\treturn pathIsUnbounded || urlIsUnbounded;\n};\n\n/**\n * The REST API enforces an upper limit on the per_page option. To handle large\n * collections, apiFetch consumers can pass `per_page=-1`; this middleware will\n * then recursively assemble a full response array from all available pages.\n *\n * @type {import('../types').ApiFetchMiddleware}\n */\nconst fetchAllMiddleware = async ( options, next ) => {\n\tif ( options.parse === false ) {\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\n\t\treturn next( options );\n\t}\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\n\t\treturn next( options );\n\t}\n\n\t// Retrieve requested page of results.\n\tconst response = await apiFetch( {\n\t\t...modifyQuery( options, {\n\t\t\tper_page: 100,\n\t\t} ),\n\t\t// Ensure headers are returned for page 1.\n\t\tparse: false,\n\t} );\n\n\tconst results = await parseResponse( response );\n\n\tif ( ! Array.isArray( results ) ) {\n\t\t// We have no reliable way of merging non-array results.\n\t\treturn results;\n\t}\n\n\tlet nextPage = getNextPageUrl( response );\n\n\tif ( ! nextPage ) {\n\t\t// There are no further pages to request.\n\t\treturn results;\n\t}\n\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\n\tlet mergedResults = /** @type {any[]} */ ( [] ).concat( results );\n\twhile ( nextPage ) {\n\t\tconst nextResponse = await apiFetch( {\n\t\t\t...options,\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\n\t\t\tpath: undefined,\n\t\t\turl: nextPage,\n\t\t\t// Ensure we still get headers so we can identify the next page.\n\t\t\tparse: false,\n\t\t} );\n\t\tconst nextResults = await parseResponse( nextResponse );\n\t\tmergedResults = mergedResults.concat( nextResults );\n\t\tnextPage = getNextPageUrl( nextResponse );\n\t}\n\treturn mergedResults;\n};\n\nexport default fetchAllMiddleware;\n"]}