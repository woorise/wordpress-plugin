"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _reactNative = require("react-native");

var _reactNativeVideo = _interopRequireDefault(require("react-native-video"));

var _lodash = require("lodash");

var _reactNativeBridge = require("@wordpress/react-native-bridge");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _focalPoint = _interopRequireDefault(require("./focal-point"));

var _tooltip = _interopRequireDefault(require("./tooltip"));

var _style = _interopRequireDefault(require("./style.scss"));

var _utils = require("./utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var MIN_POSITION_VALUE = 0;
var MAX_POSITION_VALUE = 100;
var FOCAL_POINT_UNITS = [{
  default: '50',
  label: '%',
  value: '%'
}];

function FocalPointPicker(props) {
  var focalPoint = props.focalPoint,
      onChange = props.onChange,
      shouldEnableBottomSheetScroll = props.shouldEnableBottomSheetScroll,
      url = props.url;
  var isVideo = (0, _utils.isVideoType)(url);

  var _useState = (0, _element.useState)(null),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      containerSize = _useState2[0],
      setContainerSize = _useState2[1];

  var _useState3 = (0, _element.useState)(0),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      sliderKey = _useState4[0],
      setSliderKey = _useState4[1];

  var _useState5 = (0, _element.useState)(true),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      displayPlaceholder = _useState6[0],
      setDisplayPlaceholder = _useState6[1];

  var _useState7 = (0, _element.useState)(null),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      videoNaturalSize = _useState8[0],
      setVideoNaturalSize = _useState8[1];

  var _useState9 = (0, _element.useState)(false),
      _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
      tooltipVisible = _useState10[0],
      setTooltipVisible = _useState10[1];

  var locationPageOffsetX = (0, _element.useRef)().current;
  var locationPageOffsetY = (0, _element.useRef)().current;
  var videoRef = (0, _element.useRef)(null);
  (0, _element.useEffect)(function () {
    (0, _reactNativeBridge.requestFocalPointPickerTooltipShown)(function (tooltipShown) {
      if (!tooltipShown) {
        setTooltipVisible(true);
        (0, _reactNativeBridge.setFocalPointPickerTooltipShown)(true);
      }
    });
  }, []); // Animated coordinates for drag handle

  var pan = (0, _element.useRef)(new _reactNative.Animated.ValueXY()).current;
  /**
   * Set drag handle position anytime focal point coordinates change.
   * E.g. initial render, dragging range sliders.
   */

  (0, _element.useEffect)(function () {
    if (containerSize) {
      pan.setValue({
        x: focalPoint.x * containerSize.width,
        y: focalPoint.y * containerSize.height
      });
    }
  }, [focalPoint, containerSize]); // Pan responder to manage drag handle interactivity

  var panResponder = (0, _element.useMemo)(function () {
    return _reactNative.PanResponder.create({
      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {
        return true;
      },
      onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {
        return true;
      },
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder() {
        return true;
      },
      onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture() {
        return true;
      },
      onPanResponderGrant: function onPanResponderGrant(event) {
        shouldEnableBottomSheetScroll(false);
        var _event$nativeEvent = event.nativeEvent,
            x = _event$nativeEvent.locationX,
            y = _event$nativeEvent.locationY,
            pageX = _event$nativeEvent.pageX,
            pageY = _event$nativeEvent.pageY;
        locationPageOffsetX = pageX - x;
        locationPageOffsetY = pageY - y;
        pan.setValue({
          x: x,
          y: y
        }); // Set cursor to tap location

        pan.extractOffset(); // Set offset to current value
      },
      // Move cursor to match delta drag
      onPanResponderMove: _reactNative.Animated.event([null, {
        dx: pan.x,
        dy: pan.y
      }]),
      onPanResponderRelease: function onPanResponderRelease(event) {
        shouldEnableBottomSheetScroll(true);
        pan.flattenOffset(); // Flatten offset into value

        var _event$nativeEvent2 = event.nativeEvent,
            pageX = _event$nativeEvent2.pageX,
            pageY = _event$nativeEvent2.pageY; // Ideally, x and y below are merely locationX and locationY from the
        // nativeEvent. However, we are required to compute these relative
        // coordinates to workaround a bug affecting Android's PanResponder.
        // Specifically, dragging the handle outside the bounds of the image
        // results in inaccurate locationX and locationY coordinates to be
        // reported. https://git.io/JtWmi

        var x = pageX - locationPageOffsetX;
        var y = pageY - locationPageOffsetY;
        onChange({
          x: (0, _lodash.clamp)(x / (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width), 0, 1).toFixed(2),
          y: (0, _lodash.clamp)(y / (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height), 0, 1).toFixed(2)
        }); // Slider (child of RangeCell) is uncontrolled, so we must increment a
        // key to re-mount and sync the pan gesture values to the sliders
        // https://git.io/JTe4A

        setSliderKey(function (prevState) {
          return prevState + 1;
        });
      }
    });
  }, [containerSize]);
  var mediaBackground = (0, _compose.usePreferredColorSchemeStyle)(_style.default.mediaBackground, _style.default.mediaBackgroundDark);
  var imagePreviewStyles = [displayPlaceholder && _style.default.mediaPlaceholder, _style.default.image];
  var videoPreviewStyles = [{
    aspectRatio: videoNaturalSize && videoNaturalSize.width / videoNaturalSize.height,
    // Hide Video component since it has black background while loading the source
    opacity: displayPlaceholder ? 0 : 1
  }, _style.default.video, displayPlaceholder && _style.default.mediaPlaceholder];
  var focalPointGroupStyles = [_style.default.focalPointGroup, {
    transform: [{
      translateX: pan.x.interpolate({
        inputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) || 0],
        outputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) || 0],
        extrapolate: 'clamp'
      })
    }, {
      translateY: pan.y.interpolate({
        inputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) || 0],
        outputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) || 0],
        extrapolate: 'clamp'
      })
    }]
  }];
  var FOCAL_POINT_SIZE = 50;
  var focalPointStyles = [_style.default.focalPoint, {
    height: FOCAL_POINT_SIZE,
    marginLeft: -(FOCAL_POINT_SIZE / 2),
    marginTop: -(FOCAL_POINT_SIZE / 2),
    width: FOCAL_POINT_SIZE
  }];

  var onTooltipPress = function onTooltipPress() {
    return setTooltipVisible(false);
  };

  var onMediaLayout = function onMediaLayout(event) {
    var _event$nativeEvent$la = event.nativeEvent.layout,
        height = _event$nativeEvent$la.height,
        width = _event$nativeEvent$la.width;

    if (width !== 0 && height !== 0 && ((containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) !== width || (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) !== height)) {
      setContainerSize({
        width: width,
        height: height
      });
    }
  };

  var onImageDataLoad = function onImageDataLoad() {
    return setDisplayPlaceholder(false);
  };

  var onVideoLoad = function onVideoLoad(event) {
    var _event$naturalSize = event.naturalSize,
        height = _event$naturalSize.height,
        width = _event$naturalSize.width;
    setVideoNaturalSize({
      height: height,
      width: width
    });
    setDisplayPlaceholder(false); // Avoid invisible, paused video on Android, presumably related to
    // https://git.io/Jt6Dr

    videoRef === null || videoRef === void 0 ? void 0 : videoRef.current.seek(0);
  };

  var onXCoordinateChange = function onXCoordinateChange(x) {
    return onChange({
      x: (x / 100).toFixed(2)
    });
  };

  var onYCoordinateChange = function onYCoordinateChange(y) {
    return onChange({
      y: (y / 100).toFixed(2)
    });
  };

  return (0, _element.createElement)(_reactNative.View, {
    style: _style.default.container
  }, (0, _element.createElement)(_tooltip.default, {
    onPress: onTooltipPress,
    visible: tooltipVisible
  }, (0, _element.createElement)(_reactNative.View, {
    style: [_style.default.media, mediaBackground]
  }, (0, _element.createElement)(_reactNative.View, (0, _extends2.default)({}, panResponder.panHandlers, {
    onLayout: onMediaLayout,
    style: _style.default.mediaContainer
  }), !isVideo && (0, _element.createElement)(_components.Image, {
    editButton: false,
    highlightSelected: false,
    isSelected: !displayPlaceholder,
    height: "100%",
    url: url,
    style: imagePreviewStyles,
    onImageDataLoad: onImageDataLoad
  }), isVideo && (0, _element.createElement)(_reactNativeVideo.default, {
    muted: true,
    paused: true,
    disableFocus: true,
    onLoad: onVideoLoad,
    ref: videoRef,
    resizeMode: "contain",
    source: {
      uri: url
    },
    style: videoPreviewStyles
  }), !displayPlaceholder && (0, _element.createElement)(_reactNative.Animated.View, {
    pointerEvents: "none",
    style: focalPointGroupStyles
  }, (0, _element.createElement)(_tooltip.default.Label, {
    text: (0, _i18n.__)('Drag to adjust focal point'),
    yOffset: -(FOCAL_POINT_SIZE / 2)
  }), (0, _element.createElement)(_focalPoint.default, {
    height: _style.default.focalPoint.height,
    style: focalPointStyles,
    width: _style.default.focalPoint.width
  })))), (0, _element.createElement)(_components.UnitControl, {
    key: "xAxis-".concat(sliderKey),
    label: (0, _i18n.__)('X-Axis Position'),
    max: MAX_POSITION_VALUE,
    min: MIN_POSITION_VALUE,
    onChange: onXCoordinateChange,
    unit: "%",
    units: FOCAL_POINT_UNITS,
    value: Math.round(focalPoint.x * 100)
  }), (0, _element.createElement)(_components.UnitControl, {
    key: "yAxis-".concat(sliderKey),
    label: (0, _i18n.__)('Y-Axis Position'),
    max: MAX_POSITION_VALUE,
    min: MIN_POSITION_VALUE,
    onChange: onYCoordinateChange,
    unit: "%",
    units: FOCAL_POINT_UNITS,
    value: Math.round(focalPoint.y * 100)
  })));
}

var _default = FocalPointPicker;
exports.default = _default;
//# sourceMappingURL=index.native.js.map