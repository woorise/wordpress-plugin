"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classnames = _interopRequireDefault(require("classnames"));

var _dom = require("@wordpress/dom");

var _keycodes = require("@wordpress/keycodes");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _utils = require("./utils");

var _button = _interopRequireDefault(require("../button"));

var _scrollLock = _interopRequireDefault(require("../scroll-lock"));

var _slotFill = require("../slot-fill");

var _animate = require("../animate");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Name of slot in which popover should fill.
 *
 * @type {string}
 */
var SLOT_NAME = 'Popover';

function computeAnchorRect(anchorRefFallback, anchorRect, getAnchorRect) {
  var anchorRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var shouldAnchorIncludePadding = arguments.length > 4 ? arguments[4] : undefined;

  if (anchorRect) {
    return anchorRect;
  }

  if (getAnchorRect) {
    if (!anchorRefFallback.current) {
      return;
    }

    return (0, _utils.offsetIframe)(getAnchorRect(anchorRefFallback.current), anchorRefFallback.current.ownerDocument);
  }

  if (anchorRef !== false) {
    if (!anchorRef || !window.Range || !window.Element || !window.DOMRect) {
      return;
    } // Duck-type to check if `anchorRef` is an instance of Range
    // `anchorRef instanceof window.Range` checks will break across document boundaries
    // such as in an iframe


    if (typeof (anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.cloneRange) === 'function') {
      return (0, _utils.offsetIframe)((0, _dom.getRectangleFromRange)(anchorRef), anchorRef.endContainer.ownerDocument);
    } // Duck-type to check if `anchorRef` is an instance of Element
    // `anchorRef instanceof window.Element` checks will break across document boundaries
    // such as in an iframe


    if (typeof (anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.getBoundingClientRect) === 'function') {
      var _rect2 = (0, _utils.offsetIframe)(anchorRef.getBoundingClientRect(), anchorRef.ownerDocument);

      if (shouldAnchorIncludePadding) {
        return _rect2;
      }

      return withoutPadding(_rect2, anchorRef);
    }

    var top = anchorRef.top,
        bottom = anchorRef.bottom;
    var topRect = top.getBoundingClientRect();
    var bottomRect = bottom.getBoundingClientRect();

    var _rect = (0, _utils.offsetIframe)(new window.DOMRect(topRect.left, topRect.top, topRect.width, bottomRect.bottom - topRect.top), top.ownerDocument);

    if (shouldAnchorIncludePadding) {
      return _rect;
    }

    return withoutPadding(_rect, anchorRef);
  }

  if (!anchorRefFallback.current) {
    return;
  }

  var parentNode = anchorRefFallback.current.parentNode;
  var rect = parentNode.getBoundingClientRect();

  if (shouldAnchorIncludePadding) {
    return rect;
  }

  return withoutPadding(rect, parentNode);
}

function getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

function withoutPadding(rect, element) {
  var _getComputedStyle = getComputedStyle(element),
      paddingTop = _getComputedStyle.paddingTop,
      paddingBottom = _getComputedStyle.paddingBottom,
      paddingLeft = _getComputedStyle.paddingLeft,
      paddingRight = _getComputedStyle.paddingRight;

  var top = paddingTop ? parseInt(paddingTop, 10) : 0;
  var bottom = paddingBottom ? parseInt(paddingBottom, 10) : 0;
  var left = paddingLeft ? parseInt(paddingLeft, 10) : 0;
  var right = paddingRight ? parseInt(paddingRight, 10) : 0;
  return {
    x: rect.left + left,
    y: rect.top + top,
    width: rect.width - left - right,
    height: rect.height - top - bottom,
    left: rect.left + left,
    right: rect.right - right,
    top: rect.top + top,
    bottom: rect.bottom - bottom
  };
}
/**
 * Sets or removes an element attribute.
 *
 * @param {Element} element The element to modify.
 * @param {string}  name    The attribute name to set or remove.
 * @param {?string} value   The value to set. A falsy value will remove the
 *                          attribute.
 */


function setAttribute(element, name, value) {
  if (!value) {
    if (element.hasAttribute(name)) {
      element.removeAttribute(name);
    }
  } else if (element.getAttribute(name) !== value) {
    element.setAttribute(name, value);
  }
}
/**
 * Sets or removes an element style property.
 *
 * @param {Element} element  The element to modify.
 * @param {string}  property The property to set or remove.
 * @param {?string} value    The value to set. A falsy value will remove the
 *                           property.
 */


function setStyle(element, property) {
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  if (element.style[property] !== value) {
    element.style[property] = value;
  }
}
/**
 * Sets or removes an element class.
 *
 * @param {Element} element The element to modify.
 * @param {string}  name    The class to set or remove.
 * @param {boolean} toggle  True to set the class, false to remove.
 */


function setClass(element, name, toggle) {
  if (toggle) {
    if (!element.classList.contains(name)) {
      element.classList.add(name);
    }
  } else if (element.classList.contains(name)) {
    element.classList.remove(name);
  }
}

function getAnchorDocument(anchor) {
  if (!anchor) {
    return;
  }

  if (anchor.endContainer) {
    return anchor.endContainer.ownerDocument;
  }

  if (anchor.top) {
    return anchor.top.ownerDocument;
  }

  return anchor.ownerDocument;
}

var Popover = function Popover(_ref) {
  var headerTitle = _ref.headerTitle,
      onClose = _ref.onClose,
      onKeyDown = _ref.onKeyDown,
      children = _ref.children,
      className = _ref.className,
      _ref$noArrow = _ref.noArrow,
      noArrow = _ref$noArrow === void 0 ? true : _ref$noArrow,
      isAlternate = _ref.isAlternate,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'bottom right' : _ref$position,
      range = _ref.range,
      _ref$focusOnMount = _ref.focusOnMount,
      focusOnMount = _ref$focusOnMount === void 0 ? 'firstElement' : _ref$focusOnMount,
      anchorRef = _ref.anchorRef,
      shouldAnchorIncludePadding = _ref.shouldAnchorIncludePadding,
      anchorRect = _ref.anchorRect,
      getAnchorRect = _ref.getAnchorRect,
      expandOnMobile = _ref.expandOnMobile,
      _ref$animate = _ref.animate,
      animate = _ref$animate === void 0 ? true : _ref$animate,
      onClickOutside = _ref.onClickOutside,
      onFocusOutside = _ref.onFocusOutside,
      __unstableStickyBoundaryElement = _ref.__unstableStickyBoundaryElement,
      _ref$__unstableSlotNa = _ref.__unstableSlotName,
      __unstableSlotName = _ref$__unstableSlotNa === void 0 ? SLOT_NAME : _ref$__unstableSlotNa,
      __unstableObserveElement = _ref.__unstableObserveElement,
      __unstableBoundaryParent = _ref.__unstableBoundaryParent,
      __unstableForcePosition = _ref.__unstableForcePosition,
      contentProps = (0, _objectWithoutProperties2.default)(_ref, ["headerTitle", "onClose", "onKeyDown", "children", "className", "noArrow", "isAlternate", "position", "range", "focusOnMount", "anchorRef", "shouldAnchorIncludePadding", "anchorRect", "getAnchorRect", "expandOnMobile", "animate", "onClickOutside", "onFocusOutside", "__unstableStickyBoundaryElement", "__unstableSlotName", "__unstableObserveElement", "__unstableBoundaryParent", "__unstableForcePosition"]);

  var anchorRefFallback = (0, _element.useRef)(null);
  var contentRef = (0, _element.useRef)(null);
  var containerRef = (0, _element.useRef)();
  var isMobileViewport = (0, _compose.useViewportMatch)('medium', '<');

  var _useState = (0, _element.useState)(),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      animateOrigin = _useState2[0],
      setAnimateOrigin = _useState2[1];

  var slot = (0, _slotFill.useSlot)(__unstableSlotName);
  var isExpanded = expandOnMobile && isMobileViewport;

  var _useResizeObserver = (0, _compose.useResizeObserver)(),
      _useResizeObserver2 = (0, _slicedToArray2.default)(_useResizeObserver, 2),
      containerResizeListener = _useResizeObserver2[0],
      contentSize = _useResizeObserver2[1];

  noArrow = isExpanded || noArrow;
  (0, _element.useLayoutEffect)(function () {
    if (isExpanded) {
      setClass(containerRef.current, 'is-without-arrow', noArrow);
      setClass(containerRef.current, 'is-alternate', isAlternate);
      setAttribute(containerRef.current, 'data-x-axis');
      setAttribute(containerRef.current, 'data-y-axis');
      setStyle(containerRef.current, 'top');
      setStyle(containerRef.current, 'left');
      setStyle(contentRef.current, 'maxHeight');
      setStyle(contentRef.current, 'maxWidth');
      return;
    }

    var refresh = function refresh() {
      if (!containerRef.current || !contentRef.current) {
        return;
      }

      var anchor = computeAnchorRect(anchorRefFallback, anchorRect, getAnchorRect, anchorRef, shouldAnchorIncludePadding);

      if (!anchor) {
        return;
      }

      var _containerRef$current = containerRef.current,
          offsetParent = _containerRef$current.offsetParent,
          ownerDocument = _containerRef$current.ownerDocument;
      var relativeOffsetTop = 0; // If there is a positioned ancestor element that is not the body,
      // subtract the position from the anchor rect. If the position of
      // the popover is fixed, the offset parent is null or the body
      // element, in which case the position is relative to the viewport.
      // See https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent

      if (offsetParent && offsetParent !== ownerDocument.body) {
        var offsetParentRect = offsetParent.getBoundingClientRect();
        relativeOffsetTop = offsetParentRect.top;
        anchor = new window.DOMRect(anchor.left - offsetParentRect.left, anchor.top - offsetParentRect.top, anchor.width, anchor.height);
      }

      var boundaryElement;

      if (__unstableBoundaryParent) {
        var _containerRef$current2;

        boundaryElement = (_containerRef$current2 = containerRef.current.closest('.popover-slot')) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.parentNode;
      }

      var usedContentSize = !contentSize.height ? contentRef.current.getBoundingClientRect() : contentSize;

      var _computePopoverPositi = (0, _utils.computePopoverPosition)(anchor, usedContentSize, position, __unstableStickyBoundaryElement, containerRef.current, relativeOffsetTop, boundaryElement, __unstableForcePosition),
          popoverTop = _computePopoverPositi.popoverTop,
          popoverLeft = _computePopoverPositi.popoverLeft,
          xAxis = _computePopoverPositi.xAxis,
          yAxis = _computePopoverPositi.yAxis,
          contentHeight = _computePopoverPositi.contentHeight,
          contentWidth = _computePopoverPositi.contentWidth;

      if (typeof popoverTop === 'number' && typeof popoverLeft === 'number') {
        setStyle(containerRef.current, 'top', popoverTop + 'px');
        setStyle(containerRef.current, 'left', popoverLeft + 'px');
      }

      setClass(containerRef.current, 'is-without-arrow', noArrow || xAxis === 'center' && yAxis === 'middle');
      setClass(containerRef.current, 'is-alternate', isAlternate);
      setAttribute(containerRef.current, 'data-x-axis', xAxis);
      setAttribute(containerRef.current, 'data-y-axis', yAxis);
      setStyle(contentRef.current, 'maxHeight', typeof contentHeight === 'number' ? contentHeight + 'px' : '');
      setStyle(contentRef.current, 'maxWidth', typeof contentWidth === 'number' ? contentWidth + 'px' : ''); // Compute the animation position

      var yAxisMapping = {
        top: 'bottom',
        bottom: 'top'
      };
      var xAxisMapping = {
        left: 'right',
        right: 'left'
      };
      var animateYAxis = yAxisMapping[yAxis] || 'middle';
      var animateXAxis = xAxisMapping[xAxis] || 'center';
      setAnimateOrigin(animateXAxis + ' ' + animateYAxis);
    };

    refresh();
    var ownerDocument = containerRef.current.ownerDocument;
    var defaultView = ownerDocument.defaultView;
    /*
     * There are sometimes we need to reposition or resize the popover that
     * are not handled by the resize/scroll window events (i.e. CSS changes
     * in the layout that changes the position of the anchor).
     *
     * For these situations, we refresh the popover every 0.5s
     */

    var intervalHandle = defaultView.setInterval(refresh, 500);
    var rafId;

    var refreshOnAnimationFrame = function refreshOnAnimationFrame() {
      defaultView.cancelAnimationFrame(rafId);
      rafId = defaultView.requestAnimationFrame(refresh);
    }; // Sometimes a click trigger a layout change that affects the popover
    // position. This is an opportunity to immediately refresh rather than
    // at the interval.


    defaultView.addEventListener('click', refreshOnAnimationFrame);
    defaultView.addEventListener('resize', refresh);
    defaultView.addEventListener('scroll', refresh, true);
    var anchorDocument = getAnchorDocument(anchorRef); // If the anchor is within an iframe, the popover position also needs
    // to refrest when the iframe content is scrolled or resized.

    if (anchorDocument && anchorDocument !== ownerDocument) {
      anchorDocument.defaultView.addEventListener('resize', refresh);
      anchorDocument.defaultView.addEventListener('scroll', refresh, true);
    }

    var observer;

    if (__unstableObserveElement) {
      observer = new defaultView.MutationObserver(refresh);
      observer.observe(__unstableObserveElement, {
        attributes: true
      });
    }

    return function () {
      defaultView.clearInterval(intervalHandle);
      defaultView.removeEventListener('resize', refresh);
      defaultView.removeEventListener('scroll', refresh, true);
      defaultView.removeEventListener('click', refreshOnAnimationFrame);
      defaultView.cancelAnimationFrame(rafId);

      if (anchorDocument && anchorDocument !== ownerDocument) {
        anchorDocument.defaultView.removeEventListener('resize', refresh);
        anchorDocument.defaultView.removeEventListener('scroll', refresh, true);
      }

      if (observer) {
        observer.disconnect();
      }
    };
  }, [isExpanded, anchorRect, getAnchorRect, anchorRef, shouldAnchorIncludePadding, position, contentSize, __unstableStickyBoundaryElement, __unstableObserveElement, __unstableBoundaryParent]);
  var constrainedTabbingRef = (0, _compose.useConstrainedTabbing)();
  var focusReturnRef = (0, _compose.useFocusReturn)();
  var focusOnMountRef = (0, _compose.useFocusOnMount)(focusOnMount);
  var focusOutsideProps = (0, _compose.__experimentalUseFocusOutside)(handleOnFocusOutside);
  var mergedRefs = (0, _compose.useMergeRefs)([containerRef, focusOnMount ? constrainedTabbingRef : null, focusOnMount ? focusReturnRef : null, focusOnMount ? focusOnMountRef : null]); // Event handlers

  var maybeClose = function maybeClose(event) {
    // Close on escape
    if (event.keyCode === _keycodes.ESCAPE && onClose) {
      event.stopPropagation();
      onClose();
    } // Preserve original content prop behavior


    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  /**
   * Shims an onFocusOutside callback to be compatible with a deprecated
   * onClickOutside prop function, if provided.
   *
   * @param {FocusEvent} event Focus event from onFocusOutside.
   */


  function handleOnFocusOutside(event) {
    // Defer to given `onFocusOutside` if specified. Call `onClose` only if
    // both `onFocusOutside` and `onClickOutside` are unspecified. Doing so
    // assures backwards-compatibility for prior `onClickOutside` default.
    if (onFocusOutside) {
      onFocusOutside(event);
      return;
    } else if (!onClickOutside) {
      if (onClose) {
        onClose();
      }

      return;
    } // Simulate MouseEvent using FocusEvent#relatedTarget as emulated click
    // target. MouseEvent constructor is unsupported in Internet Explorer.


    var clickEvent;

    try {
      clickEvent = new window.MouseEvent('click');
    } catch (error) {
      clickEvent = document.createEvent('MouseEvent');
      clickEvent.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    }

    Object.defineProperty(clickEvent, 'target', {
      get: function get() {
        return event.relatedTarget;
      }
    });
    (0, _deprecated.default)('Popover onClickOutside prop', {
      since: '5.3',
      alternative: 'onFocusOutside'
    });
    onClickOutside(clickEvent);
  }
  /** @type {false | string} */


  var animateClassName = Boolean(animate && animateOrigin) && (0, _animate.getAnimateClassName)({
    type: 'appear',
    origin: animateOrigin
  }); // Disable reason: We care to capture the _bubbled_ events from inputs
  // within popover as inferring close intent.

  var content = // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
  // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  (0, _element.createElement)("div", (0, _extends2.default)({
    className: (0, _classnames.default)('components-popover', className, animateClassName, {
      'is-expanded': isExpanded,
      'is-without-arrow': noArrow,
      'is-alternate': isAlternate
    })
  }, contentProps, {
    onKeyDown: maybeClose
  }, focusOutsideProps, {
    ref: mergedRefs,
    tabIndex: "-1"
  }), isExpanded && (0, _element.createElement)(_scrollLock.default, null), isExpanded && (0, _element.createElement)("div", {
    className: "components-popover__header"
  }, (0, _element.createElement)("span", {
    className: "components-popover__header-title"
  }, headerTitle), (0, _element.createElement)(_button.default, {
    className: "components-popover__close",
    icon: _icons.close,
    onClick: onClose
  })), (0, _element.createElement)("div", {
    ref: contentRef,
    className: "components-popover__content"
  }, (0, _element.createElement)("div", {
    style: {
      position: 'relative'
    }
  }, containerResizeListener, children)));

  if (slot.ref) {
    content = (0, _element.createElement)(_slotFill.Fill, {
      name: __unstableSlotName
    }, content);
  }

  if (anchorRef || anchorRect) {
    return content;
  }

  return (0, _element.createElement)("span", {
    ref: anchorRefFallback
  }, content);
};

var PopoverContainer = Popover;

PopoverContainer.Slot = function (_ref2) {
  var _ref2$name = _ref2.name,
      name = _ref2$name === void 0 ? SLOT_NAME : _ref2$name;
  return (0, _element.createElement)(_slotFill.Slot, {
    bubblesVirtually: true,
    name: name,
    className: "popover-slot"
  });
};

var _default = PopoverContainer;
exports.default = _default;
//# sourceMappingURL=index.js.map