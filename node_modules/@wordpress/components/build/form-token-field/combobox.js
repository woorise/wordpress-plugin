"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _lodash = require("lodash");

var _classnames = _interopRequireDefault(require("classnames"));

var _i18n = require("@wordpress/i18n");

var _compose = require("@wordpress/compose");

var _keycodes = require("@wordpress/keycodes");

var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));

var _tokenInput = _interopRequireDefault(require("./token-input"));

var _suggestionsList = _interopRequireDefault(require("./suggestions-list"));

var _withSpokenMessages = _interopRequireDefault(require("../higher-order/with-spoken-messages"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var initialState = {
  incompleteTokenValue: '',
  isActive: false,
  isExpanded: false,
  selectedSuggestion: null
};

var ComboboxControl = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(ComboboxControl, _Component);

  var _super = _createSuper(ComboboxControl);

  function ComboboxControl() {
    var _this;

    (0, _classCallCheck2.default)(this, ComboboxControl);
    _this = _super.apply(this, arguments);
    _this.state = initialState;
    _this.onKeyDown = _this.onKeyDown.bind((0, _assertThisInitialized2.default)(_this));
    _this.onFocus = _this.onFocus.bind((0, _assertThisInitialized2.default)(_this));
    _this.onBlur = _this.onBlur.bind((0, _assertThisInitialized2.default)(_this));
    _this.onContainerTouched = _this.onContainerTouched.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSuggestionHovered = _this.onSuggestionHovered.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSuggestionSelected = _this.onSuggestionSelected.bind((0, _assertThisInitialized2.default)(_this));
    _this.onInputChange = _this.onInputChange.bind((0, _assertThisInitialized2.default)(_this));
    _this.bindInput = _this.bindInput.bind((0, _assertThisInitialized2.default)(_this));
    _this.bindTokensAndInput = _this.bindTokensAndInput.bind((0, _assertThisInitialized2.default)(_this));
    _this.updateSuggestions = _this.updateSuggestions.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(ComboboxControl, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      // Make sure to focus the input when the isActive state is true.
      if (this.state.isActive && !this.input.hasFocus()) {
        this.input.focus();
      }

      var _this$props = this.props,
          suggestions = _this$props.suggestions,
          value = _this$props.value;
      var suggestionsDidUpdate = !(0, _isShallowEqual.default)(suggestions, prevProps.suggestions);

      if (suggestionsDidUpdate || value !== prevProps.value) {
        this.updateSuggestions();
      }
    }
  }, {
    key: "bindInput",
    value: function bindInput(ref) {
      this.input = ref;
    }
  }, {
    key: "bindTokensAndInput",
    value: function bindTokensAndInput(ref) {
      this.tokensAndInput = ref;
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      // If focus is on the input or on the container, set the isActive state to true.
      if (this.input.hasFocus() || event.target === this.tokensAndInput) {
        this.setState({
          isActive: true
        });
      } else {
        /*
         * Otherwise, focus is on one of the token "remove" buttons and we
         * set the isActive state to false to prevent the input to be
         * re-focused, see componentDidUpdate().
         */
        this.setState({
          isActive: false
        });
      }

      if ('function' === typeof this.props.onFocus) {
        this.props.onFocus(event);
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        isActive: false,
        incompleteTokenValue: this.props.value,
        isExpanded: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var preventDefault = false;

      switch (event.keyCode) {
        case _keycodes.ENTER:
          if (this.state.selectedSuggestion) {
            this.onSuggestionSelected(this.state.selectedSuggestion);
            preventDefault = true;
          }

          break;

        case _keycodes.LEFT:
          preventDefault = this.handleLeftArrowKey();
          break;

        case _keycodes.UP:
          preventDefault = this.handleUpArrowKey();
          break;

        case _keycodes.RIGHT:
          preventDefault = this.handleRightArrowKey();
          break;

        case _keycodes.DOWN:
          preventDefault = this.handleDownArrowKey();
          break;

        case _keycodes.ESCAPE:
          preventDefault = this.handleEscapeKey(event);
          event.stopPropagation();
          break;

        default:
          break;
      }

      if (preventDefault) {
        event.preventDefault();
      }
    }
  }, {
    key: "onContainerTouched",
    value: function onContainerTouched(event) {
      // Prevent clicking/touching the tokensAndInput container from blurring
      // the input and adding the current token.
      if (event.target === this.tokensAndInput && this.state.isActive) {
        event.preventDefault();
      }
    }
  }, {
    key: "onSuggestionHovered",
    value: function onSuggestionHovered(suggestion) {
      this.setState({
        selectedSuggestion: suggestion
      });
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(event) {
      var text = event.value;
      this.setState({
        incompleteTokenValue: text
      }, this.updateSuggestions);
      this.props.onInputChange(text);
    }
  }, {
    key: "handleUpArrowKey",
    value: function handleUpArrowKey() {
      var matchingSuggestions = this.getMatchingSuggestions();
      var index = matchingSuggestions.indexOf(this.state.selectedSuggestion);

      if (index === 0 || index === -1) {
        this.setState({
          selectedSuggestion: matchingSuggestions[matchingSuggestions.length - 1]
        });
      } else {
        this.setState({
          selectedSuggestion: matchingSuggestions[index - 1]
        });
      }

      return true; // preventDefault
    }
  }, {
    key: "handleDownArrowKey",
    value: function handleDownArrowKey() {
      var matchingSuggestions = this.getMatchingSuggestions();
      var index = matchingSuggestions.indexOf(this.state.selectedSuggestion);

      if (index === matchingSuggestions.length - 1 || index === -1) {
        this.setState({
          selectedSuggestion: matchingSuggestions[0]
        });
      } else {
        this.setState({
          selectedSuggestion: matchingSuggestions[index + 1]
        });
      }

      return true; // preventDefault
    }
  }, {
    key: "handleEscapeKey",
    value: function handleEscapeKey(event) {
      this.setState({
        incompleteTokenValue: event.target.value,
        isExpanded: false,
        selectedSuggestion: null
      });
      return true; // preventDefault
    }
  }, {
    key: "onSuggestionSelected",
    value: function onSuggestionSelected(newValue) {
      this.props.onChange(newValue);
      this.props.speak(this.props.messages.selected, 'assertive');

      if (this.state.isActive) {
        this.input.focus();
      }

      this.setState({
        incompleteTokenValue: newValue,
        selectedSuggestion: null,
        isExpanded: false
      });
    }
  }, {
    key: "getMatchingSuggestions",
    value: function getMatchingSuggestions() {
      var searchValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.incompleteTokenValue;
      var suggestions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.suggestions;
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.value;
      var maxSuggestions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props.maxSuggestions;
      var saveTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.props.saveTransform;
      var match = saveTransform(searchValue);
      var startsWithMatch = [];
      var containsMatch = [];

      if (!match || match.length === 0) {
        suggestions = (0, _lodash.difference)(suggestions, value);
      } else {
        match = match.toLocaleLowerCase();
        (0, _lodash.each)(suggestions, function (suggestion) {
          var index = suggestion.toLocaleLowerCase().indexOf(match);

          if (index === 0) {
            startsWithMatch.push(suggestion);
          } else if (index > 0) {
            containsMatch.push(suggestion);
          }
        });
        suggestions = startsWithMatch.concat(containsMatch);
      }

      return (0, _lodash.take)(suggestions, maxSuggestions);
    }
  }, {
    key: "updateSuggestions",
    value: function updateSuggestions() {
      var _this$state = this.state,
          incompleteTokenValue = _this$state.incompleteTokenValue,
          selectedSuggestion = _this$state.selectedSuggestion;
      var inputHasMinimumChars = !!incompleteTokenValue && incompleteTokenValue.trim().length > 1;
      var matchingSuggestions = this.getMatchingSuggestions(incompleteTokenValue);
      var hasMatchingSuggestions = matchingSuggestions.length > 0;
      var newState = {
        isExpanded: inputHasMinimumChars && hasMatchingSuggestions
      };

      if (matchingSuggestions.indexOf(selectedSuggestion) === -1) {
        newState.selectedSuggestion = null;
      }

      if (!incompleteTokenValue || matchingSuggestions.indexOf(this.props.value) === -1) {
        this.props.onChange(null);
      }

      this.setState(newState);

      if (inputHasMinimumChars) {
        var debouncedSpeak = this.props.debouncedSpeak;
        var message = hasMatchingSuggestions ? (0, _i18n.sprintf)(
        /* translators: %d: number of results. */
        (0, _i18n._n)('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', matchingSuggestions.length), matchingSuggestions.length) : (0, _i18n.__)('No results.');
        debouncedSpeak(message, 'assertive');
      }
    }
  }, {
    key: "renderInput",
    value: function renderInput() {
      var _this$props2 = this.props,
          autoCapitalize = _this$props2.autoCapitalize,
          autoComplete = _this$props2.autoComplete,
          maxLength = _this$props2.maxLength,
          value = _this$props2.value,
          instanceId = _this$props2.instanceId;
      var matchingSuggestions = this.getMatchingSuggestions();
      var props = {
        instanceId: instanceId,
        autoCapitalize: autoCapitalize,
        autoComplete: autoComplete,
        ref: this.bindInput,
        key: 'input',
        disabled: this.props.disabled,
        value: this.state.incompleteTokenValue,
        onBlur: this.onBlur,
        isExpanded: this.state.isExpanded,
        selectedSuggestionIndex: matchingSuggestions.indexOf(this.state.selectedSuggestion)
      };

      if (!(maxLength && value.length >= maxLength)) {
        props = _objectSpread(_objectSpread({}, props), {}, {
          onChange: this.onInputChange
        });
      }

      return (0, _element.createElement)(_tokenInput.default, props);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          disabled = _this$props3.disabled,
          _this$props3$label = _this$props3.label,
          label = _this$props3$label === void 0 ? (0, _i18n.__)('Select item') : _this$props3$label,
          instanceId = _this$props3.instanceId,
          className = _this$props3.className;
      var _this$state2 = this.state,
          isExpanded = _this$state2.isExpanded,
          selectedSuggestion = _this$state2.selectedSuggestion,
          incompleteTokenValue = _this$state2.incompleteTokenValue;
      var classes = (0, _classnames.default)(className, 'components-form-token-field__input-container', {
        'is-active': this.state.isActive,
        'is-disabled': disabled
      });
      var tokenFieldProps = {
        className: 'components-form-token-field',
        tabIndex: '-1'
      };
      var matchingSuggestions = this.getMatchingSuggestions();

      if (!disabled) {
        tokenFieldProps = Object.assign({}, tokenFieldProps, {
          onKeyDown: this.onKeyDown,
          onFocus: this.onFocus
        });
      } // Disable reason: There is no appropriate role which describes the
      // input container intended accessible usability.
      // TODO: Refactor click detection to use blur to stop propagation.

      /* eslint-disable jsx-a11y/no-static-element-interactions */


      return (0, _element.createElement)("div", tokenFieldProps, (0, _element.createElement)("label", {
        htmlFor: "components-form-token-input-".concat(instanceId),
        className: "components-form-token-field__label"
      }, label), (0, _element.createElement)("div", {
        ref: this.bindTokensAndInput,
        className: classes,
        tabIndex: "-1",
        onMouseDown: this.onContainerTouched,
        onTouchStart: this.onContainerTouched
      }, this.renderInput(), isExpanded && (0, _element.createElement)(_suggestionsList.default, {
        instanceId: instanceId,
        match: this.props.saveTransform(incompleteTokenValue),
        displayTransform: this.props.displayTransform,
        suggestions: matchingSuggestions,
        selectedIndex: matchingSuggestions.indexOf(selectedSuggestion),
        onHover: this.onSuggestionHovered,
        onSelect: this.onSuggestionSelected
      })));
      /* eslint-enable jsx-a11y/no-static-element-interactions */
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (!props.disabled || !state.isActive) {
        return null;
      }

      return {
        isActive: false,
        incompleteTokenValue: ''
      };
    }
  }]);
  return ComboboxControl;
}(_element.Component);

ComboboxControl.defaultProps = {
  suggestions: Object.freeze([]),
  maxSuggestions: 100,
  value: null,
  displayTransform: _lodash.identity,
  saveTransform: _lodash.identity,
  onChange: function onChange() {},
  onInputChange: function onInputChange() {},
  isBorderless: false,
  disabled: false,
  messages: {
    selected: (0, _i18n.__)('Item selected.')
  }
};

var _default = (0, _withSpokenMessages.default)((0, _compose.withInstanceId)(ComboboxControl));

exports.default = _default;
//# sourceMappingURL=combobox.js.map