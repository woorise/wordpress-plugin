"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLinearGradientRepresentationOfARadial = getLinearGradientRepresentationOfARadial;
exports.getGradientAstWithDefault = getGradientAstWithDefault;
exports.getGradientAstWithControlPoints = getGradientAstWithControlPoints;
exports.getStopCssColor = getStopCssColor;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _gradientParser = _interopRequireDefault(require("gradient-parser"));

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _constants = require("./constants");

var _serializer = require("./serializer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getLinearGradientRepresentationOfARadial(gradientAST) {
  return (0, _serializer.serializeGradient)({
    type: 'linear-gradient',
    orientation: _constants.HORIZONTAL_GRADIENT_ORIENTATION,
    colorStops: gradientAST.colorStops
  });
}

function hasUnsupportedLength(item) {
  return item.length === undefined || item.length.type !== '%';
}

function getGradientAstWithDefault(value) {
  var _gradientAST$orientat;

  // gradientAST will contain the gradient AST as parsed by gradient-parser npm module.
  // More information of its structure available at https://www.npmjs.com/package/gradient-parser#ast.
  var gradientAST;

  try {
    gradientAST = _gradientParser.default.parse(value)[0];
    gradientAST.value = value;
  } catch (error) {
    gradientAST = _gradientParser.default.parse(_constants.DEFAULT_GRADIENT)[0];
    gradientAST.value = _constants.DEFAULT_GRADIENT;
  }

  if (((_gradientAST$orientat = gradientAST.orientation) === null || _gradientAST$orientat === void 0 ? void 0 : _gradientAST$orientat.type) === 'directional') {
    gradientAST.orientation.type = 'angular';
    gradientAST.orientation.value = _constants.DIRECTIONAL_ORIENTATION_ANGLE_MAP[gradientAST.orientation.value].toString();
  }

  if (gradientAST.colorStops.some(hasUnsupportedLength)) {
    var _gradientAST = gradientAST,
        colorStops = _gradientAST.colorStops;
    var step = 100 / (colorStops.length - 1);
    colorStops.forEach(function (stop, index) {
      stop.length = {
        value: step * index,
        type: '%'
      };
    });
    gradientAST.value = (0, _serializer.serializeGradient)(gradientAST);
  }

  return gradientAST;
}

function getGradientAstWithControlPoints(gradientAST, newControlPoints) {
  return _objectSpread(_objectSpread({}, gradientAST), {}, {
    colorStops: newControlPoints.map(function (_ref) {
      var position = _ref.position,
          color = _ref.color;

      var _tinycolor$toRgb = (0, _tinycolor.default)(color).toRgb(),
          r = _tinycolor$toRgb.r,
          g = _tinycolor$toRgb.g,
          b = _tinycolor$toRgb.b,
          a = _tinycolor$toRgb.a;

      return {
        length: {
          type: '%',
          value: position.toString()
        },
        type: a < 1 ? 'rgba' : 'rgb',
        value: a < 1 ? [r, g, b, a] : [r, g, b]
      };
    })
  });
}

function getStopCssColor(colorStop) {
  switch (colorStop.type) {
    case 'hex':
      return "#".concat(colorStop.value);

    case 'literal':
      return colorStop.value;

    case 'rgb':
    case 'rgba':
      return "".concat(colorStop.type, "(").concat(colorStop.value.join(','), ")");

    default:
      // Should be unreachable if passing an AST from gradient-parser.
      // See https://github.com/rafaelcaricio/gradient-parser#ast.
      return 'transparent';
  }
}
//# sourceMappingURL=utils.js.map