"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Draggable;

var _element = require("@wordpress/element");

/**
 * WordPress dependencies
 */
var dragImageClass = 'components-draggable__invisible-drag-image';
var cloneWrapperClass = 'components-draggable__clone';
var cloneHeightTransformationBreakpoint = 700;
var clonePadding = 0;
var bodyClass = 'is-dragging-components-draggable';

function Draggable(_ref) {
  var children = _ref.children,
      onDragStart = _ref.onDragStart,
      onDragOver = _ref.onDragOver,
      onDragEnd = _ref.onDragEnd,
      cloneClassname = _ref.cloneClassname,
      elementId = _ref.elementId,
      transferData = _ref.transferData,
      dragComponent = _ref.__experimentalDragComponent;
  var dragComponentRef = (0, _element.useRef)();
  var cleanup = (0, _element.useRef)(function () {});
  /**
   * Removes the element clone, resets cursor, and removes drag listener.
   *
   * @param {Object} event The non-custom DragEvent.
   */

  function end(event) {
    event.preventDefault();
    cleanup.current();

    if (onDragOver) {
      onDragEnd(event);
    }
  }
  /**
   * This method does a couple of things:
   *
   * - Clones the current element and spawns clone over original element.
   * - Adds a fake temporary drag image to avoid browser defaults.
   * - Sets transfer data.
   * - Adds dragover listener.
   *
   * @param {Object} event The non-custom DragEvent.
   */


  function start(event) {
    var ownerDocument = event.target.ownerDocument;
    event.dataTransfer.setData('text', JSON.stringify(transferData));
    var cloneWrapper = ownerDocument.createElement('div');
    var dragImage = ownerDocument.createElement('div'); // Set a fake drag image to avoid browser defaults. Remove from DOM
    // right after. event.dataTransfer.setDragImage is not supported yet in
    // IE, we need to check for its existence first.

    if ('function' === typeof event.dataTransfer.setDragImage) {
      dragImage.classList.add(dragImageClass);
      ownerDocument.body.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, 0, 0);
    }

    cloneWrapper.classList.add(cloneWrapperClass);

    if (cloneClassname) {
      cloneWrapper.classList.add(cloneClassname);
    } // If a dragComponent is defined, the following logic will clone the
    // HTML node and inject it into the cloneWrapper.


    if (dragComponentRef.current) {
      // Position dragComponent at the same position as the cursor.
      cloneWrapper.style.top = "".concat(event.clientY, "px");
      cloneWrapper.style.left = "".concat(event.clientX, "px");
      var clonedDragComponent = ownerDocument.createElement('div');
      clonedDragComponent.innerHTML = dragComponentRef.current.innerHTML;
      cloneWrapper.appendChild(clonedDragComponent); // Inject the cloneWrapper into the DOM.

      ownerDocument.body.appendChild(cloneWrapper);
    } else {
      var element = ownerDocument.getElementById(elementId); // Prepare element clone and append to element wrapper.

      var elementRect = element.getBoundingClientRect();
      var elementWrapper = element.parentNode;
      var elementTopOffset = parseInt(elementRect.top, 10);
      var elementLeftOffset = parseInt(elementRect.left, 10);
      cloneWrapper.style.width = "".concat(elementRect.width + clonePadding * 2, "px");
      var clone = element.cloneNode(true);
      clone.id = "clone-".concat(elementId);

      if (elementRect.height > cloneHeightTransformationBreakpoint) {
        // Scale down clone if original element is larger than 700px.
        cloneWrapper.style.transform = 'scale(0.5)';
        cloneWrapper.style.transformOrigin = 'top left'; // Position clone near the cursor.

        cloneWrapper.style.top = "".concat(event.clientY - 100, "px");
        cloneWrapper.style.left = "".concat(event.clientX, "px");
      } else {
        // Position clone right over the original element (20px padding).
        cloneWrapper.style.top = "".concat(elementTopOffset - clonePadding, "px");
        cloneWrapper.style.left = "".concat(elementLeftOffset - clonePadding, "px");
      } // Hack: Remove iFrames as it's causing the embeds drag clone to freeze


      Array.from(clone.querySelectorAll('iframe')).forEach(function (child) {
        return child.parentNode.removeChild(child);
      });
      cloneWrapper.appendChild(clone); // Inject the cloneWrapper into the DOM.

      elementWrapper.appendChild(cloneWrapper);
    } // Mark the current cursor coordinates.


    var cursorLeft = event.clientX;
    var cursorTop = event.clientY;

    function over(e) {
      cloneWrapper.style.top = "".concat(parseInt(cloneWrapper.style.top, 10) + e.clientY - cursorTop, "px");
      cloneWrapper.style.left = "".concat(parseInt(cloneWrapper.style.left, 10) + e.clientX - cursorLeft, "px"); // Update cursor coordinates.

      cursorLeft = e.clientX;
      cursorTop = e.clientY;

      if (onDragOver) {
        onDragOver(e);
      }
    }

    ownerDocument.addEventListener('dragover', over); // Update cursor to 'grabbing', document wide.

    ownerDocument.body.classList.add(bodyClass); // Allow the Synthetic Event to be accessed from asynchronous code.
    // https://reactjs.org/docs/events.html#event-pooling

    event.persist();
    var timerId;

    if (onDragStart) {
      timerId = setTimeout(function () {
        return onDragStart(event);
      });
    }

    cleanup.current = function () {
      // Remove drag clone
      if (cloneWrapper && cloneWrapper.parentNode) {
        cloneWrapper.parentNode.removeChild(cloneWrapper);
      }

      if (dragImage && dragImage.parentNode) {
        dragImage.parentNode.removeChild(dragImage);
      } // Reset cursor.


      ownerDocument.body.classList.remove(bodyClass);
      ownerDocument.removeEventListener('dragover', over);
      clearTimeout(timerId);
    };
  }

  (0, _element.useEffect)(function () {
    return function () {
      cleanup.current();
    };
  }, []);
  return (0, _element.createElement)(_element.Fragment, null, children({
    onDraggableStart: start,
    onDraggableEnd: end
  }), dragComponent && (0, _element.createElement)("div", {
    className: "components-draggable-drag-component-root",
    style: {
      display: 'none'
    },
    ref: dragComponentRef
  }, dragComponent));
}
//# sourceMappingURL=index.js.map