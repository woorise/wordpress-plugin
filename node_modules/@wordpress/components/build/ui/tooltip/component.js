"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _context = require("@wp-g2/context");

var _reakit = require("reakit");

var _context2 = require("./context");

var _content = _interopRequireDefault(require("./content"));

var _styles = require("./styles");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @param {import('@wp-g2/create-styles').ViewOwnProps<import('./types').Props, 'div'>} props
 * @param {import('react').Ref<any>} forwardedRef
 */
function Tooltip(props, forwardedRef) {
  var _useContextSystem = (0, _context.useContextSystem)(props, 'Tooltip'),
      _useContextSystem$ani = _useContextSystem.animated,
      animated = _useContextSystem$ani === void 0 ? true : _useContextSystem$ani,
      _useContextSystem$ani2 = _useContextSystem.animationDuration,
      animationDuration = _useContextSystem$ani2 === void 0 ? 160 : _useContextSystem$ani2,
      baseId = _useContextSystem.baseId,
      children = _useContextSystem.children,
      content = _useContextSystem.content,
      _useContextSystem$foc = _useContextSystem.focusable,
      focusable = _useContextSystem$foc === void 0 ? true : _useContextSystem$foc,
      _useContextSystem$gut = _useContextSystem.gutter,
      gutter = _useContextSystem$gut === void 0 ? 4 : _useContextSystem$gut,
      id = _useContextSystem.id,
      _useContextSystem$mod = _useContextSystem.modal,
      modal = _useContextSystem$mod === void 0 ? true : _useContextSystem$mod,
      placement = _useContextSystem.placement,
      _useContextSystem$vis = _useContextSystem.visible,
      visible = _useContextSystem$vis === void 0 ? false : _useContextSystem$vis,
      shortcut = _useContextSystem.shortcut,
      otherProps = (0, _objectWithoutProperties2.default)(_useContextSystem, ["animated", "animationDuration", "baseId", "children", "content", "focusable", "gutter", "id", "modal", "placement", "visible", "shortcut"]);

  var tooltip = (0, _reakit.useTooltipState)(_objectSpread({
    animated: animated ? animationDuration : undefined,
    baseId: baseId || id,
    gutter: gutter,
    placement: placement,
    visible: visible
  }, otherProps));
  var contextProps = (0, _element.useMemo)(function () {
    return {
      tooltip: tooltip
    };
  }, [tooltip]);
  return (0, _element.createElement)(_context2.TooltipContext.Provider, {
    value: contextProps
  }, content && (0, _element.createElement)(_content.default, {
    unstable_portal: modal,
    ref: forwardedRef
  }, content, shortcut && (0, _element.createElement)(_styles.TooltipShortcut, {
    shortcut: shortcut
  })), children && (0, _element.createElement)(_reakit.TooltipReference, (0, _extends2.default)({}, tooltip, children.props, {
    // @ts-ignore If ref doesn't exist that's fine with us, it'll just be undefined, but it can exist on ReactElement and there's no reason to try to scope this (it'll just overcomplicate things)
    ref: children === null || children === void 0 ? void 0 : children.ref
  }), function (referenceProps) {
    if (!focusable) {
      referenceProps.tabIndex = undefined;
    }

    return (0, _element.cloneElement)(children, referenceProps);
  }));
}
/**
 * `Tooltip` is a component that provides context for a user interface element.
 *
 * @example
 * ```jsx
 * import { Tooltip, Text } from `@wordpress/components/ui`;
 *
 * function Example() {
 * 	return (
 * 		<Tooltip content="Code is Poetry">
 * 			<Text>WordPress.org</Text>
 * 		</Tooltip>
 * 	)
 * }
 * ```
 */


var ConnectedTooltip = (0, _context.contextConnect)(Tooltip, 'Tooltip');
var _default = ConnectedTooltip;
exports.default = _default;
//# sourceMappingURL=component.js.map