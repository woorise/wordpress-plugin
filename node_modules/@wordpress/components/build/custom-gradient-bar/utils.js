"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clampPercent = clampPercent;
exports.isOverlapping = isOverlapping;
exports.addControlPoint = addControlPoint;
exports.removeControlPoint = removeControlPoint;
exports.updateControlPoint = updateControlPoint;
exports.updateControlPointPosition = updateControlPointPosition;
exports.updateControlPointColor = updateControlPointColor;
exports.updateControlPointColorByPosition = updateControlPointColorByPosition;
exports.getHorizontalRelativeGradientPosition = getHorizontalRelativeGradientPosition;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Control point for the gradient bar.
 *
 * @typedef {Object} ControlPoint
 * @property {string} color    Color of the control point.
 * @property {number} position Integer position of the control point as a percentage.
 */

/**
 * Color as parsed from the gradient by gradient-parser.
 *
 * @typedef {Object} Color
 * @property {string} r   Red component.
 * @property {string} g   Green component.
 * @property {string} b   Green component.
 * @property {string} [a] Optional alpha component.
 */

/**
 * Clamps a number between 0 and 100.
 *
 * @param {number} value Value to clamp.
 *
 * @return {number} Value clamped between 0 and 100.
 */
function clampPercent(value) {
  return Math.max(0, Math.min(100, value));
}
/**
 * Check if a control point is overlapping with another.
 *
 * @param {ControlPoint[]} value        Array of control points.
 * @param {number}         initialIndex Index of the position to test.
 * @param {number}         newPosition  New position of the control point.
 * @param {number}         minDistance  Distance considered to be overlapping.
 *
 * @return {boolean} True if the point is overlapping.
 */


function isOverlapping(value, initialIndex, newPosition) {
  var minDistance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.MINIMUM_DISTANCE_BETWEEN_POINTS;
  var initialPosition = value[initialIndex].position;
  var minPosition = Math.min(initialPosition, newPosition);
  var maxPosition = Math.max(initialPosition, newPosition);
  return value.some(function (_ref, index) {
    var position = _ref.position;
    return index !== initialIndex && (Math.abs(position - newPosition) < minDistance || minPosition < position && position < maxPosition);
  });
}
/**
 * Adds a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         position Position to insert the new point.
 * @param {Color}          color    Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function addControlPoint(points, position, color) {
  var nextIndex = points.findIndex(function (point) {
    return point.position > position;
  });
  var newPoint = {
    color: color,
    position: position
  };
  var newPoints = points.slice();
  newPoints.splice(nextIndex - 1, 0, newPoint);
  return newPoints;
}
/**
 * Removes a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points Array of control points.
 * @param {number}         index  Index to remove.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function removeControlPoint(points, index) {
  return points.filter(function (point, pointIndex) {
    return pointIndex !== index;
  });
}
/**
 * Updates a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         index    Index to update.
 * @param {ControlPoint[]} newPoint New control point to replace the index.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function updateControlPoint(points, index, newPoint) {
  var newValue = points.slice();
  newValue[index] = newPoint;
  return newValue;
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points      Array of control points.
 * @param {number}         index       Index to update.
 * @param {number}         newPosition Position to move the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function updateControlPointPosition(points, index, newPosition) {
  if (isOverlapping(points, index, newPosition)) {
    return points;
  }

  var newPoint = _objectSpread(_objectSpread({}, points[index]), {}, {
    position: newPosition
  });

  return updateControlPoint(points, index, newPoint);
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         index    Index to update.
 * @param {Color}          newColor Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function updateControlPointColor(points, index, newColor) {
  var newPoint = _objectSpread(_objectSpread({}, points[index]), {}, {
    color: newColor
  });

  return updateControlPoint(points, index, newPoint);
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         position Position of the color stop.
 * @param {string}         newColor Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */


function updateControlPointColorByPosition(points, position, newColor) {
  var index = points.findIndex(function (point) {
    return point.position === position;
  });
  return updateControlPointColor(points, index, newColor);
}
/**
 * Gets the horizontal coordinate when dragging a control point with the mouse.
 *
 * @param {number}  mouseXCoordinate       Horizontal coordinate of the mouse position.
 * @param {Element} containerElement       Container for the gradient picker.
 * @param {number}  positionedElementWidth Width of the positioned element.
 *
 * @return {number} Whole number percentage from the left.
 */


function getHorizontalRelativeGradientPosition(mouseXCoordinate, containerElement, positionedElementWidth) {
  if (!containerElement) {
    return;
  }

  var _containerElement$get = containerElement.getBoundingClientRect(),
      x = _containerElement$get.x,
      width = _containerElement$get.width;

  var absolutePositionValue = mouseXCoordinate - x - _constants.MINIMUM_ABSOLUTE_LEFT_POSITION - positionedElementWidth / 2;
  var availableWidth = width - _constants.MINIMUM_ABSOLUTE_LEFT_POSITION - _constants.INSERT_POINT_WIDTH;
  return Math.round(clampPercent(absolutePositionValue * 100 / availableWidth));
}
//# sourceMappingURL=utils.js.map