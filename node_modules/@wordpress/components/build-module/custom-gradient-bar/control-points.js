import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { useInstanceId } from '@wordpress/compose';
import { useEffect, useRef, useState } from '@wordpress/element';
import { __, sprintf } from '@wordpress/i18n';
import { plus } from '@wordpress/icons';
/**
 * Internal dependencies
 */

import Button from '../button';
import ColorPicker from '../color-picker';
import Dropdown from '../dropdown';
import KeyboardShortcuts from '../keyboard-shortcuts';
import VisuallyHidden from '../visually-hidden';
import { addControlPoint, clampPercent, removeControlPoint, updateControlPointColor, updateControlPointColorByPosition, updateControlPointPosition, getHorizontalRelativeGradientPosition } from './utils';
import { COLOR_POPOVER_PROPS, GRADIENT_MARKERS_WIDTH, MINIMUM_SIGNIFICANT_MOVE, KEYBOARD_CONTROL_POINT_VARIATION } from './constants';

function ControlPointKeyboardMove(_ref) {
  var position = _ref.value,
      onChange = _ref.onChange,
      children = _ref.children;
  var shortcuts = {
    right: function right(event) {
      // Stop propagation of the key press event to avoid focus moving
      // to another editor area.
      event.stopPropagation();
      var newPosition = clampPercent(position + KEYBOARD_CONTROL_POINT_VARIATION);
      onChange(newPosition);
    },
    left: function left(event) {
      // Stop propagation of the key press event to avoid focus moving
      // to another editor area.
      event.stopPropagation();
      var newPosition = clampPercent(position - KEYBOARD_CONTROL_POINT_VARIATION);
      onChange(newPosition);
    }
  };
  return createElement(KeyboardShortcuts, {
    shortcuts: shortcuts
  }, children);
}

function ControlPointButton(_ref2) {
  var isOpen = _ref2.isOpen,
      position = _ref2.position,
      color = _ref2.color,
      onChange = _ref2.onChange,
      additionalProps = _objectWithoutProperties(_ref2, ["isOpen", "position", "color", "onChange"]);

  var instanceId = useInstanceId(ControlPointButton);
  var descriptionId = "components-custom-gradient-picker__control-point-button-description-".concat(instanceId);
  return createElement(ControlPointKeyboardMove, {
    value: position,
    onChange: onChange
  }, createElement(Button, _extends({
    "aria-label": sprintf( // translators: %1$s: gradient position e.g: 70, %2$s: gradient color code e.g: rgb(52,121,151).
    __('Gradient control point at position %1$s%% with color code %2$s.'), position, color),
    "aria-describedby": descriptionId,
    "aria-haspopup": "true",
    "aria-expanded": isOpen,
    className: classnames('components-custom-gradient-picker__control-point-button', {
      'is-active': isOpen
    }),
    style: {
      left: "".concat(position, "%")
    }
  }, additionalProps)), createElement(VisuallyHidden, {
    id: descriptionId
  }, __('Use your left or right arrow keys or drag and drop with the mouse to change the gradient position. Press the button to change the color or remove the control point.')));
}

function ControlPoints(_ref3) {
  var gradientPickerDomRef = _ref3.gradientPickerDomRef,
      ignoreMarkerPosition = _ref3.ignoreMarkerPosition,
      controlPoints = _ref3.value,
      _onChange = _ref3.onChange,
      onStartControlPointChange = _ref3.onStartControlPointChange,
      onStopControlPointChange = _ref3.onStopControlPointChange;
  var controlPointMoveState = useRef();

  var onMouseMove = function onMouseMove(event) {
    var relativePosition = getHorizontalRelativeGradientPosition(event.clientX, gradientPickerDomRef.current, GRADIENT_MARKERS_WIDTH);
    var _controlPointMoveStat = controlPointMoveState.current,
        initialPosition = _controlPointMoveStat.initialPosition,
        index = _controlPointMoveStat.index,
        significantMoveHappened = _controlPointMoveStat.significantMoveHappened;

    if (!significantMoveHappened && Math.abs(initialPosition - relativePosition) >= MINIMUM_SIGNIFICANT_MOVE) {
      controlPointMoveState.current.significantMoveHappened = true;
    }

    _onChange(updateControlPointPosition(controlPoints, index, relativePosition));
  };

  var cleanEventListeners = function cleanEventListeners() {
    if (window && window.removeEventListener && controlPointMoveState.current && controlPointMoveState.current.listenersActivated) {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', cleanEventListeners);
      onStopControlPointChange();
      controlPointMoveState.current.listenersActivated = false;
    }
  };

  useEffect(function () {
    return function () {
      cleanEventListeners();
    };
  }, []);
  return controlPoints.map(function (point, index) {
    var initialPosition = point === null || point === void 0 ? void 0 : point.position;
    return ignoreMarkerPosition !== initialPosition && createElement(Dropdown, {
      key: index,
      onClose: onStopControlPointChange,
      renderToggle: function renderToggle(_ref4) {
        var isOpen = _ref4.isOpen,
            onToggle = _ref4.onToggle;
        return createElement(ControlPointButton, {
          key: index,
          onClick: function onClick() {
            if (controlPointMoveState.current && controlPointMoveState.current.significantMoveHappened) {
              return;
            }

            if (isOpen) {
              onStopControlPointChange();
            } else {
              onStartControlPointChange();
            }

            onToggle();
          },
          onMouseDown: function onMouseDown() {
            if (window && window.addEventListener) {
              controlPointMoveState.current = {
                initialPosition: initialPosition,
                index: index,
                significantMoveHappened: false,
                listenersActivated: true
              };
              onStartControlPointChange();
              window.addEventListener('mousemove', onMouseMove);
              window.addEventListener('mouseup', cleanEventListeners);
            }
          },
          isOpen: isOpen,
          position: point.position,
          color: point.color,
          onChange: function onChange(newPosition) {
            _onChange(updateControlPointPosition(controlPoints, index, newPosition));
          }
        });
      },
      renderContent: function renderContent(_ref5) {
        var onClose = _ref5.onClose;
        return createElement(Fragment, null, createElement(ColorPicker, {
          color: point.color,
          onChangeComplete: function onChangeComplete(_ref6) {
            var color = _ref6.color;

            _onChange(updateControlPointColor(controlPoints, index, color.toRgbString()));
          }
        }), createElement(Button, {
          className: "components-custom-gradient-picker__remove-control-point",
          onClick: function onClick() {
            _onChange(removeControlPoint(controlPoints, index));

            onClose();
          },
          isLink: true
        }, __('Remove Control Point')));
      },
      popoverProps: COLOR_POPOVER_PROPS
    });
  });
}

function InsertPoint(_ref7) {
  var controlPoints = _ref7.value,
      onChange = _ref7.onChange,
      onOpenInserter = _ref7.onOpenInserter,
      onCloseInserter = _ref7.onCloseInserter,
      insertPosition = _ref7.insertPosition;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      alreadyInsertedPoint = _useState2[0],
      setAlreadyInsertedPoint = _useState2[1];

  return createElement(Dropdown, {
    className: "components-custom-gradient-picker__inserter",
    onClose: function onClose() {
      onCloseInserter();
    },
    renderToggle: function renderToggle(_ref8) {
      var isOpen = _ref8.isOpen,
          onToggle = _ref8.onToggle;
      return createElement(Button, {
        "aria-expanded": isOpen,
        "aria-haspopup": "true",
        onClick: function onClick() {
          if (isOpen) {
            onCloseInserter();
          } else {
            setAlreadyInsertedPoint(false);
            onOpenInserter();
          }

          onToggle();
        },
        className: "components-custom-gradient-picker__insert-point",
        icon: plus,
        style: {
          left: insertPosition !== null ? "".concat(insertPosition, "%") : undefined
        }
      });
    },
    renderContent: function renderContent() {
      return createElement(ColorPicker, {
        onChangeComplete: function onChangeComplete(_ref9) {
          var color = _ref9.color;

          if (!alreadyInsertedPoint) {
            onChange(addControlPoint(controlPoints, insertPosition, color.toRgbString()));
            setAlreadyInsertedPoint(true);
          } else {
            onChange(updateControlPointColorByPosition(controlPoints, insertPosition, color.toRgbString()));
          }
        }
      });
    },
    popoverProps: COLOR_POPOVER_PROPS
  });
}

ControlPoints.InsertPoint = InsertPoint;
export default ControlPoints;
//# sourceMappingURL=control-points.js.map