import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { createElement } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { includes } from 'lodash';
/**
 * WordPress dependencies
 */

import { Children, cloneElement, concatChildren, useEffect, useState } from '@wordpress/element';
import { useDebounce } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import Popover from '../popover';
import Shortcut from '../shortcut';
import { withNextComponent } from './next';
/**
 * Time over children to wait before showing tooltip
 *
 * @type {number}
 */

export var TOOLTIP_DELAY = 700;
var eventCatcher = createElement("div", {
  className: "event-catcher"
});

var getDisabledElement = function getDisabledElement(_ref) {
  var eventHandlers = _ref.eventHandlers,
      child = _ref.child,
      childrenWithPopover = _ref.childrenWithPopover;
  return cloneElement(createElement("span", {
    className: "disabled-element-wrapper"
  }, cloneElement(eventCatcher, eventHandlers), cloneElement(child, {
    children: childrenWithPopover
  }), ","), eventHandlers);
};

var getRegularElement = function getRegularElement(_ref2) {
  var child = _ref2.child,
      eventHandlers = _ref2.eventHandlers,
      childrenWithPopover = _ref2.childrenWithPopover;
  return cloneElement(child, _objectSpread(_objectSpread({}, eventHandlers), {}, {
    children: childrenWithPopover
  }));
};

var addPopoverToGrandchildren = function addPopoverToGrandchildren(_ref3) {
  var grandchildren = _ref3.grandchildren,
      isOver = _ref3.isOver,
      position = _ref3.position,
      text = _ref3.text,
      shortcut = _ref3.shortcut;
  return concatChildren(grandchildren, isOver && createElement(Popover, {
    focusOnMount: false,
    position: position,
    className: "components-tooltip",
    "aria-hidden": "true",
    animate: false,
    noArrow: true
  }, text, createElement(Shortcut, {
    className: "components-tooltip__shortcut",
    shortcut: shortcut
  })));
};

var emitToChild = function emitToChild(children, eventName, event) {
  if (Children.count(children) !== 1) {
    return;
  }

  var child = Children.only(children);

  if (typeof child.props[eventName] === 'function') {
    child.props[eventName](event);
  }
};

function Tooltip(_ref4) {
  var children = _ref4.children,
      position = _ref4.position,
      text = _ref4.text,
      shortcut = _ref4.shortcut;

  /**
   * Whether a mouse is currently pressed, used in determining whether
   * to handle a focus event as displaying the tooltip immediately.
   *
   * @type {boolean}
   */
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isMouseDown = _useState2[0],
      setIsMouseDown = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isOver = _useState4[0],
      setIsOver = _useState4[1];

  var delayedSetIsOver = useDebounce(setIsOver, TOOLTIP_DELAY);

  var createMouseDown = function createMouseDown(event) {
    // Preserve original child callback behavior
    emitToChild(children, 'onMouseDown', event); // On mouse down, the next `mouseup` should revert the value of the
    // instance property and remove its own event handler. The bind is
    // made on the document since the `mouseup` might not occur within
    // the bounds of the element.

    document.addEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(true);
  };

  var createMouseUp = function createMouseUp(event) {
    emitToChild(children, 'onMouseUp', event);
    document.removeEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(false);
  };

  var createMouseEvent = function createMouseEvent(type) {
    if (type === 'mouseUp') return createMouseUp;
    if (type === 'mouseDown') return createMouseDown;
  };
  /**
   * Prebound `isInMouseDown` handler, created as a constant reference to
   * assure ability to remove in component unmount.
   *
   * @type {Function}
   */


  var cancelIsMouseDown = createMouseEvent('mouseUp');

  var createToggleIsOver = function createToggleIsOver(eventName, isDelayed) {
    return function (event) {
      // Preserve original child callback behavior
      emitToChild(children, eventName, event); // Mouse events behave unreliably in React for disabled elements,
      // firing on mouseenter but not mouseleave.  Further, the default
      // behavior for disabled elements in some browsers is to ignore
      // mouse events. Don't bother trying to to handle them.
      //
      // See: https://github.com/facebook/react/issues/4251

      if (event.currentTarget.disabled) {
        return;
      } // A focus event will occur as a result of a mouse click, but it
      // should be disambiguated between interacting with the button and
      // using an explicit focus shift as a cue to display the tooltip.


      if ('focus' === event.type && isMouseDown) {
        return;
      } // Needed in case unsetting is over while delayed set pending, i.e.
      // quickly blur/mouseleave before delayedSetIsOver is called


      delayedSetIsOver.cancel();

      var _isOver = includes(['focus', 'mouseenter'], event.type);

      if (_isOver === isOver) {
        return;
      }

      if (isDelayed) {
        delayedSetIsOver(_isOver);
      } else {
        setIsOver(_isOver);
      }
    };
  };

  var clearOnUnmount = function clearOnUnmount() {
    delayedSetIsOver.cancel();
  };

  useEffect(function () {
    return clearOnUnmount;
  }, []);

  if (Children.count(children) !== 1) {
    if ('development' === process.env.NODE_ENV) {
      // eslint-disable-next-line no-console
      console.error('Tooltip should be called with only a single child element.');
    }

    return children;
  }

  var eventHandlers = {
    onMouseEnter: createToggleIsOver('onMouseEnter', true),
    onMouseLeave: createToggleIsOver('onMouseLeave'),
    onClick: createToggleIsOver('onClick'),
    onFocus: createToggleIsOver('onFocus'),
    onBlur: createToggleIsOver('onBlur'),
    onMouseDown: createMouseEvent('mouseDown')
  };
  var child = Children.only(children);
  var _child$props = child.props,
      grandchildren = _child$props.children,
      disabled = _child$props.disabled;
  var getElementWithPopover = disabled ? getDisabledElement : getRegularElement;
  var popoverData = {
    isOver: isOver,
    position: position,
    text: text,
    shortcut: shortcut
  };
  var childrenWithPopover = addPopoverToGrandchildren(_objectSpread({
    grandchildren: grandchildren
  }, popoverData));
  return getElementWithPopover({
    child: child,
    eventHandlers: eventHandlers,
    childrenWithPopover: childrenWithPopover
  });
}

export default withNextComponent(Tooltip);
//# sourceMappingURL=index.js.map