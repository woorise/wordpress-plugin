import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { renderToString, useRef, useState, useEffect } from '@wordpress/element';
/**
 * Internal dependencies
 */

import FocusableIframe from '../focusable-iframe';
var observeAndResizeJS = "\n\t( function() {\n\t\tvar observer;\n\n\t\tif ( ! window.MutationObserver || ! document.body || ! window.parent ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction sendResize() {\n\t\t\tvar clientBoundingRect = document.body.getBoundingClientRect();\n\n\t\t\twindow.parent.postMessage( {\n\t\t\t\taction: 'resize',\n\t\t\t\twidth: clientBoundingRect.width,\n\t\t\t\theight: clientBoundingRect.height,\n\t\t\t}, '*' );\n\t\t}\n\n\t\tobserver = new MutationObserver( sendResize );\n\t\tobserver.observe( document.body, {\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: false,\n\t\t\tcharacterData: true,\n\t\t\tcharacterDataOldValue: false,\n\t\t\tchildList: true,\n\t\t\tsubtree: true\n\t\t} );\n\n\t\twindow.addEventListener( 'load', sendResize, true );\n\n\t\t// Hack: Remove viewport unit styles, as these are relative\n\t\t// the iframe root and interfere with our mechanism for\n\t\t// determining the unconstrained page bounds.\n\t\tfunction removeViewportStyles( ruleOrNode ) {\n\t\t\tif( ruleOrNode.style ) {\n\t\t\t\t[ 'width', 'height', 'minHeight', 'maxHeight' ].forEach( function( style ) {\n\t\t\t\t\tif ( /^\\d+(vmin|vmax|vh|vw)$/.test( ruleOrNode.style[ style ] ) ) {\n\t\t\t\t\t\truleOrNode.style[ style ] = '';\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tArray.prototype.forEach.call( document.querySelectorAll( '[style]' ), removeViewportStyles );\n\t\tArray.prototype.forEach.call( document.styleSheets, function( stylesheet ) {\n\t\t\tArray.prototype.forEach.call( stylesheet.cssRules || stylesheet.rules, removeViewportStyles );\n\t\t} );\n\n\t\tdocument.body.style.position = 'absolute';\n\t\tdocument.body.style.width = '100%';\n\t\tdocument.body.setAttribute( 'data-resizable-iframe-connected', '' );\n\n\t\tsendResize();\n\n\t\t// Resize events can change the width of elements with 100% width, but we don't\n\t\t// get an DOM mutations for that, so do the resize when the window is resized, too.\n\t\twindow.addEventListener( 'resize', sendResize, true );\n} )();";
var style = "\n\tbody {\n\t\tmargin: 0;\n\t}\n\thtml,\n\tbody,\n\tbody > div,\n\tbody > div iframe {\n\t\twidth: 100%;\n\t}\n\thtml.wp-has-aspect-ratio,\n\tbody.wp-has-aspect-ratio,\n\tbody.wp-has-aspect-ratio > div,\n\tbody.wp-has-aspect-ratio > div iframe {\n\t\theight: 100%;\n\t\toverflow: hidden; /* If it has an aspect ratio, it shouldn't scroll. */\n\t}\n\tbody > div > * {\n\t\tmargin-top: 0 !important; /* Has to have !important to override inline styles. */\n\t\tmargin-bottom: 0 !important;\n\t}\n";
export default function Sandbox(_ref) {
  var _ref$html = _ref.html,
      html = _ref$html === void 0 ? '' : _ref$html,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? '' : _ref$title,
      type = _ref.type,
      _ref$styles = _ref.styles,
      styles = _ref$styles === void 0 ? [] : _ref$styles,
      _ref$scripts = _ref.scripts,
      scripts = _ref$scripts === void 0 ? [] : _ref$scripts,
      onFocus = _ref.onFocus;
  var ref = useRef();

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      width = _useState2[0],
      setWidth = _useState2[1];

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      height = _useState4[0],
      setHeight = _useState4[1];

  function isFrameAccessible() {
    try {
      return !!ref.current.contentDocument.body;
    } catch (e) {
      return false;
    }
  }

  function trySandbox() {
    var forceRerender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!isFrameAccessible()) {
      return;
    }

    var _ref$current = ref.current,
        contentDocument = _ref$current.contentDocument,
        ownerDocument = _ref$current.ownerDocument;
    var body = contentDocument.body;

    if (!forceRerender && null !== body.getAttribute('data-resizable-iframe-connected')) {
      return;
    } // put the html snippet into a html document, and then write it to the iframe's document
    // we can use this in the future to inject custom styles or scripts.
    // Scripts go into the body rather than the head, to support embedded content such as Instagram
    // that expect the scripts to be part of the body.


    var htmlDoc = createElement("html", {
      lang: ownerDocument.documentElement.lang,
      className: type
    }, createElement("head", null, createElement("title", null, title), createElement("style", {
      dangerouslySetInnerHTML: {
        __html: style
      }
    }), styles.map(function (rules, i) {
      return createElement("style", {
        key: i,
        dangerouslySetInnerHTML: {
          __html: rules
        }
      });
    })), createElement("body", {
      "data-resizable-iframe-connected": "data-resizable-iframe-connected",
      className: type
    }, createElement("div", {
      dangerouslySetInnerHTML: {
        __html: html
      }
    }), createElement("script", {
      type: "text/javascript",
      dangerouslySetInnerHTML: {
        __html: observeAndResizeJS
      }
    }), scripts.map(function (src) {
      return createElement("script", {
        key: src,
        src: src
      });
    }))); // writing the document like this makes it act in the same way as if it was
    // loaded over the network, so DOM creation and mutation, script execution, etc.
    // all work as expected

    contentDocument.open();
    contentDocument.write('<!DOCTYPE html>' + renderToString(htmlDoc));
    contentDocument.close();
  }

  useEffect(function () {
    trySandbox();

    function tryNoForceSandbox() {
      trySandbox(false);
    }

    function checkMessageForResize(event) {
      var iframe = ref.current; // Verify that the mounted element is the source of the message

      if (!iframe || iframe.contentWindow !== event.source) {
        return;
      } // Attempt to parse the message data as JSON if passed as string


      var data = event.data || {};

      if ('string' === typeof data) {
        try {
          data = JSON.parse(data);
        } catch (e) {}
      } // Update the state only if the message is formatted as we expect,
      // i.e. as an object with a 'resize' action.


      if ('resize' !== data.action) {
        return;
      }

      setWidth(data.width);
      setHeight(data.height);
    }

    var ownerDocument = ref.current.ownerDocument;
    var defaultView = ownerDocument.defaultView; // This used to be registered using <iframe onLoad={} />, but it made the iframe blank
    // after reordering the containing block. See these two issues for more details:
    // https://github.com/WordPress/gutenberg/issues/6146
    // https://github.com/facebook/react/issues/18752

    ref.current.addEventListener('load', tryNoForceSandbox, false);
    defaultView.addEventListener('message', checkMessageForResize);
    return function () {
      ref.current.removeEventListener('load', tryNoForceSandbox, false);
      defaultView.addEventListener('message', checkMessageForResize);
    };
  }, []);
  useEffect(function () {
    trySandbox();
  }, [title, type, styles, scripts]);
  useEffect(function () {
    trySandbox(true);
  }, [html]);
  return createElement(FocusableIframe, {
    iframeRef: ref,
    title: title,
    className: "components-sandbox",
    sandbox: "allow-scripts allow-same-origin allow-presentation",
    onFocus: onFocus,
    width: Math.ceil(width),
    height: Math.ceil(height)
  });
}
//# sourceMappingURL=index.js.map