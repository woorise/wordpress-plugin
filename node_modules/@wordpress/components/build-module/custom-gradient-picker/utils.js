import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import gradientParser from 'gradient-parser';
import tinycolor from 'tinycolor2';
/**
 * Internal dependencies
 */

import { DEFAULT_GRADIENT, HORIZONTAL_GRADIENT_ORIENTATION, DIRECTIONAL_ORIENTATION_ANGLE_MAP } from './constants';
import { serializeGradient } from './serializer';
export function getLinearGradientRepresentationOfARadial(gradientAST) {
  return serializeGradient({
    type: 'linear-gradient',
    orientation: HORIZONTAL_GRADIENT_ORIENTATION,
    colorStops: gradientAST.colorStops
  });
}

function hasUnsupportedLength(item) {
  return item.length === undefined || item.length.type !== '%';
}

export function getGradientAstWithDefault(value) {
  var _gradientAST$orientat;

  // gradientAST will contain the gradient AST as parsed by gradient-parser npm module.
  // More information of its structure available at https://www.npmjs.com/package/gradient-parser#ast.
  var gradientAST;

  try {
    gradientAST = gradientParser.parse(value)[0];
    gradientAST.value = value;
  } catch (error) {
    gradientAST = gradientParser.parse(DEFAULT_GRADIENT)[0];
    gradientAST.value = DEFAULT_GRADIENT;
  }

  if (((_gradientAST$orientat = gradientAST.orientation) === null || _gradientAST$orientat === void 0 ? void 0 : _gradientAST$orientat.type) === 'directional') {
    gradientAST.orientation.type = 'angular';
    gradientAST.orientation.value = DIRECTIONAL_ORIENTATION_ANGLE_MAP[gradientAST.orientation.value].toString();
  }

  if (gradientAST.colorStops.some(hasUnsupportedLength)) {
    var _gradientAST = gradientAST,
        colorStops = _gradientAST.colorStops;
    var step = 100 / (colorStops.length - 1);
    colorStops.forEach(function (stop, index) {
      stop.length = {
        value: step * index,
        type: '%'
      };
    });
    gradientAST.value = serializeGradient(gradientAST);
  }

  return gradientAST;
}
export function getGradientAstWithControlPoints(gradientAST, newControlPoints) {
  return _objectSpread(_objectSpread({}, gradientAST), {}, {
    colorStops: newControlPoints.map(function (_ref) {
      var position = _ref.position,
          color = _ref.color;

      var _tinycolor$toRgb = tinycolor(color).toRgb(),
          r = _tinycolor$toRgb.r,
          g = _tinycolor$toRgb.g,
          b = _tinycolor$toRgb.b,
          a = _tinycolor$toRgb.a;

      return {
        length: {
          type: '%',
          value: position.toString()
        },
        type: a < 1 ? 'rgba' : 'rgb',
        value: a < 1 ? [r, g, b, a] : [r, g, b]
      };
    })
  });
}
export function getStopCssColor(colorStop) {
  switch (colorStop.type) {
    case 'hex':
      return "#".concat(colorStop.value);

    case 'literal':
      return colorStop.value;

    case 'rgb':
    case 'rgba':
      return "".concat(colorStop.type, "(").concat(colorStop.value.join(','), ")");

    default:
      // Should be unreachable if passing an AST from gradient-parser.
      // See https://github.com/rafaelcaricio/gradient-parser#ast.
      return 'transparent';
  }
}
//# sourceMappingURL=utils.js.map