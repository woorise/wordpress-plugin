import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { noop } from 'lodash';
import { useDrag } from 'react-use-gesture';
/**
 * WordPress dependencies
 */

import { forwardRef, useRef } from '@wordpress/element';
import { UP, DOWN, ENTER } from '@wordpress/keycodes';
/**
 * Internal dependencies
 */

import { useDragCursor } from './utils';
import { Input } from './styles/input-control-styles';
import { useInputControlStateReducer } from './state';
import { isValueEmpty } from '../utils/values';
import { useUpdateEffect } from '../utils';

function InputField(_ref, ref) {
  var _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$dragDirection = _ref.dragDirection,
      dragDirection = _ref$dragDirection === void 0 ? 'n' : _ref$dragDirection,
      _ref$dragThreshold = _ref.dragThreshold,
      dragThreshold = _ref$dragThreshold === void 0 ? 10 : _ref$dragThreshold,
      id = _ref.id,
      _ref$isDragEnabled = _ref.isDragEnabled,
      isDragEnabled = _ref$isDragEnabled === void 0 ? false : _ref$isDragEnabled,
      isFocused = _ref.isFocused,
      _ref$isPressEnterToCh = _ref.isPressEnterToChange,
      isPressEnterToChange = _ref$isPressEnterToCh === void 0 ? false : _ref$isPressEnterToCh,
      _ref$onBlur = _ref.onBlur,
      onBlur = _ref$onBlur === void 0 ? noop : _ref$onBlur,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
      _ref$onDrag = _ref.onDrag,
      onDrag = _ref$onDrag === void 0 ? noop : _ref$onDrag,
      _ref$onDragEnd = _ref.onDragEnd,
      onDragEnd = _ref$onDragEnd === void 0 ? noop : _ref$onDragEnd,
      _ref$onDragStart = _ref.onDragStart,
      onDragStart = _ref$onDragStart === void 0 ? noop : _ref$onDragStart,
      _ref$onFocus = _ref.onFocus,
      onFocus = _ref$onFocus === void 0 ? noop : _ref$onFocus,
      _ref$onKeyDown = _ref.onKeyDown,
      onKeyDown = _ref$onKeyDown === void 0 ? noop : _ref$onKeyDown,
      _ref$onValidate = _ref.onValidate,
      onValidate = _ref$onValidate === void 0 ? noop : _ref$onValidate,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'default' : _ref$size,
      setIsFocused = _ref.setIsFocused,
      _ref$stateReducer = _ref.stateReducer,
      stateReducer = _ref$stateReducer === void 0 ? function (state) {
    return state;
  } : _ref$stateReducer,
      valueProp = _ref.value,
      type = _ref.type,
      props = _objectWithoutProperties(_ref, ["disabled", "dragDirection", "dragThreshold", "id", "isDragEnabled", "isFocused", "isPressEnterToChange", "onBlur", "onChange", "onDrag", "onDragEnd", "onDragStart", "onFocus", "onKeyDown", "onValidate", "size", "setIsFocused", "stateReducer", "value", "type"]);

  var _useInputControlState = useInputControlStateReducer(stateReducer, {
    isDragEnabled: isDragEnabled,
    value: valueProp,
    isPressEnterToChange: isPressEnterToChange
  }),
      state = _useInputControlState.state,
      change = _useInputControlState.change,
      commit = _useInputControlState.commit,
      drag = _useInputControlState.drag,
      dragEnd = _useInputControlState.dragEnd,
      dragStart = _useInputControlState.dragStart,
      invalidate = _useInputControlState.invalidate,
      pressDown = _useInputControlState.pressDown,
      pressEnter = _useInputControlState.pressEnter,
      pressUp = _useInputControlState.pressUp,
      reset = _useInputControlState.reset,
      update = _useInputControlState.update;

  var _event = state._event,
      value = state.value,
      isDragging = state.isDragging,
      isDirty = state.isDirty;
  var wasDirtyOnBlur = useRef(false);
  var dragCursor = useDragCursor(isDragging, dragDirection);
  /*
   * Handles syncronization of external and internal value state.
   * If not focused and did not hold a dirty value[1] on blur
   * updates the value from the props. Otherwise if not holding
   * a dirty value[1] propagates the value and event through onChange.
   * [1] value is only made dirty if isPressEnterToChange is true
   */

  useUpdateEffect(function () {
    if (valueProp === value) {
      return;
    }

    if (!isFocused && !wasDirtyOnBlur.current) {
      update(valueProp);
    } else if (!isDirty) {
      onChange(value, {
        event: _event
      });
      wasDirtyOnBlur.current = false;
    }
  }, [value, isDirty, isFocused, valueProp]);

  var handleOnBlur = function handleOnBlur(event) {
    onBlur(event);
    setIsFocused(false);
    /**
     * If isPressEnterToChange is set, this commits the value to
     * the onChange callback.
     */

    if (isPressEnterToChange && isDirty) {
      wasDirtyOnBlur.current = true;

      if (!isValueEmpty(value)) {
        handleOnCommit(event);
      } else {
        reset(valueProp);
      }
    }
  };

  var handleOnFocus = function handleOnFocus(event) {
    onFocus(event);
    setIsFocused(true);
  };

  var handleOnChange = function handleOnChange(event) {
    var nextValue = event.target.value;
    change(nextValue, event);
  };

  var handleOnCommit = function handleOnCommit(event) {
    var nextValue = event.target.value;

    try {
      onValidate(nextValue, event);
      commit(nextValue, event);
    } catch (err) {
      invalidate(err, event);
    }
  };

  var handleOnKeyDown = function handleOnKeyDown(event) {
    var keyCode = event.keyCode;
    onKeyDown(event);

    switch (keyCode) {
      case UP:
        pressUp(event);
        break;

      case DOWN:
        pressDown(event);
        break;

      case ENTER:
        pressEnter(event);

        if (isPressEnterToChange) {
          event.preventDefault();
          handleOnCommit(event);
        }

        break;
    }
  };

  var dragGestureProps = useDrag(function (dragProps) {
    var distance = dragProps.distance,
        dragging = dragProps.dragging,
        event = dragProps.event;
    if (!distance) return;
    event.stopPropagation();
    /**
     * Quick return if no longer dragging.
     * This prevents unnecessary value calculations.
     */

    if (!dragging) {
      onDragEnd(dragProps);
      dragEnd(dragProps);
      return;
    }

    onDrag(dragProps);
    drag(dragProps);

    if (!isDragging) {
      onDragStart(dragProps);
      dragStart(dragProps);
    }
  }, {
    threshold: dragThreshold,
    enabled: isDragEnabled
  });
  var dragProps = isDragEnabled ? dragGestureProps() : {};
  /*
   * Works around the odd UA (e.g. Firefox) that does not focus inputs of
   * type=number when their spinner arrows are pressed.
   */

  var handleOnMouseDown;

  if (type === 'number') {
    handleOnMouseDown = function handleOnMouseDown(event) {
      var _props$onMouseDown;

      (_props$onMouseDown = props.onMouseDown) === null || _props$onMouseDown === void 0 ? void 0 : _props$onMouseDown.call(props, event);

      if (event.target !== event.target.ownerDocument.activeElement) {
        event.target.focus();
      }
    };
  }

  return createElement(Input, _extends({}, props, dragProps, {
    className: "components-input-control__input",
    disabled: disabled,
    dragCursor: dragCursor,
    isDragging: isDragging,
    id: id,
    onBlur: handleOnBlur,
    onChange: handleOnChange,
    onFocus: handleOnFocus,
    onKeyDown: handleOnKeyDown,
    onMouseDown: handleOnMouseDown,
    ref: ref,
    size: size,
    value: value,
    type: type
  }));
}

var ForwardedComponent = forwardRef(InputField);
export default ForwardedComponent;
//# sourceMappingURL=input-field.js.map