import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { escapeRegExp, find, map, debounce, deburr } from 'lodash';
/**
 * WordPress dependencies
 */

import { renderToString, useEffect, useLayoutEffect, useState } from '@wordpress/element';
import { ENTER, ESCAPE, UP, DOWN, LEFT, RIGHT } from '@wordpress/keycodes';
import { __, _n, sprintf } from '@wordpress/i18n';
import { useInstanceId } from '@wordpress/compose';
import { create, slice, insert, isCollapsed, getTextContent, useAnchorRef } from '@wordpress/rich-text';
/**
 * Internal dependencies
 */

import Button from '../button';
import Popover from '../popover';
import withSpokenMessages from '../higher-order/with-spoken-messages';
/**
 * A raw completer option.
 *
 * @typedef {*} CompleterOption
 */

/**
 * @callback FnGetOptions
 *
 * @return {(CompleterOption[]|Promise.<CompleterOption[]>)} The completer options or a promise for them.
 */

/**
 * @callback FnGetOptionKeywords
 * @param {CompleterOption} option a completer option.
 *
 * @return {string[]} list of key words to search.
 */

/**
 * @callback FnIsOptionDisabled
 * @param {CompleterOption} option a completer option.
 *
 * @return {string[]} whether or not the given option is disabled.
 */

/**
 * @callback FnGetOptionLabel
 * @param {CompleterOption} option a completer option.
 *
 * @return {(string|Array.<(string|WPElement)>)} list of react components to render.
 */

/**
 * @callback FnAllowContext
 * @param {string} before the string before the auto complete trigger and query.
 * @param {string} after  the string after the autocomplete trigger and query.
 *
 * @return {boolean} true if the completer can handle.
 */

/**
 * @typedef {Object} OptionCompletion
 * @property {'insert-at-caret'|'replace'} action the intended placement of the completion.
 * @property {OptionCompletionValue} value the completion value.
 */

/**
 * A completion value.
 *
 * @typedef {(string|WPElement|Object)} OptionCompletionValue
 */

/**
 * @callback FnGetOptionCompletion
 * @param {CompleterOption} value the value of the completer option.
 * @param {string} query the text value of the autocomplete query.
 *
 * @return {(OptionCompletion|OptionCompletionValue)} the completion for the given option. If an
 * 													   OptionCompletionValue is returned, the
 * 													   completion action defaults to `insert-at-caret`.
 */

/**
 * @typedef {Object} WPCompleter
 * @property {string} name a way to identify a completer, useful for selective overriding.
 * @property {?string} className A class to apply to the popup menu.
 * @property {string} triggerPrefix the prefix that will display the menu.
 * @property {(CompleterOption[]|FnGetOptions)} options the completer options or a function to get them.
 * @property {?FnGetOptionKeywords} getOptionKeywords get the keywords for a given option.
 * @property {?FnIsOptionDisabled} isOptionDisabled get whether or not the given option is disabled.
 * @property {FnGetOptionLabel} getOptionLabel get the label for a given option.
 * @property {?FnAllowContext} allowContext filter the context under which the autocomplete activates.
 * @property {FnGetOptionCompletion} getOptionCompletion get the completion associated with a given option.
 */

function filterOptions(search) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var maxResults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  var filtered = [];

  for (var i = 0; i < options.length; i++) {
    var option = options[i]; // Merge label into keywords

    var _option$keywords = option.keywords,
        keywords = _option$keywords === void 0 ? [] : _option$keywords;

    if ('string' === typeof option.label) {
      keywords = [].concat(_toConsumableArray(keywords), [option.label]);
    }

    var isMatch = keywords.some(function (keyword) {
      return search.test(deburr(keyword));
    });

    if (!isMatch) {
      continue;
    }

    filtered.push(option); // Abort early if max reached

    if (filtered.length === maxResults) {
      break;
    }
  }

  return filtered;
}

var getAutoCompleterUI = function getAutoCompleterUI(autocompleter) {
  var useItems = autocompleter.useItems ? autocompleter.useItems : function (filterValue) {
    var _useState = useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        items = _useState2[0],
        setItems = _useState2[1];
    /*
     * We support both synchronous and asynchronous retrieval of completer options
     * but internally treat all as async so we maintain a single, consistent code path.
     *
     * Because networks can be slow, and the internet is wonderfully unpredictable,
     * we don't want two promises updating the state at once. This ensures that only
     * the most recent promise will act on `optionsData`. This doesn't use the state
     * because `setState` is batched, and so there's no guarantee that setting
     * `activePromise` in the state would result in it actually being in `this.state`
     * before the promise resolves and we check to see if this is the active promise or not.
     */


    useLayoutEffect(function () {
      var options = autocompleter.options,
          isDebounced = autocompleter.isDebounced;
      var loadOptions = debounce(function () {
        var promise = Promise.resolve(typeof options === 'function' ? options(filterValue) : options).then(function (optionsData) {
          if (promise.canceled) {
            return;
          }

          var keyedOptions = optionsData.map(function (optionData, optionIndex) {
            return {
              key: "".concat(autocompleter.name, "-").concat(optionIndex),
              value: optionData,
              label: autocompleter.getOptionLabel(optionData),
              keywords: autocompleter.getOptionKeywords ? autocompleter.getOptionKeywords(optionData) : [],
              isDisabled: autocompleter.isOptionDisabled ? autocompleter.isOptionDisabled(optionData) : false
            };
          }); // create a regular expression to filter the options

          var search = new RegExp('(?:\\b|\\s|^)' + escapeRegExp(filterValue), 'i');
          setItems(filterOptions(search, keyedOptions));
        });
        return promise;
      }, isDebounced ? 250 : 0);
      var promise = loadOptions();
      return function () {
        loadOptions.cancel();

        if (promise) {
          promise.canceled = true;
        }
      };
    }, [filterValue]);
    return [items];
  };

  function AutocompleterUI(_ref) {
    var filterValue = _ref.filterValue,
        instanceId = _ref.instanceId,
        listBoxId = _ref.listBoxId,
        className = _ref.className,
        selectedIndex = _ref.selectedIndex,
        onChangeOptions = _ref.onChangeOptions,
        onSelect = _ref.onSelect,
        onReset = _ref.onReset,
        value = _ref.value,
        contentRef = _ref.contentRef;

    var _useItems = useItems(filterValue),
        _useItems2 = _slicedToArray(_useItems, 1),
        items = _useItems2[0];

    var anchorRef = useAnchorRef({
      ref: contentRef,
      value: value
    });
    useLayoutEffect(function () {
      onChangeOptions(items);
    }, [items]);

    if (!items.length > 0) {
      return null;
    }

    return createElement(Popover, {
      focusOnMount: false,
      onClose: onReset,
      position: "top right",
      className: "components-autocomplete__popover",
      anchorRef: anchorRef
    }, createElement("div", {
      id: listBoxId,
      role: "listbox",
      className: "components-autocomplete__results"
    }, map(items, function (option, index) {
      return createElement(Button, {
        key: option.key,
        id: "components-autocomplete-item-".concat(instanceId, "-").concat(option.key),
        role: "option",
        "aria-selected": index === selectedIndex,
        disabled: option.isDisabled,
        className: classnames('components-autocomplete__result', className, {
          'is-selected': index === selectedIndex
        }),
        onClick: function onClick() {
          return onSelect(option);
        }
      }, option.label);
    })));
  }

  return AutocompleterUI;
};

function Autocomplete(_ref2) {
  var children = _ref2.children,
      isSelected = _ref2.isSelected,
      record = _ref2.record,
      onChange = _ref2.onChange,
      onReplace = _ref2.onReplace,
      completers = _ref2.completers,
      debouncedSpeak = _ref2.debouncedSpeak,
      contentRef = _ref2.contentRef;
  var instanceId = useInstanceId(Autocomplete);

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      selectedIndex = _useState4[0],
      setSelectedIndex = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      filteredOptions = _useState6[0],
      setFilteredOptions = _useState6[1];

  var _useState7 = useState(''),
      _useState8 = _slicedToArray(_useState7, 2),
      filterValue = _useState8[0],
      setFilterValue = _useState8[1];

  var _useState9 = useState(null),
      _useState10 = _slicedToArray(_useState9, 2),
      autocompleter = _useState10[0],
      setAutocompleter = _useState10[1];

  var _useState11 = useState(null),
      _useState12 = _slicedToArray(_useState11, 2),
      AutocompleterUI = _useState12[0],
      setAutocompleterUI = _useState12[1];

  function insertCompletion(replacement) {
    var end = record.start;
    var start = end - autocompleter.triggerPrefix.length - filterValue.length;
    var toInsert = create({
      html: renderToString(replacement)
    });
    onChange(insert(record, toInsert, start, end));
  }

  function select(option) {
    var _ref3 = autocompleter || {},
        getOptionCompletion = _ref3.getOptionCompletion;

    if (option.isDisabled) {
      return;
    }

    if (getOptionCompletion) {
      var completion = getOptionCompletion(option.value, filterValue);

      var _ref4 = undefined === completion.action || undefined === completion.value ? {
        action: 'insert-at-caret',
        value: completion
      } : completion,
          action = _ref4.action,
          value = _ref4.value;

      if ('replace' === action) {
        onReplace([value]);
      } else if ('insert-at-caret' === action) {
        insertCompletion(value);
      }
    } // Reset autocomplete state after insertion rather than before
    // so insertion events don't cause the completion menu to redisplay.


    reset();
  }

  function reset() {
    setSelectedIndex(0);
    setFilteredOptions([]);
    setFilterValue('');
    setAutocompleter(null);
    setAutocompleterUI(null);
  }

  function announce(options) {
    if (!debouncedSpeak) {
      return;
    }

    if (!!options.length) {
      debouncedSpeak(sprintf(
      /* translators: %d: number of results. */
      _n('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', options.length), options.length), 'assertive');
    } else {
      debouncedSpeak(__('No results.'), 'assertive');
    }
  }
  /**
   * Load options for an autocompleter.
   *
   * @param {Array} options
   */


  function onChangeOptions(options) {
    setSelectedIndex(options.length === filteredOptions.length ? selectedIndex : 0);
    setFilteredOptions(options);
    announce(options);
  }

  function handleKeyDown(event) {
    if (!autocompleter) {
      return;
    }

    if (filteredOptions.length === 0) {
      return;
    }

    switch (event.keyCode) {
      case UP:
        setSelectedIndex((selectedIndex === 0 ? filteredOptions.length : selectedIndex) - 1);
        break;

      case DOWN:
        setSelectedIndex((selectedIndex + 1) % filteredOptions.length);
        break;

      case ESCAPE:
        setAutocompleter(null);
        setAutocompleterUI(null);
        break;

      case ENTER:
        select(filteredOptions[selectedIndex]);
        break;

      case LEFT:
      case RIGHT:
        reset();
        return;

      default:
        return;
    } // Any handled keycode should prevent original behavior. This relies on
    // the early return in the default case.


    event.preventDefault();
    event.stopPropagation();
  }

  var textContent;

  if (isCollapsed(record)) {
    textContent = getTextContent(slice(record, 0));
  }

  useEffect(function () {
    if (!textContent) {
      return;
    }

    var text = deburr(textContent);
    var textAfterSelection = getTextContent(slice(record, undefined, getTextContent(record).length));
    var completer = find(completers, function (_ref5) {
      var triggerPrefix = _ref5.triggerPrefix,
          allowContext = _ref5.allowContext;
      var index = text.lastIndexOf(triggerPrefix);

      if (index === -1) {
        return false;
      }

      if (allowContext && !allowContext(text.slice(0, index), textAfterSelection)) {
        return false;
      }

      var textWithoutTrigger = text.slice(index + triggerPrefix.length);

      if (/^\s/.test(textWithoutTrigger) || /\s\s+$/.test(textWithoutTrigger)) {
        return false;
      }

      return /[\u0000-\uFFFF]*$/.test(textWithoutTrigger);
    });

    if (!completer) {
      reset();
      return;
    }

    var safeTrigger = escapeRegExp(completer.triggerPrefix);
    var match = text.match(new RegExp("".concat(safeTrigger, "([\0-\uFFFF]*)$")));
    var query = match && match[1];
    setAutocompleter(completer);
    setAutocompleterUI(function () {
      return completer !== autocompleter ? getAutoCompleterUI(completer) : AutocompleterUI;
    });
    setFilterValue(query);
  }, [textContent]);

  var _ref6 = filteredOptions[selectedIndex] || {},
      _ref6$key = _ref6.key,
      selectedKey = _ref6$key === void 0 ? '' : _ref6$key;

  var _ref7 = autocompleter || {},
      className = _ref7.className;

  var isExpanded = !!autocompleter && filteredOptions.length > 0;
  var listBoxId = isExpanded ? "components-autocomplete-listbox-".concat(instanceId) : null;
  var activeId = isExpanded ? "components-autocomplete-item-".concat(instanceId, "-").concat(selectedKey) : null;
  return createElement(Fragment, null, children({
    isExpanded: isExpanded,
    listBoxId: listBoxId,
    activeId: activeId,
    onKeyDown: handleKeyDown
  }), isSelected && AutocompleterUI && createElement(AutocompleterUI, {
    className: className,
    filterValue: filterValue,
    instanceId: instanceId,
    listBoxId: listBoxId,
    selectedIndex: selectedIndex,
    onChangeOptions: onChangeOptions,
    onSelect: select,
    value: record,
    contentRef: contentRef
  }));
}

export default withSpokenMessages(Autocomplete);
//# sourceMappingURL=index.js.map