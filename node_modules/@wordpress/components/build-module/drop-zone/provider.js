import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { find, some, filter, includes, throttle } from 'lodash';
/**
 * WordPress dependencies
 */

import { createContext, useRef, useContext } from '@wordpress/element';
import { getFilesFromDataTransfer } from '@wordpress/dom';
import isShallowEqual from '@wordpress/is-shallow-equal';
import { useRefEffect } from '@wordpress/compose';
export var Context = createContext();
var Provider = Context.Provider;

function getDragEventType(_ref) {
  var dataTransfer = _ref.dataTransfer;

  if (dataTransfer) {
    // Use lodash `includes` here as in the Edge browser `types` is implemented
    // as a DomStringList, whereas in other browsers it's an array. `includes`
    // happily works with both types.
    if (includes(dataTransfer.types, 'Files') || getFilesFromDataTransfer(dataTransfer).length > 0) {
      return 'file';
    }

    if (includes(dataTransfer.types, 'text/html')) {
      return 'html';
    }
  }

  return 'default';
}

function isTypeSupportedByDropZone(type, dropZone) {
  return Boolean(type === 'file' && dropZone.onFilesDrop || type === 'html' && dropZone.onHTMLDrop || type === 'default' && dropZone.onDrop);
}

function isWithinElementBounds(element, x, y) {
  var rect = element.getBoundingClientRect(); /// make sure the rect is a valid rect

  if (rect.bottom === rect.top || rect.left === rect.right) {
    return false;
  }

  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function getPosition(event) {
  // In some contexts, it may be necessary to capture and redirect the
  // drag event (e.g. atop an `iframe`). To accommodate this, you can
  // create an instance of CustomEvent with the original event specified
  // as the `detail` property.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
  var detail = window.CustomEvent && event instanceof window.CustomEvent ? event.detail : event;
  return {
    x: detail.clientX,
    y: detail.clientY
  };
}

function getHoveredDropZone(dropZones, position, dragEventType) {
  var hoveredDropZones = filter(Array.from(dropZones), function (dropZone) {
    return isTypeSupportedByDropZone(dragEventType, dropZone) && isWithinElementBounds(dropZone.element.current, position.x, position.y);
  }); // Find the leaf dropzone not containing another dropzone

  return find(hoveredDropZones, function (zone) {
    var container = zone.isRelative ? zone.element.current.parentElement : zone.element.current;
    return !some(hoveredDropZones, function (subZone) {
      return subZone !== zone && container.contains(subZone.element.current);
    });
  });
}

export var INITIAL_DROP_ZONE_STATE = {
  isDraggingOverDocument: false,
  isDraggingOverElement: false,
  x: null,
  y: null,
  type: null
};
export function useDrop() {
  var dropZones = useContext(Context);
  return useRefEffect(function (node) {
    var ownerDocument = node.ownerDocument;
    var defaultView = ownerDocument.defaultView;
    var lastRelative;

    function updateDragZones(event) {
      if (lastRelative && lastRelative.contains(event.target)) {
        return;
      }

      var dragEventType = getDragEventType(event);
      var position = getPosition(event);
      var hoveredDropZone = getHoveredDropZone(dropZones, position, dragEventType);

      if (hoveredDropZone && hoveredDropZone.isRelative) {
        lastRelative = hoveredDropZone.element.current.offsetParent;
      } else {
        lastRelative = null;
      } // Notifying the dropzones


      dropZones.forEach(function (dropZone) {
        var isDraggingOverDropZone = dropZone === hoveredDropZone;
        var newState = {
          isDraggingOverDocument: isTypeSupportedByDropZone(dragEventType, dropZone),
          isDraggingOverElement: isDraggingOverDropZone,
          x: isDraggingOverDropZone && dropZone.withPosition ? position.x : null,
          y: isDraggingOverDropZone && dropZone.withPosition ? position.y : null,
          type: isDraggingOverDropZone ? dragEventType : null
        };
        dropZone.setState(function (state) {
          if (isShallowEqual(state, newState)) {
            return state;
          }

          return newState;
        });
      });
      event.preventDefault();
    }

    var throttledUpdateDragZones = throttle(updateDragZones, 200);

    function onDragOver(event) {
      throttledUpdateDragZones(event);
      event.preventDefault();
    }

    function resetDragState() {
      // Avoid throttled drag over handler calls
      throttledUpdateDragZones.cancel();
      dropZones.forEach(function (dropZone) {
        return dropZone.setState(INITIAL_DROP_ZONE_STATE);
      });
    }

    function onDrop(event) {
      // This seemingly useless line has been shown to resolve a Safari issue
      // where files dragged directly from the dock are not recognized
      event.dataTransfer && event.dataTransfer.files.length; // eslint-disable-line no-unused-expressions

      var dragEventType = getDragEventType(event);
      var position = getPosition(event);
      var hoveredDropZone = getHoveredDropZone(dropZones, position, dragEventType);
      resetDragState();

      if (hoveredDropZone) {
        switch (dragEventType) {
          case 'file':
            hoveredDropZone.onFilesDrop(getFilesFromDataTransfer(event.dataTransfer), position);
            break;

          case 'html':
            hoveredDropZone.onHTMLDrop(event.dataTransfer.getData('text/html'), position);
            break;

          case 'default':
            hoveredDropZone.onDrop(event, position);
        }
      }

      event.stopPropagation();
      event.preventDefault();
    }

    node.addEventListener('drop', onDrop);
    defaultView.addEventListener('dragover', onDragOver);
    defaultView.addEventListener('mouseup', resetDragState); // Note that `dragend` doesn't fire consistently for file and HTML drag
    // events where the drag origin is outside the browser window.
    // In Firefox it may also not fire if the originating node is removed.

    defaultView.addEventListener('dragend', resetDragState);
    return function () {
      node.removeEventListener('drop', onDrop);
      defaultView.removeEventListener('dragover', onDragOver);
      defaultView.removeEventListener('mouseup', resetDragState);
      defaultView.removeEventListener('dragend', resetDragState);
    };
  }, [dropZones]);
}
export function DropZoneContextProvider(props) {
  var ref = useRef(new Set([]));
  return createElement(Provider, _extends({}, props, {
    value: ref.current
  }));
}

function DropContainer(_ref2) {
  var children = _ref2.children;
  var ref = useDrop();
  return createElement("div", {
    ref: ref,
    className: "components-drop-zone__provider"
  }, children);
}

export default function DropZoneProvider(_ref3) {
  var children = _ref3.children;
  return createElement(DropZoneContextProvider, null, createElement(DropContainer, null, children));
}
//# sourceMappingURL=provider.js.map