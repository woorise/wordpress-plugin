import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { useContextSystem } from '@wp-g2/context';
import { css, cx } from '@wp-g2/styles';
/**
 * Internal dependencies
 */

import { useControlGroupContext } from '../control-group';
import { useFlex } from '../flex';
import * as styles from './styles';
/**
 * @type {('onMouseDown' | 'onClick')[]}
 */

var disabledEventsOnDisabledButton = ['onMouseDown', 'onClick'];
/**
 * @param {import('@wp-g2/create-styles').ViewOwnProps<import('./types').Props, 'button'>} props
 */

export function useBaseButton(props) {
  var _useContextSystem = useContextSystem(props, 'BaseButton'),
      children = _useContextSystem.children,
      className = _useContextSystem.className,
      cssProp = _useContextSystem.css,
      currentColor = _useContextSystem.currentColor,
      _useContextSystem$dis = _useContextSystem.disabled,
      disabled = _useContextSystem$dis === void 0 ? false : _useContextSystem$dis,
      _useContextSystem$ele = _useContextSystem.elevation,
      elevation = _useContextSystem$ele === void 0 ? 0 : _useContextSystem$ele,
      elevationActive = _useContextSystem.elevationActive,
      elevationFocus = _useContextSystem.elevationFocus,
      elevationHover = _useContextSystem.elevationHover,
      _useContextSystem$gap = _useContextSystem.gap,
      gap = _useContextSystem$gap === void 0 ? 2 : _useContextSystem$gap,
      _useContextSystem$has = _useContextSystem.hasCaret,
      hasCaret = _useContextSystem$has === void 0 ? false : _useContextSystem$has,
      href = _useContextSystem.href,
      icon = _useContextSystem.icon,
      _useContextSystem$ico = _useContextSystem.iconSize,
      iconSize = _useContextSystem$ico === void 0 ? 16 : _useContextSystem$ico,
      _useContextSystem$isB = _useContextSystem.isBlock,
      isBlock = _useContextSystem$isB === void 0 ? false : _useContextSystem$isB,
      _useContextSystem$isC = _useContextSystem.isControl,
      isControl = _useContextSystem$isC === void 0 ? false : _useContextSystem$isC,
      _useContextSystem$isD = _useContextSystem.isDestructive,
      isDestructive = _useContextSystem$isD === void 0 ? false : _useContextSystem$isD,
      _useContextSystem$isF = _useContextSystem.isFocusable,
      isFocusable = _useContextSystem$isF === void 0 ? true : _useContextSystem$isF,
      _useContextSystem$isL = _useContextSystem.isLoading,
      isLoading = _useContextSystem$isL === void 0 ? false : _useContextSystem$isL,
      _useContextSystem$isN = _useContextSystem.isNarrow,
      isNarrow = _useContextSystem$isN === void 0 ? false : _useContextSystem$isN,
      _useContextSystem$isR = _useContextSystem.isRounded,
      isRounded = _useContextSystem$isR === void 0 ? false : _useContextSystem$isR,
      _useContextSystem$isS = _useContextSystem.isSplit,
      isSplit = _useContextSystem$isS === void 0 ? false : _useContextSystem$isS,
      _useContextSystem$isS2 = _useContextSystem.isSubtle,
      isSubtle = _useContextSystem$isS2 === void 0 ? false : _useContextSystem$isS2,
      _useContextSystem$jus = _useContextSystem.justify,
      justify = _useContextSystem$jus === void 0 ? 'center' : _useContextSystem$jus,
      _useContextSystem$noW = _useContextSystem.noWrap,
      noWrap = _useContextSystem$noW === void 0 ? true : _useContextSystem$noW,
      pre = _useContextSystem.pre,
      _useContextSystem$siz = _useContextSystem.size,
      size = _useContextSystem$siz === void 0 ? 'medium' : _useContextSystem$siz,
      suffix = _useContextSystem.suffix,
      _useContextSystem$tex = _useContextSystem.textAlign,
      textAlign = _useContextSystem$tex === void 0 ? 'center' : _useContextSystem$tex,
      otherProps = _objectWithoutProperties(_useContextSystem, ["children", "className", "css", "currentColor", "disabled", "elevation", "elevationActive", "elevationFocus", "elevationHover", "gap", "hasCaret", "href", "icon", "iconSize", "isBlock", "isControl", "isDestructive", "isFocusable", "isLoading", "isNarrow", "isRounded", "isSplit", "isSubtle", "justify", "noWrap", "pre", "size", "suffix", "textAlign"]);

  var _useFlex = useFlex({
    gap: gap,
    justify: justify
  }),
      flexClassName = _useFlex.className,
      flexProps = _objectWithoutProperties(_useFlex, ["className"]);
  /** @type {import('react').ElementType} */


  var as = href ? 'a' : 'button';

  var _useControlGroupConte = useControlGroupContext(),
      controlGroupStyles = _useControlGroupConte.styles;

  var isIconOnly = !!icon && !children;
  var classes = cx(flexClassName, styles.Button, isBlock && styles.block, isDestructive && styles.destructive, styles[size], isIconOnly && styles.icon, isSubtle && styles.subtle, isControl && styles.control, isSubtle && isControl && styles.subtleControl, controlGroupStyles, isRounded && styles.rounded, isNarrow && styles.narrow, isSplit && styles.split, currentColor && styles.currentColor, css({
    textAlign: textAlign
  }), css(cssProp), className);
  var trulyDisabled = disabled && !isFocusable;

  var returnProps = _objectSpread(_objectSpread({}, flexProps), {}, {
    as: as,
    href: href,
    children: children,
    disabled: trulyDisabled,
    elevation: elevation,
    className: classes,
    elevationActive: elevationActive,
    elevationFocus: elevationFocus,
    elevationHover: elevationHover,
    hasCaret: hasCaret,
    icon: icon,
    isDestructive: isDestructive,
    pre: pre,
    suffix: suffix,
    iconSize: iconSize,
    isLoading: isLoading,
    noWrap: noWrap
  }, otherProps);

  if (disabled && isFocusable) {
    // In this case, the button will be disabled, but still focusable and
    // perceivable by screen reader users.
    returnProps['aria-disabled'] = true;

    var _iterator = _createForOfIteratorHelper(disabledEventsOnDisabledButton),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var disabledEvent = _step.value;

        returnProps[disabledEvent] = function (
        /** @type {import('react').MouseEvent<any>} */
        event) {
          event.stopPropagation();
          event.preventDefault();
        };
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return returnProps;
}
//# sourceMappingURL=hook.js.map