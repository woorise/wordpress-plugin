import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * WordPress dependencies
 */
import { useEffect, useState } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { isValueDefined, getDefinedValue } from '../values';
/**
 * @template T
 * @typedef Options
 * @property {T | undefined} initial  Initial value
 * @property {T | ""}        fallback Fallback value
 */

/** @type {Readonly<{ initial: undefined, fallback: '' }>} */

var defaultOptions = {
  initial: undefined,

  /**
   * Defaults to empty string, as that is preferred for usage with
   * <input />, <textarea />, and <select /> form elements.
   */
  fallback: ''
};
/**
 * Custom hooks for "controlled" components to track and consolidate internal
 * state and incoming values. This is useful for components that render
 * `input`, `textarea`, or `select` HTML elements.
 *
 * https://reactjs.org/docs/forms.html#controlled-components
 *
 * At first, a component using useControlledState receives an initial prop
 * value, which is used as initial internal state.
 *
 * This internal state can be maintained and updated without
 * relying on new incoming prop values.
 *
 * Unlike the basic useState hook, useControlledState's state can
 * be updated if a new incoming prop value is changed.
 *
 * @template T
 *
 * @param {T | undefined} currentState The current value.
 * @param {Options<T>} [options=defaultOptions] Additional options for the hook.
 *
 * @return {[T | "", (nextState: T) => void]} The controlled value and the value setter.
 */

function useControlledState(currentState) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

  var _defaultOptions$optio = _objectSpread(_objectSpread({}, defaultOptions), options),
      initial = _defaultOptions$optio.initial,
      fallback = _defaultOptions$optio.fallback;

  var _useState = useState(currentState),
      _useState2 = _slicedToArray(_useState, 2),
      internalState = _useState2[0],
      setInternalState = _useState2[1];

  var hasCurrentState = isValueDefined(currentState);
  /*
   * Resets internal state if value every changes from uncontrolled <-> controlled.
   */

  useEffect(function () {
    if (hasCurrentState && internalState) {
      setInternalState(undefined);
    }
  }, [hasCurrentState, internalState]);
  var state = getDefinedValue([currentState, internalState, initial], fallback);
  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {(nextState: T) => void} */

  var setState = function setState(nextState) {
    if (!hasCurrentState) {
      setInternalState(nextState);
    }
  };
  /* eslint-enable jsdoc/no-undefined-types */


  return [state, setState];
}

export default useControlledState;
//# sourceMappingURL=use-controlled-state.js.map