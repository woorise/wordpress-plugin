import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { Animated, PanResponder, View } from 'react-native';
import Video from 'react-native-video';
import { clamp } from 'lodash';
/**
 * WordPress dependencies
 */

import { requestFocalPointPickerTooltipShown, setFocalPointPickerTooltipShown } from '@wordpress/react-native-bridge';
import { __ } from '@wordpress/i18n';
import { Image, UnitControl } from '@wordpress/components';
import { useRef, useState, useMemo, useEffect } from '@wordpress/element';
import { usePreferredColorSchemeStyle } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import FocalPoint from './focal-point';
import Tooltip from './tooltip';
import styles from './style.scss';
import { isVideoType } from './utils';
var MIN_POSITION_VALUE = 0;
var MAX_POSITION_VALUE = 100;
var FOCAL_POINT_UNITS = [{
  default: '50',
  label: '%',
  value: '%'
}];

function FocalPointPicker(props) {
  var focalPoint = props.focalPoint,
      onChange = props.onChange,
      shouldEnableBottomSheetScroll = props.shouldEnableBottomSheetScroll,
      url = props.url;
  var isVideo = isVideoType(url);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      containerSize = _useState2[0],
      setContainerSize = _useState2[1];

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      sliderKey = _useState4[0],
      setSliderKey = _useState4[1];

  var _useState5 = useState(true),
      _useState6 = _slicedToArray(_useState5, 2),
      displayPlaceholder = _useState6[0],
      setDisplayPlaceholder = _useState6[1];

  var _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      videoNaturalSize = _useState8[0],
      setVideoNaturalSize = _useState8[1];

  var _useState9 = useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      tooltipVisible = _useState10[0],
      setTooltipVisible = _useState10[1];

  var locationPageOffsetX = useRef().current;
  var locationPageOffsetY = useRef().current;
  var videoRef = useRef(null);
  useEffect(function () {
    requestFocalPointPickerTooltipShown(function (tooltipShown) {
      if (!tooltipShown) {
        setTooltipVisible(true);
        setFocalPointPickerTooltipShown(true);
      }
    });
  }, []); // Animated coordinates for drag handle

  var pan = useRef(new Animated.ValueXY()).current;
  /**
   * Set drag handle position anytime focal point coordinates change.
   * E.g. initial render, dragging range sliders.
   */

  useEffect(function () {
    if (containerSize) {
      pan.setValue({
        x: focalPoint.x * containerSize.width,
        y: focalPoint.y * containerSize.height
      });
    }
  }, [focalPoint, containerSize]); // Pan responder to manage drag handle interactivity

  var panResponder = useMemo(function () {
    return PanResponder.create({
      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {
        return true;
      },
      onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {
        return true;
      },
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder() {
        return true;
      },
      onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture() {
        return true;
      },
      onPanResponderGrant: function onPanResponderGrant(event) {
        shouldEnableBottomSheetScroll(false);
        var _event$nativeEvent = event.nativeEvent,
            x = _event$nativeEvent.locationX,
            y = _event$nativeEvent.locationY,
            pageX = _event$nativeEvent.pageX,
            pageY = _event$nativeEvent.pageY;
        locationPageOffsetX = pageX - x;
        locationPageOffsetY = pageY - y;
        pan.setValue({
          x: x,
          y: y
        }); // Set cursor to tap location

        pan.extractOffset(); // Set offset to current value
      },
      // Move cursor to match delta drag
      onPanResponderMove: Animated.event([null, {
        dx: pan.x,
        dy: pan.y
      }]),
      onPanResponderRelease: function onPanResponderRelease(event) {
        shouldEnableBottomSheetScroll(true);
        pan.flattenOffset(); // Flatten offset into value

        var _event$nativeEvent2 = event.nativeEvent,
            pageX = _event$nativeEvent2.pageX,
            pageY = _event$nativeEvent2.pageY; // Ideally, x and y below are merely locationX and locationY from the
        // nativeEvent. However, we are required to compute these relative
        // coordinates to workaround a bug affecting Android's PanResponder.
        // Specifically, dragging the handle outside the bounds of the image
        // results in inaccurate locationX and locationY coordinates to be
        // reported. https://git.io/JtWmi

        var x = pageX - locationPageOffsetX;
        var y = pageY - locationPageOffsetY;
        onChange({
          x: clamp(x / (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width), 0, 1).toFixed(2),
          y: clamp(y / (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height), 0, 1).toFixed(2)
        }); // Slider (child of RangeCell) is uncontrolled, so we must increment a
        // key to re-mount and sync the pan gesture values to the sliders
        // https://git.io/JTe4A

        setSliderKey(function (prevState) {
          return prevState + 1;
        });
      }
    });
  }, [containerSize]);
  var mediaBackground = usePreferredColorSchemeStyle(styles.mediaBackground, styles.mediaBackgroundDark);
  var imagePreviewStyles = [displayPlaceholder && styles.mediaPlaceholder, styles.image];
  var videoPreviewStyles = [{
    aspectRatio: videoNaturalSize && videoNaturalSize.width / videoNaturalSize.height,
    // Hide Video component since it has black background while loading the source
    opacity: displayPlaceholder ? 0 : 1
  }, styles.video, displayPlaceholder && styles.mediaPlaceholder];
  var focalPointGroupStyles = [styles.focalPointGroup, {
    transform: [{
      translateX: pan.x.interpolate({
        inputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) || 0],
        outputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) || 0],
        extrapolate: 'clamp'
      })
    }, {
      translateY: pan.y.interpolate({
        inputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) || 0],
        outputRange: [0, (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) || 0],
        extrapolate: 'clamp'
      })
    }]
  }];
  var FOCAL_POINT_SIZE = 50;
  var focalPointStyles = [styles.focalPoint, {
    height: FOCAL_POINT_SIZE,
    marginLeft: -(FOCAL_POINT_SIZE / 2),
    marginTop: -(FOCAL_POINT_SIZE / 2),
    width: FOCAL_POINT_SIZE
  }];

  var onTooltipPress = function onTooltipPress() {
    return setTooltipVisible(false);
  };

  var onMediaLayout = function onMediaLayout(event) {
    var _event$nativeEvent$la = event.nativeEvent.layout,
        height = _event$nativeEvent$la.height,
        width = _event$nativeEvent$la.width;

    if (width !== 0 && height !== 0 && ((containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) !== width || (containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) !== height)) {
      setContainerSize({
        width: width,
        height: height
      });
    }
  };

  var onImageDataLoad = function onImageDataLoad() {
    return setDisplayPlaceholder(false);
  };

  var onVideoLoad = function onVideoLoad(event) {
    var _event$naturalSize = event.naturalSize,
        height = _event$naturalSize.height,
        width = _event$naturalSize.width;
    setVideoNaturalSize({
      height: height,
      width: width
    });
    setDisplayPlaceholder(false); // Avoid invisible, paused video on Android, presumably related to
    // https://git.io/Jt6Dr

    videoRef === null || videoRef === void 0 ? void 0 : videoRef.current.seek(0);
  };

  var onXCoordinateChange = function onXCoordinateChange(x) {
    return onChange({
      x: (x / 100).toFixed(2)
    });
  };

  var onYCoordinateChange = function onYCoordinateChange(y) {
    return onChange({
      y: (y / 100).toFixed(2)
    });
  };

  return createElement(View, {
    style: styles.container
  }, createElement(Tooltip, {
    onPress: onTooltipPress,
    visible: tooltipVisible
  }, createElement(View, {
    style: [styles.media, mediaBackground]
  }, createElement(View, _extends({}, panResponder.panHandlers, {
    onLayout: onMediaLayout,
    style: styles.mediaContainer
  }), !isVideo && createElement(Image, {
    editButton: false,
    highlightSelected: false,
    isSelected: !displayPlaceholder,
    height: "100%",
    url: url,
    style: imagePreviewStyles,
    onImageDataLoad: onImageDataLoad
  }), isVideo && createElement(Video, {
    muted: true,
    paused: true,
    disableFocus: true,
    onLoad: onVideoLoad,
    ref: videoRef,
    resizeMode: "contain",
    source: {
      uri: url
    },
    style: videoPreviewStyles
  }), !displayPlaceholder && createElement(Animated.View, {
    pointerEvents: "none",
    style: focalPointGroupStyles
  }, createElement(Tooltip.Label, {
    text: __('Drag to adjust focal point'),
    yOffset: -(FOCAL_POINT_SIZE / 2)
  }), createElement(FocalPoint, {
    height: styles.focalPoint.height,
    style: focalPointStyles,
    width: styles.focalPoint.width
  })))), createElement(UnitControl, {
    key: "xAxis-".concat(sliderKey),
    label: __('X-Axis Position'),
    max: MAX_POSITION_VALUE,
    min: MIN_POSITION_VALUE,
    onChange: onXCoordinateChange,
    unit: "%",
    units: FOCAL_POINT_UNITS,
    value: Math.round(focalPoint.x * 100)
  }), createElement(UnitControl, {
    key: "yAxis-".concat(sliderKey),
    label: __('Y-Axis Position'),
    max: MAX_POSITION_VALUE,
    min: MIN_POSITION_VALUE,
    onChange: onYCoordinateChange,
    unit: "%",
    units: FOCAL_POINT_UNITS,
    value: Math.round(focalPoint.y * 100)
  })));
}

export default FocalPointPicker;
//# sourceMappingURL=index.native.js.map