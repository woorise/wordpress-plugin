import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { Animated, Easing, PanResponder, Text, View } from 'react-native';
/**
 * WordPress dependencies
 */

import { createContext, useEffect, useRef, useState, useContext } from '@wordpress/element';
/**
 * Internal dependencies
 */

import styles from './style.scss';
var TooltipContext = createContext();

function Tooltip(_ref) {
  var children = _ref.children,
      onPress = _ref.onPress,
      style = _ref.style,
      visible = _ref.visible;
  var panResponder = useRef(PanResponder.create({
    /**
     * To allow dimissing the tooltip on press while also avoiding blocking
     * interactivity within the child context, we place this `onPress` side
     * effect within the `onStartShouldSetPanResponderCapture` callback.
     *
     * This is a bit unorthodox, but may be the simplest approach to achieving
     * this outcome. This is effectively a gesture responder that never
     * becomes the controlling responder. https://bit.ly/2J3ugKF
     */
    onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {
      if (onPress) {
        onPress();
      }

      return false;
    }
  })).current;
  return createElement(TooltipContext.Provider, {
    value: visible
  }, createElement(View, _extends({}, visible ? panResponder.panHandlers : {}, {
    style: style
  }), children));
}

function Label(_ref2) {
  var align = _ref2.align,
      text = _ref2.text,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset;
  var animationValue = useRef(new Animated.Value(0)).current;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      dimensions = _useState2[0],
      setDimensions = _useState2[1];

  var visible = useContext(TooltipContext);

  if (typeof visible === 'undefined') {
    throw new Error('Tooltip.Label cannot be rendered outside of the Tooltip component');
  }

  useEffect(function () {
    startAnimation();
  }, [visible]);

  var startAnimation = function startAnimation() {
    Animated.timing(animationValue, {
      toValue: visible ? 1 : 0,
      duration: visible ? 300 : 150,
      useNativeDriver: true,
      delay: visible ? 500 : 0,
      easing: Easing.out(Easing.quad)
    }).start();
  }; // Transforms rely upon onLayout to enable custom offsets additions


  var tooltipTransforms;

  if (dimensions) {
    tooltipTransforms = [{
      translateX: (align === 'center' ? -dimensions.width / 2 : 0) + xOffset
    }, {
      translateY: -dimensions.height + yOffset
    }];
  }

  var tooltipStyles = [styles.tooltip, {
    shadowColor: styles.tooltipShadow.color,
    shadowOffset: {
      width: 0,
      height: 2
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 2,
    transform: tooltipTransforms
  }, align === 'left' && styles.tooltipLeftAlign];
  var arrowStyles = [styles.arrow, align === 'left' && styles.arrowLeftAlign];
  return createElement(Animated.View, {
    style: {
      opacity: animationValue,
      transform: [{
        translateY: animationValue.interpolate({
          inputRange: [0, 1],
          outputRange: [visible ? 4 : -8, -8]
        })
      }]
    }
  }, createElement(View, {
    onLayout: function onLayout(_ref3) {
      var nativeEvent = _ref3.nativeEvent;
      var _nativeEvent$layout = nativeEvent.layout,
          height = _nativeEvent$layout.height,
          width = _nativeEvent$layout.width;
      setDimensions({
        height: height,
        width: width
      });
    },
    style: tooltipStyles
  }, createElement(Text, {
    style: styles.text
  }, text), createElement(View, {
    style: arrowStyles
  })));
}

Label.defaultProps = {
  align: 'center',
  xOffset: 0,
  yOffset: 0
};
Tooltip.Label = Label;
export default Tooltip;
//# sourceMappingURL=index.native.js.map