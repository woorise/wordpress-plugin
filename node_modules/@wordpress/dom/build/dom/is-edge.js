"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isEdge;

var _lodash = require("lodash");

var _getComputedStyle2 = _interopRequireDefault(require("./get-computed-style"));

var _getRangeHeight = _interopRequireDefault(require("./get-range-height"));

var _getRectangleFromRange = _interopRequireDefault(require("./get-rectangle-from-range"));

var _isSelectionForward = _interopRequireDefault(require("./is-selection-forward"));

var _hiddenCaretRangeFromPoint = _interopRequireDefault(require("./hidden-caret-range-from-point"));

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Check whether the selection is at the edge of the container. Checks for
 * horizontal position by default. Set `onlyVertical` to true to check only
 * vertically.
 *
 * @param {Element} container    Focusable element.
 * @param {boolean} isReverse    Set to true to check left, false to check right.
 * @param {boolean} onlyVertical Set to true to check only vertical position.
 *
 * @return {boolean} True if at the edge, false if not.
 */
function isEdge(container, isReverse, onlyVertical) {
  if ((0, _lodash.includes)(['INPUT', 'TEXTAREA'], container.tagName)) {
    if (container.selectionStart !== container.selectionEnd) {
      return false;
    }

    if (isReverse) {
      return container.selectionStart === 0;
    }

    return container.value.length === container.selectionStart;
  }

  if (!container.isContentEditable) {
    return true;
  }

  var ownerDocument = container.ownerDocument;
  var defaultView = ownerDocument.defaultView;
  var selection = defaultView.getSelection();

  if (!selection.rangeCount) {
    return false;
  }

  var range = selection.getRangeAt(0);
  var collapsedRange = range.cloneRange();
  var isForward = (0, _isSelectionForward.default)(selection);
  var isCollapsed = selection.isCollapsed; // Collapse in direction of selection.

  if (!isCollapsed) {
    collapsedRange.collapse(!isForward);
  }

  var collapsedRangeRect = (0, _getRectangleFromRange.default)(collapsedRange);
  var rangeRect = (0, _getRectangleFromRange.default)(range);

  if (!collapsedRangeRect || !rangeRect) {
    return false;
  } // Only consider the multiline selection at the edge if the direction is
  // towards the edge. The selection is multiline if it is taller than the
  // collapsed  selection.


  if (!isCollapsed && (0, _getRangeHeight.default)(range) > collapsedRangeRect.height && isForward === isReverse) {
    return false;
  } // In the case of RTL scripts, the horizontal edge is at the opposite side.


  var _getComputedStyle = (0, _getComputedStyle2.default)(container),
      direction = _getComputedStyle.direction;

  var isReverseDir = direction === 'rtl' ? !isReverse : isReverse;
  var containerRect = container.getBoundingClientRect(); // To check if a selection is at the edge, we insert a test selection at the
  // edge of the container and check if the selections have the same vertical
  // or horizontal position. If they do, the selection is at the edge.
  // This method proves to be better than a DOM-based calculation for the
  // horizontal edge, since it ignores empty textnodes and a trailing line
  // break element. In other words, we need to check visual positioning, not
  // DOM positioning.
  // It also proves better than using the computed style for the vertical
  // edge, because we cannot know the padding and line height reliably in
  // pixels. `getComputedStyle` may return a value with different units.

  var x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;
  var y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;
  var testRange = (0, _hiddenCaretRangeFromPoint.default)(ownerDocument, x, y, container);

  if (!testRange) {
    return false;
  }

  var testRect = (0, _getRectangleFromRange.default)(testRange);

  if (!testRect) {
    return false;
  }

  var verticalSide = isReverse ? 'top' : 'bottom';
  var horizontalSide = isReverseDir ? 'left' : 'right';
  var verticalDiff = testRect[verticalSide] - rangeRect[verticalSide];
  var horizontalDiff = testRect[horizontalSide] - collapsedRangeRect[horizontalSide]; // Allow the position to be 1px off.

  var hasVerticalDiff = Math.abs(verticalDiff) <= 1;
  var hasHorizontalDiff = Math.abs(horizontalDiff) <= 1;
  return onlyVertical ? hasVerticalDiff : hasVerticalDiff && hasHorizontalDiff;
}
//# sourceMappingURL=is-edge.js.map