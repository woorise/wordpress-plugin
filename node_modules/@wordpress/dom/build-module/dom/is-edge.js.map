{"version":3,"sources":["@wordpress/dom/src/dom/is-edge.js"],"names":["includes","getComputedStyle","getRangeHeight","getRectangleFromRange","isSelectionForward","hiddenCaretRangeFromPoint","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","length","isContentEditable","ownerDocument","defaultView","selection","getSelection","rangeCount","range","getRangeAt","collapsedRange","cloneRange","isForward","isCollapsed","collapse","collapsedRangeRect","rangeRect","height","direction","isReverseDir","containerRect","getBoundingClientRect","x","left","right","y","top","bottom","testRange","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","Math","abs","hasHorizontalDiff"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tif (\n\t\t! isCollapsed &&\n\t\tgetRangeHeight( range ) > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = getComputedStyle( container );\n\tconst isReverseDir = direction === 'rtl' ? ! isReverse : isReverse;\n\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = hiddenCaretRangeFromPoint(\n\t\townerDocument,\n\t\tx,\n\t\ty,\n\t\tcontainer\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n"]}