"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetBlocks = resetBlocks;
exports.validateBlocksToTemplate = validateBlocksToTemplate;
exports.resetSelection = resetSelection;
exports.receiveBlocks = receiveBlocks;
exports.updateBlockAttributes = updateBlockAttributes;
exports.updateBlock = updateBlock;
exports.selectBlock = selectBlock;
exports.selectPreviousBlock = selectPreviousBlock;
exports.selectNextBlock = selectNextBlock;
exports.startMultiSelect = startMultiSelect;
exports.stopMultiSelect = stopMultiSelect;
exports.multiSelect = multiSelect;
exports.clearSelectedBlock = clearSelectedBlock;
exports.toggleSelection = toggleSelection;
exports.replaceBlocks = replaceBlocks;
exports.replaceBlock = replaceBlock;
exports.moveBlocksToPosition = moveBlocksToPosition;
exports.moveBlockToPosition = moveBlockToPosition;
exports.insertBlock = insertBlock;
exports.insertBlocks = insertBlocks;
exports.__unstableSetInsertionPoint = __unstableSetInsertionPoint;
exports.showInsertionPoint = showInsertionPoint;
exports.hideInsertionPoint = hideInsertionPoint;
exports.setTemplateValidity = setTemplateValidity;
exports.synchronizeTemplate = synchronizeTemplate;
exports.mergeBlocks = mergeBlocks;
exports.removeBlocks = removeBlocks;
exports.removeBlock = removeBlock;
exports.replaceInnerBlocks = replaceInnerBlocks;
exports.toggleBlockMode = toggleBlockMode;
exports.startTyping = startTyping;
exports.stopTyping = stopTyping;
exports.startDraggingBlocks = startDraggingBlocks;
exports.stopDraggingBlocks = stopDraggingBlocks;
exports.enterFormattedText = enterFormattedText;
exports.exitFormattedText = exitFormattedText;
exports.selectionChange = selectionChange;
exports.insertDefaultBlock = insertDefaultBlock;
exports.updateBlockListSettings = updateBlockListSettings;
exports.updateSettings = updateSettings;
exports.__unstableSaveReusableBlock = __unstableSaveReusableBlock;
exports.__unstableMarkLastChangeAsPersistent = __unstableMarkLastChangeAsPersistent;
exports.__unstableMarkNextChangeAsNotPersistent = __unstableMarkNextChangeAsNotPersistent;
exports.__unstableMarkAutomaticChange = __unstableMarkAutomaticChange;
exports.__unstableMarkAutomaticChangeFinal = __unstableMarkAutomaticChangeFinal;
exports.setNavigationMode = setNavigationMode;
exports.setBlockMovingClientId = setBlockMovingClientId;
exports.duplicateBlocks = duplicateBlocks;
exports.insertBeforeBlock = insertBeforeBlock;
exports.insertAfterBlock = insertAfterBlock;
exports.toggleBlockHighlight = toggleBlockHighlight;
exports.flashBlock = flashBlock;
exports.setHasControlledInnerBlocks = setHasControlledInnerBlocks;
exports.moveBlocksUp = exports.moveBlocksDown = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _lodash = require("lodash");

var _blocks = require("@wordpress/blocks");

var _a11y = require("@wordpress/a11y");

var _i18n = require("@wordpress/i18n");

var _data = require("@wordpress/data");

var _richText = require("@wordpress/rich-text");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _controls = require("../store/controls");

var _constants = require("./constants");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _marked = /*#__PURE__*/_regenerator.default.mark(ensureDefaultBlock),
    _marked2 = /*#__PURE__*/_regenerator.default.mark(resetBlocks),
    _marked3 = /*#__PURE__*/_regenerator.default.mark(validateBlocksToTemplate),
    _marked4 = /*#__PURE__*/_regenerator.default.mark(selectPreviousBlock),
    _marked5 = /*#__PURE__*/_regenerator.default.mark(selectNextBlock),
    _marked6 = /*#__PURE__*/_regenerator.default.mark(multiSelect),
    _marked7 = /*#__PURE__*/_regenerator.default.mark(replaceBlocks),
    _marked8 = /*#__PURE__*/_regenerator.default.mark(moveBlocksToPosition),
    _marked9 = /*#__PURE__*/_regenerator.default.mark(moveBlockToPosition),
    _marked10 = /*#__PURE__*/_regenerator.default.mark(insertBlocks),
    _marked11 = /*#__PURE__*/_regenerator.default.mark(synchronizeTemplate),
    _marked12 = /*#__PURE__*/_regenerator.default.mark(mergeBlocks),
    _marked13 = /*#__PURE__*/_regenerator.default.mark(removeBlocks),
    _marked14 = /*#__PURE__*/_regenerator.default.mark(__unstableMarkAutomaticChange),
    _marked15 = /*#__PURE__*/_regenerator.default.mark(setNavigationMode),
    _marked16 = /*#__PURE__*/_regenerator.default.mark(setBlockMovingClientId),
    _marked17 = /*#__PURE__*/_regenerator.default.mark(duplicateBlocks),
    _marked18 = /*#__PURE__*/_regenerator.default.mark(insertBeforeBlock),
    _marked19 = /*#__PURE__*/_regenerator.default.mark(insertAfterBlock),
    _marked20 = /*#__PURE__*/_regenerator.default.mark(flashBlock);

/**
 * Generator which will yield a default block insert action if there
 * are no other blocks at the root of the editor. This generator should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */
function ensureDefaultBlock() {
  var count;
  return _regenerator.default.wrap(function ensureDefaultBlock$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockCount');

        case 2:
          count = _context.sent;

          if (!(count === 0)) {
            _context.next = 7;
            break;
          }

          _context.next = 6;
          return insertDefaultBlock();

        case 6:
          return _context.abrupt("return", _context.sent);

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Returns an action object used in signalling that blocks state should be
 * reset to the specified array of blocks, taking precedence over any other
 * content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */


function resetBlocks(blocks) {
  return _regenerator.default.wrap(function resetBlocks$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return {
            type: 'RESET_BLOCKS',
            blocks: blocks
          };

        case 2:
          return _context2.delegateYield(validateBlocksToTemplate(blocks), "t0", 3);

        case 3:
          return _context2.abrupt("return", _context2.t0);

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side-
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */


function validateBlocksToTemplate(blocks) {
  var template, templateLock, isBlocksValidToTemplate, isValidTemplate;
  return _regenerator.default.wrap(function validateBlocksToTemplate$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplate');

        case 2:
          template = _context3.sent;
          _context3.next = 5;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplateLock');

        case 5:
          templateLock = _context3.sent;
          // Unlocked templates are considered always valid because they act
          // as default values only.
          isBlocksValidToTemplate = !template || templateLock !== 'all' || (0, _blocks.doBlocksMatchTemplate)(blocks, template); // Update if validity has changed.

          _context3.next = 9;
          return _data.controls.select(_constants.STORE_NAME, 'isValidTemplate');

        case 9:
          isValidTemplate = _context3.sent;

          if (!(isBlocksValidToTemplate !== isValidTemplate)) {
            _context3.next = 14;
            break;
          }

          _context3.next = 13;
          return setTemplateValidity(isBlocksValidToTemplate);

        case 13:
          return _context3.abrupt("return", isBlocksValidToTemplate);

        case 14:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */


function resetSelection(selectionStart, selectionEnd, initialPosition) {
  return {
    type: 'RESET_SELECTION',
    selectionStart: selectionStart,
    selectionEnd: selectionEnd,
    initialPosition: initialPosition
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */


function receiveBlocks(blocks) {
  return {
    type: 'RECEIVE_BLOCKS',
    blocks: blocks
  };
}
/**
 * Returns an action object used in signalling that the multiple blocks'
 * attributes with the specified client IDs have been updated.
 *
 * @param {string|string[]} clientIds  Block client IDs.
 * @param {Object}          attributes Block attributes to be merged. Should be keyed by clientIds if
 * uniqueByBlock is true.
 * @param {boolean}          uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */


function updateBlockAttributes(clientIds, attributes) {
  var uniqueByBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: (0, _lodash.castArray)(clientIds),
    attributes: attributes,
    uniqueByBlock: uniqueByBlock
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been updated.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */


function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId: clientId,
    updates: updates
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                  reflect reverse selection.
 *
 * @return {Object} Action object.
 */


function selectBlock(clientId) {
  var initialPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return {
    type: 'SELECT_BLOCK',
    initialPosition: initialPosition,
    clientId: clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */


function selectPreviousBlock(clientId) {
  var previousBlockClientId;
  return _regenerator.default.wrap(function selectPreviousBlock$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return _data.controls.select(_constants.STORE_NAME, 'getPreviousBlockClientId', clientId);

        case 2:
          previousBlockClientId = _context4.sent;

          if (!previousBlockClientId) {
            _context4.next = 7;
            break;
          }

          _context4.next = 6;
          return selectBlock(previousBlockClientId, -1);

        case 6:
          return _context4.abrupt("return", [previousBlockClientId]);

        case 7:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */


function selectNextBlock(clientId) {
  var nextBlockClientId;
  return _regenerator.default.wrap(function selectNextBlock$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return _data.controls.select(_constants.STORE_NAME, 'getNextBlockClientId', clientId);

        case 2:
          nextBlockClientId = _context5.sent;

          if (!nextBlockClientId) {
            _context5.next = 7;
            break;
          }

          _context5.next = 6;
          return selectBlock(nextBlockClientId);

        case 6:
          return _context5.abrupt("return", [nextBlockClientId]);

        case 7:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Returns an action object used in signalling that a block multi-selection has started.
 *
 * @return {Object} Action object.
 */


function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection stopped.
 *
 * @return {Object} Action object.
 */


function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection changed.
 *
 * @param {string} start First block of the multi selection.
 * @param {string} end   Last block of the multiselection.
 */


function multiSelect(start, end) {
  var blockCount;
  return _regenerator.default.wrap(function multiSelect$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return {
            type: 'MULTI_SELECT',
            start: start,
            end: end
          };

        case 2:
          _context6.next = 4;
          return _data.controls.select(_constants.STORE_NAME, 'getSelectedBlockCount');

        case 4:
          blockCount = _context6.sent;
          (0, _a11y.speak)((0, _i18n.sprintf)(
          /* translators: %s: number of selected blocks */
          (0, _i18n._n)('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');

        case 6:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Returns an action object used in signalling that the block selection is cleared.
 *
 * @return {Object} Action object.
 */


function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Returns an action object that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */


function toggleSelection() {
  var isSelectionEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled: isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var _blockEditorSettings$, _blockEditorSettings$2;

  var preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings === null || blockEditorSettings === void 0 ? void 0 : (_blockEditorSettings$2 = blockEditorSettings.__experimentalPreferredStyleVariations) === null || _blockEditorSettings$2 === void 0 ? void 0 : _blockEditorSettings$2.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
  return blocks.map(function (block) {
    var _block$attributes;

    var blockName = block.name;

    if (!(0, _blocks.hasBlockSupport)(blockName, 'defaultStylePicker', true)) {
      return block;
    }

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    var className = (_block$attributes = block.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.className;

    if (className !== null && className !== void 0 && className.includes('is-style-')) {
      return block;
    }

    var _block$attributes2 = block.attributes,
        attributes = _block$attributes2 === void 0 ? {} : _block$attributes2;
    var blockStyle = preferredStyleVariations[blockName];
    return _objectSpread(_objectSpread({}, block), {}, {
      attributes: _objectSpread(_objectSpread({}, attributes), {}, {
        className: "".concat(className || '', " is-style-").concat(blockStyle).trim()
      })
    });
  });
}
/**
 * Returns an action object signalling that a blocks should be replaced with
 * one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @yield {Object} Action object.
 */


function replaceBlocks(clientIds, blocks, indexToSelect) {
  var initialPosition,
      meta,
      rootClientId,
      index,
      block,
      canInsertBlock,
      _args7 = arguments;
  return _regenerator.default.wrap(function replaceBlocks$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          initialPosition = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : 0;
          meta = _args7.length > 4 ? _args7[4] : undefined;
          clientIds = (0, _lodash.castArray)(clientIds);
          _context7.t0 = getBlocksWithDefaultStylesApplied;
          _context7.t1 = (0, _lodash.castArray)(blocks);
          _context7.next = 7;
          return _data.controls.select(_constants.STORE_NAME, 'getSettings');

        case 7:
          _context7.t2 = _context7.sent;
          blocks = (0, _context7.t0)(_context7.t1, _context7.t2);
          _context7.next = 11;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockRootClientId', (0, _lodash.first)(clientIds));

        case 11:
          rootClientId = _context7.sent;
          index = 0;

        case 13:
          if (!(index < blocks.length)) {
            _context7.next = 23;
            break;
          }

          block = blocks[index];
          _context7.next = 17;
          return _data.controls.select(_constants.STORE_NAME, 'canInsertBlockType', block.name, rootClientId);

        case 17:
          canInsertBlock = _context7.sent;

          if (canInsertBlock) {
            _context7.next = 20;
            break;
          }

          return _context7.abrupt("return");

        case 20:
          index++;
          _context7.next = 13;
          break;

        case 23:
          _context7.next = 25;
          return {
            type: 'REPLACE_BLOCKS',
            clientIds: clientIds,
            blocks: blocks,
            time: Date.now(),
            indexToSelect: indexToSelect,
            initialPosition: initialPosition,
            meta: meta
          };

        case 25:
          return _context7.delegateYield(ensureDefaultBlock(), "t3", 26);

        case 26:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7);
}
/**
 * Returns an action object signalling that a single block should be replaced
 * with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */


function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */


function createOnMove(type) {
  return function (clientIds, rootClientId) {
    return {
      clientIds: (0, _lodash.castArray)(clientIds),
      type: type,
      rootClientId: rootClientId
    };
  };
}

var moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
exports.moveBlocksDown = moveBlocksDown;
var moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Returns an action object signalling that the given blocks should be moved to
 * a new position.
 *
 * @param  {?string} clientIds        The client IDs of the blocks.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the blocks to.
 *
 * @yield {Object} Action object.
 */

exports.moveBlocksUp = moveBlocksUp;

function moveBlocksToPosition(clientIds) {
  var fromRootClientId,
      toRootClientId,
      index,
      templateLock,
      action,
      canInsertBlocks,
      _args8 = arguments;
  return _regenerator.default.wrap(function moveBlocksToPosition$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          fromRootClientId = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : '';
          toRootClientId = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : '';
          index = _args8.length > 3 ? _args8[3] : undefined;
          _context8.next = 5;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplateLock', fromRootClientId);

        case 5:
          templateLock = _context8.sent;

          if (!(templateLock === 'all')) {
            _context8.next = 8;
            break;
          }

          return _context8.abrupt("return");

        case 8:
          action = {
            type: 'MOVE_BLOCKS_TO_POSITION',
            fromRootClientId: fromRootClientId,
            toRootClientId: toRootClientId,
            clientIds: clientIds,
            index: index
          }; // If moving inside the same root block the move is always possible.

          if (!(fromRootClientId === toRootClientId)) {
            _context8.next = 13;
            break;
          }

          _context8.next = 12;
          return action;

        case 12:
          return _context8.abrupt("return");

        case 13:
          if (!(templateLock === 'insert')) {
            _context8.next = 15;
            break;
          }

          return _context8.abrupt("return");

        case 15:
          _context8.next = 17;
          return _data.controls.select(_constants.STORE_NAME, 'canInsertBlocks', clientIds, toRootClientId);

        case 17:
          canInsertBlocks = _context8.sent;

          if (!canInsertBlocks) {
            _context8.next = 21;
            break;
          }

          _context8.next = 21;
          return action;

        case 21:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8);
}
/**
 * Returns an action object signalling that the given block should be moved to a
 * new position.
 *
 * @param  {?string} clientId         The client ID of the block.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the block to.
 *
 * @yield {Object} Action object.
 */


function moveBlockToPosition(clientId) {
  var fromRootClientId,
      toRootClientId,
      index,
      _args9 = arguments;
  return _regenerator.default.wrap(function moveBlockToPosition$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          fromRootClientId = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : '';
          toRootClientId = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : '';
          index = _args9.length > 3 ? _args9[3] : undefined;
          _context9.next = 5;
          return moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);

        case 5:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked9);
}
/**
 * Returns an action object used in signalling that a single block should be
 * inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object}  block            Block object to insert.
 * @param {?number} index            Index at which block should be inserted.
 * @param {?string} rootClientId     Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 *
 * @return {Object} Action object.
 */


function insertBlock(block, index, rootClientId) {
  var updateSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return insertBlocks([block], index, rootClientId, updateSelection);
}
/**
 * Returns an action object used in signalling that an array of blocks should
 * be inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 * @return {Object} Action object.
 */


function insertBlocks(blocks, index, rootClientId) {
  var updateSelection,
      initialPosition,
      meta,
      allowedBlocks,
      _iterator,
      _step,
      block,
      isValid,
      _args10 = arguments;

  return _regenerator.default.wrap(function insertBlocks$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          updateSelection = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : true;
          initialPosition = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : 0;
          meta = _args10.length > 5 ? _args10[5] : undefined;

          if ((0, _lodash.isObject)(initialPosition)) {
            meta = initialPosition;
            initialPosition = 0;
            (0, _deprecated.default)("meta argument in wp.data.dispatch('core/block-editor')", {
              since: '10.1',
              plugin: 'Gutenberg',
              hint: 'The meta argument is now the 6th argument of the function'
            });
          }

          _context10.t0 = getBlocksWithDefaultStylesApplied;
          _context10.t1 = (0, _lodash.castArray)(blocks);
          _context10.next = 8;
          return _data.controls.select(_constants.STORE_NAME, 'getSettings');

        case 8:
          _context10.t2 = _context10.sent;
          blocks = (0, _context10.t0)(_context10.t1, _context10.t2);
          allowedBlocks = [];
          _iterator = _createForOfIteratorHelper(blocks);
          _context10.prev = 12;

          _iterator.s();

        case 14:
          if ((_step = _iterator.n()).done) {
            _context10.next = 22;
            break;
          }

          block = _step.value;
          _context10.next = 18;
          return _data.controls.select(_constants.STORE_NAME, 'canInsertBlockType', block.name, rootClientId);

        case 18:
          isValid = _context10.sent;

          if (isValid) {
            allowedBlocks.push(block);
          }

        case 20:
          _context10.next = 14;
          break;

        case 22:
          _context10.next = 27;
          break;

        case 24:
          _context10.prev = 24;
          _context10.t3 = _context10["catch"](12);

          _iterator.e(_context10.t3);

        case 27:
          _context10.prev = 27;

          _iterator.f();

          return _context10.finish(27);

        case 30:
          if (!allowedBlocks.length) {
            _context10.next = 32;
            break;
          }

          return _context10.abrupt("return", {
            type: 'INSERT_BLOCKS',
            blocks: allowedBlocks,
            index: index,
            rootClientId: rootClientId,
            time: Date.now(),
            updateSelection: updateSelection,
            initialPosition: updateSelection ? initialPosition : null,
            meta: meta
          });

        case 32:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked10, null, [[12, 24, 27, 30]]);
}
/**
 * Sets the insertion point without showing it to users.
 *
 * Components like <Inserter> will default to inserting blocks at this point.
 *
 * @param {?string} rootClientId Root client ID of block list in which to
 *                               insert. Use `undefined` for the root block
 *                               list.
 * @param {number} index         Index at which block should be inserted.
 *
 * @return {Object} Action object.
 */


function __unstableSetInsertionPoint(rootClientId, index) {
  return {
    type: 'SET_INSERTION_POINT',
    rootClientId: rootClientId,
    index: index
  };
}
/**
 * Sets the insertion point and shows it to users.
 *
 * Components like <Inserter> will default to inserting blocks at this point.
 *
 * @param {?string} rootClientId Root client ID of block list in which to
 *                               insert. Use `undefined` for the root block
 *                               list.
 * @param {number} index         Index at which block should be inserted.
 *
 * @return {Object} Action object.
 */


function showInsertionPoint(rootClientId, index) {
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId: rootClientId,
    index: index
  };
}
/**
 * Hides the insertion point for users.
 *
 * @return {Object} Action object.
 */


function hideInsertionPoint() {
  return {
    type: 'HIDE_INSERTION_POINT'
  };
}
/**
 * Returns an action object resetting the template validity.
 *
 * @param {boolean}  isValid  template validity flag.
 *
 * @return {Object} Action object.
 */


function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid: isValid
  };
}
/**
 * Returns an action object synchronize the template with the list of blocks
 *
 * @return {Object} Action object.
 */


function synchronizeTemplate() {
  var blocks, template, updatedBlockList;
  return _regenerator.default.wrap(function synchronizeTemplate$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return {
            type: 'SYNCHRONIZE_TEMPLATE'
          };

        case 2:
          _context11.next = 4;
          return _data.controls.select(_constants.STORE_NAME, 'getBlocks');

        case 4:
          blocks = _context11.sent;
          _context11.next = 7;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplate');

        case 7:
          template = _context11.sent;
          updatedBlockList = (0, _blocks.synchronizeBlocksWithTemplate)(blocks, template);
          _context11.next = 11;
          return resetBlocks(updatedBlockList);

        case 11:
          return _context11.abrupt("return", _context11.sent);

        case 12:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked11);
}
/**
 * Returns an action object used in signalling that two blocks should be merged
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */


function mergeBlocks(firstBlockClientId, secondBlockClientId) {
  var blocks, clientIdA, clientIdB, blockA, blockAType, blockB, blockBType, _yield$controls$selec, clientId, attributeKey, offset, selectedBlockType, attributeDefinition, canRestoreTextSelection, START_OF_SELECTED_AREA, cloneA, cloneB, selectedBlock, html, multilineTag, multilineWrapperTags, preserveWhiteSpace, value, blocksWithTheSameType, updatedAttributes, newAttributeKey, convertedHtml, _blockAType$attribute, _multilineTag, _multilineWrapperTags, _preserveWhiteSpace, convertedValue, newOffset, newValue, newHtml;

  return _regenerator.default.wrap(function mergeBlocks$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          blocks = [firstBlockClientId, secondBlockClientId];
          _context12.next = 3;
          return {
            type: 'MERGE_BLOCKS',
            blocks: blocks
          };

        case 3:
          clientIdA = blocks[0], clientIdB = blocks[1];
          _context12.next = 6;
          return _data.controls.select(_constants.STORE_NAME, 'getBlock', clientIdA);

        case 6:
          blockA = _context12.sent;
          blockAType = (0, _blocks.getBlockType)(blockA.name); // Only focus the previous block if it's not mergeable

          if (blockAType.merge) {
            _context12.next = 12;
            break;
          }

          _context12.next = 11;
          return selectBlock(blockA.clientId);

        case 11:
          return _context12.abrupt("return");

        case 12:
          _context12.next = 14;
          return _data.controls.select(_constants.STORE_NAME, 'getBlock', clientIdB);

        case 14:
          blockB = _context12.sent;
          blockBType = (0, _blocks.getBlockType)(blockB.name);
          _context12.next = 18;
          return _data.controls.select(_constants.STORE_NAME, 'getSelectionStart');

        case 18:
          _yield$controls$selec = _context12.sent;
          clientId = _yield$controls$selec.clientId;
          attributeKey = _yield$controls$selec.attributeKey;
          offset = _yield$controls$selec.offset;
          selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
          attributeDefinition = selectedBlockType.attributes[attributeKey];
          canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined && // We cannot restore text selection if the RichText identifier
          // is not a defined block attribute key. This can be the case if the
          // fallback intance ID is used to store selection (and no RichText
          // identifier is set), or when the identifier is wrong.
          !!attributeDefinition;

          if (!attributeDefinition) {
            if (typeof attributeKey === 'number') {
              window.console.error("RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ".concat((0, _typeof2.default)(attributeKey)));
            } else {
              window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
            }
          } // A robust way to retain selection position through various transforms
          // is to insert a special character at the position and then recover it.


          START_OF_SELECTED_AREA = "\x86"; // Clone the blocks so we don't insert the character in a "live" block.

          cloneA = (0, _blocks.cloneBlock)(blockA);
          cloneB = (0, _blocks.cloneBlock)(blockB);

          if (canRestoreTextSelection) {
            selectedBlock = clientId === clientIdA ? cloneA : cloneB;
            html = selectedBlock.attributes[attributeKey];
            multilineTag = attributeDefinition.multiline, multilineWrapperTags = attributeDefinition.__unstableMultilineWrapperTags, preserveWhiteSpace = attributeDefinition.__unstablePreserveWhiteSpace;
            value = (0, _richText.insert)((0, _richText.create)({
              html: html,
              multilineTag: multilineTag,
              multilineWrapperTags: multilineWrapperTags,
              preserveWhiteSpace: preserveWhiteSpace
            }), START_OF_SELECTED_AREA, offset, offset);
            selectedBlock.attributes[attributeKey] = (0, _richText.toHTMLString)({
              value: value,
              multilineTag: multilineTag,
              preserveWhiteSpace: preserveWhiteSpace
            });
          } // We can only merge blocks with similar types
          // thus, we transform the block to merge first


          blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0, _blocks.switchToBlockType)(cloneB, blockA.name); // If the block types can not match, do nothing

          if (!(!blocksWithTheSameType || !blocksWithTheSameType.length)) {
            _context12.next = 33;
            break;
          }

          return _context12.abrupt("return");

        case 33:
          // Calling the merge to update the attributes and remove the block to be merged
          updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);

          if (!canRestoreTextSelection) {
            _context12.next = 45;
            break;
          }

          newAttributeKey = (0, _lodash.findKey)(updatedAttributes, function (v) {
            return typeof v === 'string' && v.indexOf(START_OF_SELECTED_AREA) !== -1;
          });
          convertedHtml = updatedAttributes[newAttributeKey];
          _blockAType$attribute = blockAType.attributes[newAttributeKey], _multilineTag = _blockAType$attribute.multiline, _multilineWrapperTags = _blockAType$attribute.__unstableMultilineWrapperTags, _preserveWhiteSpace = _blockAType$attribute.__unstablePreserveWhiteSpace;
          convertedValue = (0, _richText.create)({
            html: convertedHtml,
            multilineTag: _multilineTag,
            multilineWrapperTags: _multilineWrapperTags,
            preserveWhiteSpace: _preserveWhiteSpace
          });
          newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
          newValue = (0, _richText.remove)(convertedValue, newOffset, newOffset + 1);
          newHtml = (0, _richText.toHTMLString)({
            value: newValue,
            multilineTag: _multilineTag,
            preserveWhiteSpace: _preserveWhiteSpace
          });
          updatedAttributes[newAttributeKey] = newHtml;
          _context12.next = 45;
          return selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);

        case 45:
          return _context12.delegateYield(replaceBlocks([blockA.clientId, blockB.clientId], [_objectSpread(_objectSpread({}, blockA), {}, {
            attributes: _objectSpread(_objectSpread({}, blockA.attributes), updatedAttributes)
          })].concat((0, _toConsumableArray2.default)(blocksWithTheSameType.slice(1)))), "t0", 46);

        case 46:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked12);
}
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block should be
 *                                         selected when a block is removed.
 */


function removeBlocks(clientIds) {
  var selectPrevious,
      rootClientId,
      isLocked,
      previousBlockId,
      defaultBlockId,
      _args13 = arguments;
  return _regenerator.default.wrap(function removeBlocks$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          selectPrevious = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : true;

          if (!(!clientIds || !clientIds.length)) {
            _context13.next = 3;
            break;
          }

          return _context13.abrupt("return");

        case 3:
          clientIds = (0, _lodash.castArray)(clientIds);
          _context13.next = 6;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockRootClientId', clientIds[0]);

        case 6:
          rootClientId = _context13.sent;
          _context13.next = 9;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplateLock', rootClientId);

        case 9:
          isLocked = _context13.sent;

          if (!isLocked) {
            _context13.next = 12;
            break;
          }

          return _context13.abrupt("return");

        case 12:
          if (!selectPrevious) {
            _context13.next = 18;
            break;
          }

          _context13.next = 15;
          return selectPreviousBlock(clientIds[0]);

        case 15:
          previousBlockId = _context13.sent;
          _context13.next = 21;
          break;

        case 18:
          _context13.next = 20;
          return _data.controls.select(_constants.STORE_NAME, 'getPreviousBlockClientId', clientIds[0]);

        case 20:
          previousBlockId = _context13.sent;

        case 21:
          _context13.next = 23;
          return {
            type: 'REMOVE_BLOCKS',
            clientIds: clientIds
          };

        case 23:
          return _context13.delegateYield(ensureDefaultBlock(), "t0", 24);

        case 24:
          defaultBlockId = _context13.t0;
          return _context13.abrupt("return", [previousBlockId || defaultBlockId]);

        case 26:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked13);
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */


function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */


function replaceInnerBlocks(rootClientId, blocks) {
  var updateSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var initialPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId: rootClientId,
    blocks: blocks,
    updateSelection: updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */


function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId: clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */


function startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */


function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */


function startDraggingBlocks() {
  var clientIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds: clientIds
  };
}
/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */


function stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @return {Object} Action object.
 */


function enterFormattedText() {
  return {
    type: 'ENTER_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @return {Object} Action object.
 */


function exitFormattedText() {
  return {
    type: 'EXIT_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has changed
 * position.
 *
 * @param {string} clientId     The selected block client ID.
 * @param {string} attributeKey The selected block attribute key.
 * @param {number} startOffset  The start offset.
 * @param {number} endOffset    The end offset.
 *
 * @return {Object} Action object.
 */


function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  return {
    type: 'SELECTION_CHANGE',
    clientId: clientId,
    attributeKey: attributeKey,
    startOffset: startOffset,
    endOffset: endOffset
  };
}
/**
 * Returns an action object used in signalling that a new block of the default
 * type should be added to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block
 *
 * @return {Object} Action object
 */


function insertDefaultBlock(attributes, rootClientId, index) {
  // Abort if there is no default block type (if it has been unregistered).
  var defaultBlockName = (0, _blocks.getDefaultBlockName)();

  if (!defaultBlockName) {
    return;
  }

  var block = (0, _blocks.createBlock)(defaultBlockName, attributes);
  return insertBlock(block, index, rootClientId);
}
/**
 * Returns an action object that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */


function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId: clientId,
    settings: settings
  };
}
/**
 * Returns an action object used in signalling that the block editor settings have been updated.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */


function updateSettings(settings) {
  return {
    type: 'UPDATE_SETTINGS',
    settings: settings
  };
}
/**
 * Returns an action object used in signalling that a temporary reusable blocks have been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */


function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id: id,
    updatedId: updatedId
  };
}
/**
 * Returns an action object used in signalling that the last block change should be marked explicitly as persistent.
 *
 * @return {Object} Action object.
 */


function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */


function __unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the last block change is
 * an automatic change, meaning it was not performed by the user, and can be
 * undone using the `Escape` and `Backspace` keys. This action must be called
 * after the change was made, and any actions that are a consequence of it, so
 * it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */


function __unstableMarkAutomaticChange() {
  return _regenerator.default.wrap(function __unstableMarkAutomaticChange$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          _context14.next = 2;
          return {
            type: 'MARK_AUTOMATIC_CHANGE'
          };

        case 2:
          _context14.next = 4;
          return (0, _controls.__unstableMarkAutomaticChangeFinalControl)();

        case 4:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked14);
}

function __unstableMarkAutomaticChangeFinal() {
  return {
    type: 'MARK_AUTOMATIC_CHANGE_FINAL'
  };
}
/**
 * Generators that triggers an action used to enable or disable the navigation mode.
 *
 * @param {string} isNavigationMode Enable/Disable navigation mode.
 */


function setNavigationMode() {
  var isNavigationMode,
      _args15 = arguments;
  return _regenerator.default.wrap(function setNavigationMode$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          isNavigationMode = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : true;
          _context15.next = 3;
          return {
            type: 'SET_NAVIGATION_MODE',
            isNavigationMode: isNavigationMode
          };

        case 3:
          if (isNavigationMode) {
            (0, _a11y.speak)((0, _i18n.__)('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
          } else {
            (0, _a11y.speak)((0, _i18n.__)('You are currently in edit mode. To return to the navigation mode, press Escape.'));
          }

        case 4:
        case "end":
          return _context15.stop();
      }
    }
  }, _marked15);
}
/**
 * Generator that triggers an action used to enable or disable the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */


function setBlockMovingClientId() {
  var hasBlockMovingClientId,
      _args16 = arguments;
  return _regenerator.default.wrap(function setBlockMovingClientId$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          hasBlockMovingClientId = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : null;
          _context16.next = 3;
          return {
            type: 'SET_BLOCK_MOVING_MODE',
            hasBlockMovingClientId: hasBlockMovingClientId
          };

        case 3:
          if (hasBlockMovingClientId) {
            (0, _a11y.speak)((0, _i18n.__)('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
          }

        case 4:
        case "end":
          return _context16.stop();
      }
    }
  }, _marked16);
}
/**
 * Generator that triggers an action used to duplicate a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean} updateSelection
 */


function duplicateBlocks(clientIds) {
  var updateSelection,
      blocks,
      rootClientId,
      blockNames,
      lastSelectedIndex,
      clonedBlocks,
      _args17 = arguments;
  return _regenerator.default.wrap(function duplicateBlocks$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          updateSelection = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : true;

          if (!(!clientIds && !clientIds.length)) {
            _context17.next = 3;
            break;
          }

          return _context17.abrupt("return");

        case 3:
          _context17.next = 5;
          return _data.controls.select(_constants.STORE_NAME, 'getBlocksByClientId', clientIds);

        case 5:
          blocks = _context17.sent;
          _context17.next = 8;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockRootClientId', clientIds[0]);

        case 8:
          rootClientId = _context17.sent;

          if (!(0, _lodash.some)(blocks, function (block) {
            return !block;
          })) {
            _context17.next = 11;
            break;
          }

          return _context17.abrupt("return");

        case 11:
          blockNames = blocks.map(function (block) {
            return block.name;
          }); // Return early if blocks don't support multiple usage.

          if (!(0, _lodash.some)(blockNames, function (blockName) {
            return !(0, _blocks.hasBlockSupport)(blockName, 'multiple', true);
          })) {
            _context17.next = 14;
            break;
          }

          return _context17.abrupt("return");

        case 14:
          _context17.next = 16;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockIndex', (0, _lodash.last)((0, _lodash.castArray)(clientIds)), rootClientId);

        case 16:
          lastSelectedIndex = _context17.sent;
          clonedBlocks = blocks.map(function (block) {
            return (0, _blocks.__experimentalCloneSanitizedBlock)(block);
          });
          _context17.next = 20;
          return insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);

        case 20:
          if (!(clonedBlocks.length > 1 && updateSelection)) {
            _context17.next = 23;
            break;
          }

          _context17.next = 23;
          return multiSelect((0, _lodash.first)(clonedBlocks).clientId, (0, _lodash.last)(clonedBlocks).clientId);

        case 23:
          return _context17.abrupt("return", clonedBlocks.map(function (block) {
            return block.clientId;
          }));

        case 24:
        case "end":
          return _context17.stop();
      }
    }
  }, _marked17);
}
/**
 * Generator used to insert an empty block after a given block.
 *
 * @param {string} clientId
 */


function insertBeforeBlock(clientId) {
  var rootClientId, isLocked, firstSelectedIndex;
  return _regenerator.default.wrap(function insertBeforeBlock$(_context18) {
    while (1) {
      switch (_context18.prev = _context18.next) {
        case 0:
          if (clientId) {
            _context18.next = 2;
            break;
          }

          return _context18.abrupt("return");

        case 2:
          _context18.next = 4;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockRootClientId', clientId);

        case 4:
          rootClientId = _context18.sent;
          _context18.next = 7;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplateLock', rootClientId);

        case 7:
          isLocked = _context18.sent;

          if (!isLocked) {
            _context18.next = 10;
            break;
          }

          return _context18.abrupt("return");

        case 10:
          _context18.next = 12;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockIndex', clientId, rootClientId);

        case 12:
          firstSelectedIndex = _context18.sent;
          _context18.next = 15;
          return insertDefaultBlock({}, rootClientId, firstSelectedIndex);

        case 15:
          return _context18.abrupt("return", _context18.sent);

        case 16:
        case "end":
          return _context18.stop();
      }
    }
  }, _marked18);
}
/**
 * Generator used to insert an empty block before a given block.
 *
 * @param {string} clientId
 */


function insertAfterBlock(clientId) {
  var rootClientId, isLocked, firstSelectedIndex;
  return _regenerator.default.wrap(function insertAfterBlock$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          if (clientId) {
            _context19.next = 2;
            break;
          }

          return _context19.abrupt("return");

        case 2:
          _context19.next = 4;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockRootClientId', clientId);

        case 4:
          rootClientId = _context19.sent;
          _context19.next = 7;
          return _data.controls.select(_constants.STORE_NAME, 'getTemplateLock', rootClientId);

        case 7:
          isLocked = _context19.sent;

          if (!isLocked) {
            _context19.next = 10;
            break;
          }

          return _context19.abrupt("return");

        case 10:
          _context19.next = 12;
          return _data.controls.select(_constants.STORE_NAME, 'getBlockIndex', clientId, rootClientId);

        case 12:
          firstSelectedIndex = _context19.sent;
          _context19.next = 15;
          return insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);

        case 15:
          return _context19.abrupt("return", _context19.sent);

        case 16:
        case "end":
          return _context19.stop();
      }
    }
  }, _marked19);
}
/**
 * Returns an action object that toggles the highlighted block state.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */


function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId: clientId,
    isHighlighted: isHighlighted
  };
}
/**
 * Yields action objects used in signalling that the block corresponding to the
 * given clientId should appear to "flash" by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */


function flashBlock(clientId) {
  return _regenerator.default.wrap(function flashBlock$(_context20) {
    while (1) {
      switch (_context20.prev = _context20.next) {
        case 0:
          _context20.next = 2;
          return toggleBlockHighlight(clientId, true);

        case 2:
          _context20.next = 4;
          return {
            type: 'SLEEP',
            duration: 150
          };

        case 4:
          _context20.next = 6;
          return toggleBlockHighlight(clientId, false);

        case 6:
        case "end":
          return _context20.stop();
      }
    }
  }, _marked20);
}
/**
 * Returns an action object that sets whether the block has controlled innerblocks.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */


function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks: hasControlledInnerBlocks,
    clientId: clientId
  };
}
//# sourceMappingURL=actions.js.map