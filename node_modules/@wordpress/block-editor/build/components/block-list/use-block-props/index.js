"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBlockProps = useBlockProps;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classnames = _interopRequireDefault(require("classnames"));

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _useMovingAnimation = _interopRequireDefault(require("../../use-moving-animation"));

var _block = require("../block");

var _useFocusFirstElement = require("./use-focus-first-element");

var _useIsHovered = require("./use-is-hovered");

var _useBlockClassNames = require("./use-block-class-names");

var _useBlockDefaultClassName = require("./use-block-default-class-name");

var _useBlockCustomClassName = require("./use-block-custom-class-name");

var _useBlockMovingModeClassNames = require("./use-block-moving-mode-class-names");

var _useEventHandlers = require("./use-event-handlers");

var _useNavModeExit = require("./use-nav-mode-exit");

var _useBlockNodes = require("./use-block-nodes");

var _store = require("../../../store");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */
var BLOCK_ANIMATION_THRESHOLD = 200;
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props   Optional. Props to pass to the element. Must contain
 *                          the ref if one is defined.
 * @param {Object}  options Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

function useBlockProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      __unstableIsHtml = _ref.__unstableIsHtml;

  var _useContext = (0, _element.useContext)(_block.BlockListBlockContext),
      clientId = _useContext.clientId,
      index = _useContext.index,
      className = _useContext.className,
      _useContext$wrapperPr = _useContext.wrapperProps,
      wrapperProps = _useContext$wrapperPr === void 0 ? {} : _useContext$wrapperPr;

  var _useSelect = (0, _data.useSelect)(function (select) {
    var _select = select(_store.store),
        getBlockMode = _select.getBlockMode,
        getBlockName = _select.getBlockName,
        isTyping = _select.isTyping,
        getGlobalBlockCount = _select.getGlobalBlockCount,
        isBlockSelected = _select.isBlockSelected,
        isBlockMultiSelected = _select.isBlockMultiSelected,
        isAncestorMultiSelected = _select.isAncestorMultiSelected,
        isFirstMultiSelectedBlock = _select.isFirstMultiSelectedBlock;

    var isSelected = isBlockSelected(clientId);
    var isPartOfMultiSelection = isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    var blockName = getBlockName(clientId);
    return {
      mode: getBlockMode(clientId),
      name: blockName,
      blockTitle: (0, _blocks.getBlockType)(blockName).title,
      isPartOfSelection: isSelected || isPartOfMultiSelection,
      adjustScrolling: isSelected || isFirstMultiSelectedBlock(clientId),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD
    };
  }, [clientId]),
      mode = _useSelect.mode,
      name = _useSelect.name,
      blockTitle = _useSelect.blockTitle,
      isPartOfSelection = _useSelect.isPartOfSelection,
      adjustScrolling = _useSelect.adjustScrolling,
      enableAnimation = _useSelect.enableAnimation; // translators: %s: Type of block (i.e. Text, Image etc)


  var blockLabel = (0, _i18n.sprintf)((0, _i18n.__)('Block: %s'), blockTitle);
  var htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  var mergedRefs = (0, _compose.useMergeRefs)([props.ref, (0, _useFocusFirstElement.useFocusFirstElement)(clientId), (0, _useBlockNodes.useBlockNodes)(clientId), (0, _useEventHandlers.useEventHandlers)(clientId), (0, _useNavModeExit.useNavModeExit)(clientId), (0, _useIsHovered.useIsHovered)(), (0, _useMovingAnimation.default)({
    isSelected: isPartOfSelection,
    adjustScrolling: adjustScrolling,
    enableAnimation: enableAnimation,
    triggerAnimationOnChange: index
  })]);
  return _objectSpread(_objectSpread(_objectSpread({}, wrapperProps), props), {}, {
    ref: mergedRefs,
    id: "block-".concat(clientId).concat(htmlSuffix),
    tabIndex: 0,
    role: 'group',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    className: (0, _classnames.default)(className, props.className, wrapperProps.className, (0, _useBlockClassNames.useBlockClassNames)(clientId), (0, _useBlockDefaultClassName.useBlockDefaultClassName)(clientId), (0, _useBlockCustomClassName.useBlockCustomClassName)(clientId), (0, _useBlockMovingModeClassNames.useBlockMovingModeClassNames)(clientId)),
    style: _objectSpread(_objectSpread({}, wrapperProps.style), props.style)
  });
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */


useBlockProps.save = _blocks.__unstableGetBlockProps;
//# sourceMappingURL=index.js.map