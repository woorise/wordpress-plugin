"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventHandlers = useEventHandlers;

var _element = require("@wordpress/element");

var _dom = require("@wordpress/dom");

var _keycodes = require("@wordpress/keycodes");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _dom2 = require("../../../utils/dom");

var _writingFlow = require("../../writing-flow");

var _store = require("../../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Adds block behaviour:
 *   - Selects the block if it receives focus.
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Initiates selection start for multi-selection.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */
function useEventHandlers(clientId) {
  var onSelectionStart = (0, _element.useContext)(_writingFlow.SelectionStart);

  var _useSelect = (0, _data.useSelect)(function (select) {
    var _select = select(_store.store),
        isBlockSelected = _select.isBlockSelected,
        getBlockRootClientId = _select.getBlockRootClientId,
        getBlockIndex = _select.getBlockIndex;

    return {
      isSelected: isBlockSelected(clientId),
      rootClientId: getBlockRootClientId(clientId),
      index: getBlockIndex(clientId)
    };
  }, [clientId]),
      isSelected = _useSelect.isSelected,
      rootClientId = _useSelect.rootClientId,
      index = _useSelect.index;

  var _useDispatch = (0, _data.useDispatch)(_store.store),
      insertDefaultBlock = _useDispatch.insertDefaultBlock,
      removeBlock = _useDispatch.removeBlock,
      selectBlock = _useDispatch.selectBlock;

  return (0, _compose.useRefEffect)(function (node) {
    if (!isSelected) {
      /**
       * Marks the block as selected when focused and not already
       * selected. This specifically handles the case where block does not
       * set focus on its own (via `setFocus`), typically if there is no
       * focusable input in the block.
       *
       * @param {FocusEvent} event Focus event.
       */
      function onFocus(event) {
        // If an inner block is focussed, that block is resposible for
        // setting the selected block.
        if (!(0, _dom2.isInsideRootBlock)(node, event.target)) {
          return;
        }

        selectBlock(clientId);
      }

      node.addEventListener('focusin', onFocus);
      return function () {
        node.removeEventListener('focusin', onFocus);
      };
    }
    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */


    function onKeyDown(event) {
      var keyCode = event.keyCode,
          target = event.target;

      if (keyCode !== _keycodes.ENTER && keyCode !== _keycodes.BACKSPACE && keyCode !== _keycodes.DELETE) {
        return;
      }

      if (target !== node || (0, _dom.isTextField)(target)) {
        return;
      }

      event.preventDefault();

      if (keyCode === _keycodes.ENTER) {
        insertDefaultBlock({}, rootClientId, index + 1);
      } else {
        removeBlock(clientId);
      }
    }

    function onMouseLeave(_ref) {
      var buttons = _ref.buttons;

      // The primary button must be pressed to initiate selection.
      // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
      if (buttons === 1) {
        onSelectionStart(clientId);
      }
    }
    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */


    function onDragStart(event) {
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('mouseleave', onMouseLeave);
    node.addEventListener('dragstart', onDragStart);
    return function () {
      node.removeEventListener('mouseleave', onMouseLeave);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [isSelected, rootClientId, index, onSelectionStart, insertDefaultBlock, removeBlock, selectBlock]);
}
//# sourceMappingURL=use-event-handlers.js.map