"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _icons = require("@wordpress/icons");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _keycodes = require("@wordpress/keycodes");

var _blocks = require("@wordpress/blocks");

var _a11y = require("@wordpress/a11y");

var _dom = require("@wordpress/dom");

var _i18n = require("@wordpress/i18n");

var _blockTitle = _interopRequireDefault(require("../block-title"));

var _blockIcon = _interopRequireDefault(require("../block-icon"));

var _store = require("../../store");

var _blockDraggable = _interopRequireDefault(require("../block-draggable"));

var _useBlockDisplayInformation = _interopRequireDefault(require("../use-block-display-information"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Returns true if the user is using windows.
 *
 * @return {boolean} Whether the user is using Windows.
 */
function isWindows() {
  return window.navigator.platform.indexOf('Win') > -1;
}

function selector(select) {
  var _select = select(_store.store),
      getSelectedBlockClientId = _select.getSelectedBlockClientId,
      getMultiSelectedBlocksEndClientId = _select.getMultiSelectedBlocksEndClientId,
      getPreviousBlockClientId = _select.getPreviousBlockClientId,
      getNextBlockClientId = _select.getNextBlockClientId,
      hasBlockMovingClientId = _select.hasBlockMovingClientId,
      getBlockIndex = _select.getBlockIndex,
      getBlockRootClientId = _select.getBlockRootClientId,
      getClientIdsOfDescendants = _select.getClientIdsOfDescendants,
      canInsertBlockType = _select.canInsertBlockType,
      getBlockName = _select.getBlockName;

  var selectedBlockClientId = getSelectedBlockClientId();
  var selectionEndClientId = getMultiSelectedBlocksEndClientId();
  return {
    selectedBlockClientId: selectedBlockClientId,
    selectionBeforeEndClientId: getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId),
    selectionAfterEndClientId: getNextBlockClientId(selectionEndClientId || selectedBlockClientId),
    hasBlockMovingClientId: hasBlockMovingClientId,
    getBlockIndex: getBlockIndex,
    getBlockRootClientId: getBlockRootClientId,
    getClientIdsOfDescendants: getClientIdsOfDescendants,
    canInsertBlockType: canInsertBlockType,
    getBlockName: getBlockName
  };
}
/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {WPComponent} The component to be rendered.
 */


function BlockSelectionButton(_ref) {
  var clientId = _ref.clientId,
      rootClientId = _ref.rootClientId,
      blockElement = _ref.blockElement;
  var blockInformation = (0, _useBlockDisplayInformation.default)(clientId);
  var selected = (0, _data.useSelect)(function (select) {
    var _getBlockListSettings;

    var _select2 = select(_store.store),
        __unstableGetBlockWithoutInnerBlocks = _select2.__unstableGetBlockWithoutInnerBlocks,
        getBlockIndex = _select2.getBlockIndex,
        hasBlockMovingClientId = _select2.hasBlockMovingClientId,
        getBlockListSettings = _select2.getBlockListSettings;

    var index = getBlockIndex(clientId, rootClientId);

    var _unstableGetBlockWit = __unstableGetBlockWithoutInnerBlocks(clientId),
        name = _unstableGetBlockWit.name,
        attributes = _unstableGetBlockWit.attributes;

    var blockMovingMode = hasBlockMovingClientId();
    return {
      index: index,
      name: name,
      attributes: attributes,
      blockMovingMode: blockMovingMode,
      orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [clientId, rootClientId]);
  var index = selected.index,
      name = selected.name,
      attributes = selected.attributes,
      blockMovingMode = selected.blockMovingMode,
      orientation = selected.orientation;

  var _useDispatch = (0, _data.useDispatch)(_store.store),
      setNavigationMode = _useDispatch.setNavigationMode,
      removeBlock = _useDispatch.removeBlock;

  var ref = (0, _element.useRef)(); // Focus the breadcrumb in navigation mode.

  (0, _element.useEffect)(function () {
    ref.current.focus(); // NVDA on windows suffers from a bug where focus changes are not announced properly
    // See WordPress/gutenberg#24121 and nvaccess/nvda#5825 for more details
    // To solve it we announce the focus change manually.

    if (isWindows()) {
      (0, _a11y.speak)(label);
    }
  }, []);

  var _useSelect = (0, _data.useSelect)(selector, []),
      selectedBlockClientId = _useSelect.selectedBlockClientId,
      selectionBeforeEndClientId = _useSelect.selectionBeforeEndClientId,
      selectionAfterEndClientId = _useSelect.selectionAfterEndClientId,
      hasBlockMovingClientId = _useSelect.hasBlockMovingClientId,
      getBlockIndex = _useSelect.getBlockIndex,
      getBlockRootClientId = _useSelect.getBlockRootClientId,
      getClientIdsOfDescendants = _useSelect.getClientIdsOfDescendants;

  var _useDispatch2 = (0, _data.useDispatch)(_store.store),
      selectBlock = _useDispatch2.selectBlock,
      clearSelectedBlock = _useDispatch2.clearSelectedBlock,
      setBlockMovingClientId = _useDispatch2.setBlockMovingClientId,
      moveBlockToPosition = _useDispatch2.moveBlockToPosition;

  function onKeyDown(event) {
    var keyCode = event.keyCode;
    var isUp = keyCode === _keycodes.UP;
    var isDown = keyCode === _keycodes.DOWN;
    var isLeft = keyCode === _keycodes.LEFT;
    var isRight = keyCode === _keycodes.RIGHT;
    var isTab = keyCode === _keycodes.TAB;
    var isEscape = keyCode === _keycodes.ESCAPE;
    var isEnter = keyCode === _keycodes.ENTER;
    var isSpace = keyCode === _keycodes.SPACE;
    var isShift = event.shiftKey;

    if (keyCode === _keycodes.BACKSPACE || keyCode === _keycodes.DELETE) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }

    var navigateUp = isTab && isShift || isUp;
    var navigateDown = isTab && !isShift || isDown; // Move out of current nesting level (no effect if at root level).

    var navigateOut = isLeft; // Move into next nesting level (no effect if the current block has no innerBlocks).

    var navigateIn = isRight;
    var focusedBlockUid;

    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;

      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;

      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }

    var startingBlockClientId = hasBlockMovingClientId();

    if (isEscape && startingBlockClientId) {
      setBlockMovingClientId(null);
    }

    if ((isEnter || isSpace) && startingBlockClientId) {
      var sourceRoot = getBlockRootClientId(startingBlockClientId);
      var destRoot = getBlockRootClientId(selectedBlockClientId);
      var sourceBlockIndex = getBlockIndex(startingBlockClientId, sourceRoot);
      var destinationBlockIndex = getBlockIndex(selectedBlockClientId, destRoot);

      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }

      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }

    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        var nextTabbable;

        if (navigateDown) {
          nextTabbable = _dom.focus.tabbable.findNext(blockElement);

          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = _dom.focus.tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = _dom.focus.tabbable.findPrevious(blockElement);
        }

        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }

  var blockType = (0, _blocks.getBlockType)(name);
  var label = (0, _blocks.__experimentalGetAccessibleBlockLabel)(blockType, attributes, index + 1, orientation);
  var classNames = (0, _classnames.default)('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });
  var dragHandleLabel = (0, _i18n.__)('Drag');
  return (0, _element.createElement)("div", {
    className: classNames
  }, (0, _element.createElement)(_components.Flex, {
    justify: "center",
    className: "block-editor-block-list__block-selection-button__content"
  }, (0, _element.createElement)(_components.FlexItem, null, (0, _element.createElement)(_blockIcon.default, {
    icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
    showColors: true
  })), (0, _element.createElement)(_components.FlexItem, null, (0, _element.createElement)(_blockDraggable.default, {
    clientIds: [clientId]
  }, function (draggableProps) {
    return (0, _element.createElement)(_components.Button, (0, _extends2.default)({
      icon: _icons.dragHandle,
      className: "block-selection-button_drag-handle",
      "aria-hidden": "true",
      label: dragHandleLabel // Should not be able to tab to drag handle as this
      // button can only be used with a pointer device.
      ,
      tabIndex: "-1"
    }, draggableProps));
  })), (0, _element.createElement)(_components.FlexItem, null, (0, _element.createElement)(_components.Button, {
    ref: ref,
    onClick: function onClick() {
      return setNavigationMode(false);
    },
    onKeyDown: onKeyDown,
    label: label,
    className: "block-selection-button_select-button"
  }, (0, _element.createElement)(_blockTitle.default, {
    clientId: clientId
  })))));
}

var _default = BlockSelectionButton;
exports.default = _default;
//# sourceMappingURL=block-selection-button.js.map