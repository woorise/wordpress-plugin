"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useInsertionPoint;

var _element = require("@wordpress/element");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classnames = _interopRequireDefault(require("classnames"));

var _data = require("@wordpress/data");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _inserter = _interopRequireDefault(require("../inserter"));

var _dom = require("../../utils/dom");

var _store = require("../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function InsertionPointInserter(_ref) {
  var clientId = _ref.clientId,
      rootClientId = _ref.rootClientId,
      setIsInserterForced = _ref.setIsInserterForced;
  return (0, _element.createElement)("div", {
    className: (0, _classnames.default)('block-editor-block-list__insertion-point-inserter')
  }, (0, _element.createElement)(_inserter.default, {
    position: "bottom center",
    clientId: clientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    onToggle: setIsInserterForced,
    onSelectOrClose: function onSelectOrClose() {
      return setIsInserterForced(false);
    }
  }));
}

function InsertionPointPopover(_ref2) {
  var clientId = _ref2.clientId,
      selectedRootClientId = _ref2.selectedRootClientId,
      isInserterShown = _ref2.isInserterShown,
      isInserterForced = _ref2.isInserterForced,
      setIsInserterForced = _ref2.setIsInserterForced,
      containerRef = _ref2.containerRef,
      showInsertionPoint = _ref2.showInsertionPoint;

  var _useDispatch = (0, _data.useDispatch)(_store.store),
      selectBlock = _useDispatch.selectBlock;

  var ref = (0, _element.useRef)();

  var _useSelect = (0, _data.useSelect)(function (select) {
    var _getBlockListSettings2;

    var _select = select(_store.store),
        getBlockOrder = _select.getBlockOrder,
        getBlockRootClientId = _select.getBlockRootClientId,
        getBlockListSettings = _select.getBlockListSettings,
        getMultiSelectedBlockClientIds = _select.getMultiSelectedBlockClientIds,
        getSelectedBlockClientId = _select.getSelectedBlockClientId,
        hasMultiSelection = _select.hasMultiSelection,
        getSettings = _select.getSettings;

    var ownerDocument = containerRef.current.ownerDocument;
    var targetRootClientId = clientId ? getBlockRootClientId(clientId) : selectedRootClientId;
    var blockOrder = getBlockOrder(targetRootClientId);

    if (!blockOrder.length) {
      return {};
    }

    var previous = clientId ? clientId : blockOrder[blockOrder.length - 1];
    var isLast = previous === blockOrder[blockOrder.length - 1];
    var next = isLast ? null : blockOrder[blockOrder.indexOf(previous) + 1];

    var _getSettings = getSettings(),
        hasReducedUI = _getSettings.hasReducedUI;

    var multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
    var selectedBlockClientId = getSelectedBlockClientId();
    var blockOrientation = ((_getBlockListSettings2 = getBlockListSettings(targetRootClientId)) === null || _getBlockListSettings2 === void 0 ? void 0 : _getBlockListSettings2.orientation) || 'vertical';
    return {
      previousElement: (0, _dom.getBlockDOMNode)(previous, ownerDocument),
      nextElement: (0, _dom.getBlockDOMNode)(next, ownerDocument),
      nextClientId: next,
      isHidden: hasReducedUI || (hasMultiSelection() ? next && multiSelectedBlockClientIds.includes(next) : next && blockOrientation === 'vertical' && next === selectedBlockClientId),
      orientation: blockOrientation,
      rootClientId: targetRootClientId
    };
  }, [clientId, selectedRootClientId]),
      previousElement = _useSelect.previousElement,
      nextElement = _useSelect.nextElement,
      orientation = _useSelect.orientation,
      isHidden = _useSelect.isHidden,
      nextClientId = _useSelect.nextClientId,
      rootClientId = _useSelect.rootClientId;

  var style = (0, _element.useMemo)(function () {
    if (!previousElement) {
      return {};
    }

    var previousRect = previousElement.getBoundingClientRect();
    var nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (orientation === 'vertical') {
      return {
        width: previousElement.offsetWidth,
        height: nextRect ? nextRect.top - previousRect.bottom : 0
      };
    }

    var width = 0;

    if (nextElement) {
      width = (0, _i18n.isRTL)() ? previousRect.left - nextRect.right : nextRect.left - previousRect.right;
    }

    return {
      width: width,
      height: previousElement.offsetHeight
    };
  }, [previousElement, nextElement]);
  var getAnchorRect = (0, _element.useCallback)(function () {
    var previousRect = previousElement.getBoundingClientRect();
    var nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (orientation === 'vertical') {
      return {
        top: previousRect.bottom,
        left: previousRect.left,
        right: previousRect.right,
        bottom: nextRect ? nextRect.top : previousRect.bottom
      };
    }

    if ((0, _i18n.isRTL)()) {
      return {
        top: previousRect.top,
        left: nextRect ? nextRect.right : previousRect.left,
        right: previousRect.left,
        bottom: previousRect.bottom
      };
    }

    return {
      top: previousRect.top,
      left: previousRect.right,
      right: nextRect ? nextRect.left : previousRect.right,
      bottom: previousRect.bottom
    };
  }, [previousElement, nextElement]);

  if (!previousElement) {
    return null;
  }

  var className = (0, _classnames.default)('block-editor-block-list__insertion-point', 'is-' + orientation);

  function onClick(event) {
    if (event.target === ref.current && nextClientId) {
      selectBlock(nextClientId, -1);
    }
  }

  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      setIsInserterForced(true);
    }
  } // Only show the inserter when there's a `nextElement` (a block after the
  // insertion point). At the end of the block list the trailing appender
  // should serve the purpose of inserting blocks.


  var showInsertionPointInserter = !isHidden && nextElement && (isInserterShown || isInserterForced); // Show the indicator if the insertion point inserter is visible, or if
  // the `showInsertionPoint` state is `true`. The latter is generally true
  // when hovering blocks for insertion in the block library.

  var showInsertionPointIndicator = showInsertionPointInserter || !isHidden && showInsertionPoint;
  /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
  // While ideally it would be enough to capture the
  // bubbling focus event from the Inserter, due to the
  // characteristics of click focusing of `button`s in
  // Firefox and Safari, it is not reliable.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus

  return (0, _element.createElement)(_components.Popover, {
    noArrow: true,
    animate: false,
    getAnchorRect: getAnchorRect,
    focusOnMount: false,
    className: "block-editor-block-list__insertion-point-popover",
    __unstableSlotName: "block-toolbar"
  }, (0, _element.createElement)("div", {
    ref: ref,
    tabIndex: -1,
    onClick: onClick,
    onFocus: onFocus,
    className: className,
    style: style
  }, showInsertionPointIndicator && (0, _element.createElement)("div", {
    className: "block-editor-block-list__insertion-point-indicator"
  }), showInsertionPointInserter && (0, _element.createElement)(InsertionPointInserter, {
    rootClientId: rootClientId,
    clientId: nextClientId,
    setIsInserterForced: setIsInserterForced
  })));
  /* eslint-enable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
}

function useInsertionPoint(ref) {
  var _useState = (0, _element.useState)(false),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      isInserterShown = _useState2[0],
      setIsInserterShown = _useState2[1];

  var _useState3 = (0, _element.useState)(false),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isInserterForced = _useState4[0],
      _setIsInserterForced = _useState4[1];

  var _useState5 = (0, _element.useState)(null),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      inserterClientId = _useState6[0],
      setInserterClientId = _useState6[1];

  var _useSelect2 = (0, _data.useSelect)(function (select) {
    var _select2 = select(_store.store),
        _isMultiSelecting = _select2.isMultiSelecting,
        isBlockInsertionPointVisible = _select2.isBlockInsertionPointVisible,
        getBlockInsertionPoint = _select2.getBlockInsertionPoint,
        getBlockOrder = _select2.getBlockOrder,
        _getBlockListSettings = _select2.getBlockListSettings;

    var insertionPoint = getBlockInsertionPoint();
    var order = getBlockOrder(insertionPoint.rootClientId);
    return {
      getBlockListSettings: _getBlockListSettings,
      isMultiSelecting: _isMultiSelecting(),
      isInserterVisible: isBlockInsertionPointVisible(),
      selectedClientId: order[insertionPoint.index - 1],
      selectedRootClientId: insertionPoint.rootClientId
    };
  }, []),
      isMultiSelecting = _useSelect2.isMultiSelecting,
      isInserterVisible = _useSelect2.isInserterVisible,
      selectedClientId = _useSelect2.selectedClientId,
      selectedRootClientId = _useSelect2.selectedRootClientId,
      getBlockListSettings = _useSelect2.getBlockListSettings;

  var onMouseMove = (0, _element.useCallback)(function (event) {
    var _getBlockListSettings3;

    if (!event.target.classList.contains('block-editor-block-list__layout')) {
      if (isInserterShown) {
        setIsInserterShown(false);
      }

      return;
    }

    var rootClientId;

    if (!event.target.classList.contains('is-root-container')) {
      var blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
      rootClientId = blockElement.getAttribute('data-block');
    }

    var orientation = ((_getBlockListSettings3 = getBlockListSettings(rootClientId)) === null || _getBlockListSettings3 === void 0 ? void 0 : _getBlockListSettings3.orientation) || 'vertical';
    var rect = event.target.getBoundingClientRect();
    var offsetTop = event.clientY - rect.top;
    var offsetLeft = event.clientX - rect.left;
    var children = Array.from(event.target.children);
    var nextElement = children.find(function (blockEl) {
      return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockEl.offsetTop > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && blockEl.offsetLeft > offsetLeft;
    });
    var element = nextElement ? children[children.indexOf(nextElement) - 1] : children[children.length - 1];

    if (!element) {
      return;
    } // The block may be in an alignment wrapper, so check the first direct
    // child if the element has no ID.


    if (!element.id) {
      element = element.firstElementChild;

      if (!element) {
        return;
      }
    }

    var clientId = element.id.slice('block-'.length);

    if (!clientId) {
      return;
    }

    var elementRect = element.getBoundingClientRect();

    if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
      if (isInserterShown) {
        setIsInserterShown(false);
      }

      return;
    }

    setIsInserterShown(true);
    setInserterClientId(clientId);
  }, [isInserterShown, setIsInserterShown, setInserterClientId]);
  var enableMouseMove = !isInserterForced && !isMultiSelecting;
  (0, _element.useEffect)(function () {
    if (!enableMouseMove) {
      return;
    }

    ref.current.addEventListener('mousemove', onMouseMove);
    return function () {
      ref.current.removeEventListener('mousemove', onMouseMove);
    };
  }, [enableMouseMove, onMouseMove]);
  var isVisible = isInserterShown || isInserterForced || isInserterVisible;
  return !isMultiSelecting && isVisible && (0, _element.createElement)(InsertionPointPopover, {
    clientId: isInserterVisible ? selectedClientId : inserterClientId,
    selectedRootClientId: selectedRootClientId,
    isInserterShown: isInserterShown,
    isInserterForced: isInserterForced,
    setIsInserterForced: function setIsInserterForced(value) {
      _setIsInserterForced(value);

      if (!value) {
        setIsInserterShown(value);
      }
    },
    containerRef: ref,
    showInsertionPoint: isInserterVisible
  });
}
//# sourceMappingURL=insertion-point.js.map