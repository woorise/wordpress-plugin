/**
 * External dependencies
 */
import { castArray } from 'lodash';
/**
 * WordPress dependencies
 */

import { useDispatch, useSelect } from '@wordpress/data';
import { isUnmodifiedDefaultBlock } from '@wordpress/blocks';
import { _n, sprintf } from '@wordpress/i18n';
import { speak } from '@wordpress/a11y';
import { useCallback } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { store as blockEditorStore } from '../../../store';
/**
 * @typedef WPInserterConfig
 *
 * @property {string=}   rootClientId        If set, insertion will be into the
 *                                           block with this ID.
 * @property {number=}   insertionIndex      If set, insertion will be into this
 *                                           explicit position.
 * @property {string=}   clientId            If set, insertion will be after the
 *                                           block with this ID.
 * @property {boolean=}  isAppender          Whether the inserter is an appender
 *                                           or not.
 * @property {Function=} onSelect            Called after insertion.
 */

/**
 * Returns the insertion point state given the inserter config.
 *
 * @param {WPInserterConfig} config Inserter Config.
 * @return {Array} Insertion Point State (rootClientID, onInsertBlocks and onToggle).
 */

function useInsertionPoint(_ref) {
  var rootClientId = _ref.rootClientId,
      insertionIndex = _ref.insertionIndex,
      clientId = _ref.clientId,
      isAppender = _ref.isAppender,
      onSelect = _ref.onSelect,
      _ref$shouldFocusBlock = _ref.shouldFocusBlock,
      shouldFocusBlock = _ref$shouldFocusBlock === void 0 ? true : _ref$shouldFocusBlock;

  var _useSelect = useSelect(function (select) {
    var _select = select(blockEditorStore),
        _getSelectedBlock = _select.getSelectedBlock,
        getBlockIndex = _select.getBlockIndex,
        getBlockOrder = _select.getBlockOrder,
        getBlockInsertionPoint = _select.getBlockInsertionPoint;

    var _destinationRootClientId, _destinationIndex;

    if (rootClientId || insertionIndex || clientId || isAppender) {
      // If any of these arguments are set, we're in "manual mode"
      // meaning the insertion point is set by the caller.
      _destinationRootClientId = rootClientId;

      if (insertionIndex) {
        // Insert into a specific index.
        _destinationIndex = insertionIndex;
      } else if (clientId) {
        // Insert after a specific client ID.
        _destinationIndex = getBlockIndex(clientId, _destinationRootClientId);
      } else {
        // Insert at the end of the list.
        _destinationIndex = getBlockOrder(_destinationRootClientId).length;
      }
    } else {
      // Otherwise, we're in "auto mode" where the insertion point is
      // decided by getBlockInsertionPoint().
      var insertionPoint = getBlockInsertionPoint();
      _destinationRootClientId = insertionPoint.rootClientId;
      _destinationIndex = insertionPoint.index;
    }

    return {
      getSelectedBlock: _getSelectedBlock,
      destinationRootClientId: _destinationRootClientId,
      destinationIndex: _destinationIndex
    };
  }, [rootClientId, insertionIndex, clientId, isAppender]),
      destinationRootClientId = _useSelect.destinationRootClientId,
      destinationIndex = _useSelect.destinationIndex,
      getSelectedBlock = _useSelect.getSelectedBlock;

  var _useDispatch = useDispatch(blockEditorStore),
      replaceBlocks = _useDispatch.replaceBlocks,
      insertBlocks = _useDispatch.insertBlocks,
      showInsertionPoint = _useDispatch.showInsertionPoint,
      hideInsertionPoint = _useDispatch.hideInsertionPoint;

  var onInsertBlocks = useCallback(function (blocks, meta) {
    var shouldForceFocusBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var selectedBlock = getSelectedBlock();

    if (!isAppender && selectedBlock && isUnmodifiedDefaultBlock(selectedBlock)) {
      replaceBlocks(selectedBlock.clientId, blocks, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    } else {
      insertBlocks(blocks, destinationIndex, destinationRootClientId, true, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    }

    var message = sprintf( // translators: %d: the name of the block that has been added
    _n('%d block added.', '%d blocks added.', castArray(blocks).length), castArray(blocks).length);
    speak(message);

    if (onSelect) {
      onSelect();
    }
  }, [isAppender, getSelectedBlock, replaceBlocks, insertBlocks, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock]);
  var onToggleInsertionPoint = useCallback(function (show) {
    if (show) {
      showInsertionPoint(destinationRootClientId, destinationIndex);
    } else {
      hideInsertionPoint();
    }
  }, [showInsertionPoint, hideInsertionPoint, destinationRootClientId, destinationIndex]);
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}

export default useInsertionPoint;
//# sourceMappingURL=use-insertion-point.js.map