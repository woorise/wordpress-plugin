import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { createElement } from "@wordpress/element";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * WordPress dependencies
 */
import { useState, createPortal, useCallback, forwardRef } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
import { useMergeRefs } from '@wordpress/compose';
var BODY_CLASS_NAME = 'editor-styles-wrapper';
var BLOCK_PREFIX = 'wp-block';
/**
 * Clones stylesheets targetting the editor canvas to the given document. A
 * stylesheet is considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 *
 * @param {Document} doc The document to append cloned stylesheets to.
 */

function styleSheetsCompat(doc) {
  // Search the document for stylesheets targetting the editor canvas.
  Array.from(document.styleSheets).forEach(function (styleSheet) {
    try {
      // May fail for external styles.
      // eslint-disable-next-line no-unused-expressions
      styleSheet.cssRules;
    } catch (e) {
      return;
    }

    var ownerNode = styleSheet.ownerNode,
        cssRules = styleSheet.cssRules;

    if (!cssRules) {
      return;
    }

    var isMatch = Array.from(cssRules).find(function (_ref) {
      var selectorText = _ref.selectorText;
      return selectorText && (selectorText.includes(".".concat(BODY_CLASS_NAME)) || selectorText.includes(".".concat(BLOCK_PREFIX)));
    });

    if (isMatch && !doc.getElementById(ownerNode.id)) {
      doc.head.appendChild(ownerNode.cloneNode(true));
    }
  });
}
/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} doc Document to attach listeners to.
 */


function bubbleEvents(doc) {
  var defaultView = doc.defaultView;
  var frameElement = defaultView.frameElement;

  function bubbleEvent(event) {
    var prototype = Object.getPrototypeOf(event);
    var constructorName = prototype.constructor.name;
    var Constructor = window[constructorName];
    var init = {};

    for (var key in event) {
      init[key] = event[key];
    }

    if (event instanceof defaultView.MouseEvent) {
      var rect = frameElement.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }

    var newEvent = new Constructor(event.type, init);
    var cancelled = !frameElement.dispatchEvent(newEvent);

    if (cancelled) {
      event.preventDefault();
    }
  }

  var eventTypes = ['keydown', 'keypress', 'dragover'];

  for (var _i = 0, _eventTypes = eventTypes; _i < _eventTypes.length; _i++) {
    var name = _eventTypes[_i];
    doc.addEventListener(name, bubbleEvent);
  }
}
/**
 * Sets the document direction.
 *
 * Sets the `editor-styles-wrapper` class name on the body.
 *
 * Copies the `admin-color-*` class name to the body so that the admin color
 * scheme applies to components in the iframe.
 *
 * @param {Document} doc Document to add class name to.
 */


function setBodyClassName(doc) {
  doc.dir = document.dir;
  doc.body.className = BODY_CLASS_NAME;

  var _iterator = _createForOfIteratorHelper(document.body.classList),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var name = _step.value;

      if (name.startsWith('admin-color-')) {
        doc.body.classList.add(name);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/**
 * Sets the document head and default styles.
 *
 * @param {Document} doc  Document to set the head for.
 * @param {string}   head HTML to set as the head.
 */


function setHead(doc, head) {
  doc.head.innerHTML = // Body margin must be overridable by themes.
  '<style>body{margin:0}</style>' + head;
}

function Iframe(_ref2, ref) {
  var contentRef = _ref2.contentRef,
      children = _ref2.children,
      head = _ref2.head,
      headHTML = _ref2.headHTML,
      props = _objectWithoutProperties(_ref2, ["contentRef", "children", "head", "headHTML"]);

  var _useState = useState(),
      _useState2 = _slicedToArray(_useState, 2),
      iframeDocument = _useState2[0],
      setIframeDocument = _useState2[1];

  var setRef = useCallback(function (node) {
    if (!node) {
      return;
    }

    function setDocumentIfReady() {
      var contentDocument = node.contentDocument;
      var readyState = contentDocument.readyState,
          body = contentDocument.body;

      if (readyState !== 'interactive' && readyState !== 'complete') {
        return false;
      }

      if (typeof contentRef === 'function') {
        contentRef(body);
      } else if (contentRef) {
        contentRef.current = body;
      }

      setHead(contentDocument, headHTML);
      setBodyClassName(contentDocument);
      styleSheetsCompat(contentDocument);
      bubbleEvents(contentDocument);
      setBodyClassName(contentDocument);
      setIframeDocument(contentDocument);
      return true;
    }

    if (setDocumentIfReady()) {
      return;
    } // Document is not immediately loaded in Firefox.


    node.addEventListener('load', function () {
      setDocumentIfReady();
    });
  }, []);
  return createElement("iframe", _extends({}, props, {
    ref: useMergeRefs([ref, setRef]),
    tabIndex: "0",
    title: __('Editor canvas'),
    name: "editor-canvas"
  }), iframeDocument && createPortal(children, iframeDocument.body), iframeDocument && createPortal(head, iframeDocument.head));
}

export default forwardRef(Iframe);
//# sourceMappingURL=index.js.map