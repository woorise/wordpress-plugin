import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { dragHandle } from '@wordpress/icons';
import { Button, Flex, FlexItem } from '@wordpress/components';
import { useSelect, useDispatch } from '@wordpress/data';
import { useEffect, useRef } from '@wordpress/element';
import { BACKSPACE, DELETE, UP, DOWN, LEFT, RIGHT, TAB, ESCAPE, ENTER, SPACE } from '@wordpress/keycodes';
import { getBlockType, __experimentalGetAccessibleBlockLabel as getAccessibleBlockLabel } from '@wordpress/blocks';
import { speak } from '@wordpress/a11y';
import { focus } from '@wordpress/dom';
import { __ } from '@wordpress/i18n';
/**
 * Internal dependencies
 */

import BlockTitle from '../block-title';
import BlockIcon from '../block-icon';
import { store as blockEditorStore } from '../../store';
import BlockDraggable from '../block-draggable';
import useBlockDisplayInformation from '../use-block-display-information';
/**
 * Returns true if the user is using windows.
 *
 * @return {boolean} Whether the user is using Windows.
 */

function isWindows() {
  return window.navigator.platform.indexOf('Win') > -1;
}

function selector(select) {
  var _select = select(blockEditorStore),
      getSelectedBlockClientId = _select.getSelectedBlockClientId,
      getMultiSelectedBlocksEndClientId = _select.getMultiSelectedBlocksEndClientId,
      getPreviousBlockClientId = _select.getPreviousBlockClientId,
      getNextBlockClientId = _select.getNextBlockClientId,
      hasBlockMovingClientId = _select.hasBlockMovingClientId,
      getBlockIndex = _select.getBlockIndex,
      getBlockRootClientId = _select.getBlockRootClientId,
      getClientIdsOfDescendants = _select.getClientIdsOfDescendants,
      canInsertBlockType = _select.canInsertBlockType,
      getBlockName = _select.getBlockName;

  var selectedBlockClientId = getSelectedBlockClientId();
  var selectionEndClientId = getMultiSelectedBlocksEndClientId();
  return {
    selectedBlockClientId: selectedBlockClientId,
    selectionBeforeEndClientId: getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId),
    selectionAfterEndClientId: getNextBlockClientId(selectionEndClientId || selectedBlockClientId),
    hasBlockMovingClientId: hasBlockMovingClientId,
    getBlockIndex: getBlockIndex,
    getBlockRootClientId: getBlockRootClientId,
    getClientIdsOfDescendants: getClientIdsOfDescendants,
    canInsertBlockType: canInsertBlockType,
    getBlockName: getBlockName
  };
}
/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {WPComponent} The component to be rendered.
 */


function BlockSelectionButton(_ref) {
  var clientId = _ref.clientId,
      rootClientId = _ref.rootClientId,
      blockElement = _ref.blockElement;
  var blockInformation = useBlockDisplayInformation(clientId);
  var selected = useSelect(function (select) {
    var _getBlockListSettings;

    var _select2 = select(blockEditorStore),
        __unstableGetBlockWithoutInnerBlocks = _select2.__unstableGetBlockWithoutInnerBlocks,
        getBlockIndex = _select2.getBlockIndex,
        hasBlockMovingClientId = _select2.hasBlockMovingClientId,
        getBlockListSettings = _select2.getBlockListSettings;

    var index = getBlockIndex(clientId, rootClientId);

    var _unstableGetBlockWit = __unstableGetBlockWithoutInnerBlocks(clientId),
        name = _unstableGetBlockWit.name,
        attributes = _unstableGetBlockWit.attributes;

    var blockMovingMode = hasBlockMovingClientId();
    return {
      index: index,
      name: name,
      attributes: attributes,
      blockMovingMode: blockMovingMode,
      orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [clientId, rootClientId]);
  var index = selected.index,
      name = selected.name,
      attributes = selected.attributes,
      blockMovingMode = selected.blockMovingMode,
      orientation = selected.orientation;

  var _useDispatch = useDispatch(blockEditorStore),
      setNavigationMode = _useDispatch.setNavigationMode,
      removeBlock = _useDispatch.removeBlock;

  var ref = useRef(); // Focus the breadcrumb in navigation mode.

  useEffect(function () {
    ref.current.focus(); // NVDA on windows suffers from a bug where focus changes are not announced properly
    // See WordPress/gutenberg#24121 and nvaccess/nvda#5825 for more details
    // To solve it we announce the focus change manually.

    if (isWindows()) {
      speak(label);
    }
  }, []);

  var _useSelect = useSelect(selector, []),
      selectedBlockClientId = _useSelect.selectedBlockClientId,
      selectionBeforeEndClientId = _useSelect.selectionBeforeEndClientId,
      selectionAfterEndClientId = _useSelect.selectionAfterEndClientId,
      hasBlockMovingClientId = _useSelect.hasBlockMovingClientId,
      getBlockIndex = _useSelect.getBlockIndex,
      getBlockRootClientId = _useSelect.getBlockRootClientId,
      getClientIdsOfDescendants = _useSelect.getClientIdsOfDescendants;

  var _useDispatch2 = useDispatch(blockEditorStore),
      selectBlock = _useDispatch2.selectBlock,
      clearSelectedBlock = _useDispatch2.clearSelectedBlock,
      setBlockMovingClientId = _useDispatch2.setBlockMovingClientId,
      moveBlockToPosition = _useDispatch2.moveBlockToPosition;

  function onKeyDown(event) {
    var keyCode = event.keyCode;
    var isUp = keyCode === UP;
    var isDown = keyCode === DOWN;
    var isLeft = keyCode === LEFT;
    var isRight = keyCode === RIGHT;
    var isTab = keyCode === TAB;
    var isEscape = keyCode === ESCAPE;
    var isEnter = keyCode === ENTER;
    var isSpace = keyCode === SPACE;
    var isShift = event.shiftKey;

    if (keyCode === BACKSPACE || keyCode === DELETE) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }

    var navigateUp = isTab && isShift || isUp;
    var navigateDown = isTab && !isShift || isDown; // Move out of current nesting level (no effect if at root level).

    var navigateOut = isLeft; // Move into next nesting level (no effect if the current block has no innerBlocks).

    var navigateIn = isRight;
    var focusedBlockUid;

    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;

      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;

      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }

    var startingBlockClientId = hasBlockMovingClientId();

    if (isEscape && startingBlockClientId) {
      setBlockMovingClientId(null);
    }

    if ((isEnter || isSpace) && startingBlockClientId) {
      var sourceRoot = getBlockRootClientId(startingBlockClientId);
      var destRoot = getBlockRootClientId(selectedBlockClientId);
      var sourceBlockIndex = getBlockIndex(startingBlockClientId, sourceRoot);
      var destinationBlockIndex = getBlockIndex(selectedBlockClientId, destRoot);

      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }

      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }

    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        var nextTabbable;

        if (navigateDown) {
          nextTabbable = focus.tabbable.findNext(blockElement);

          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = focus.tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = focus.tabbable.findPrevious(blockElement);
        }

        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }

  var blockType = getBlockType(name);
  var label = getAccessibleBlockLabel(blockType, attributes, index + 1, orientation);
  var classNames = classnames('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });

  var dragHandleLabel = __('Drag');

  return createElement("div", {
    className: classNames
  }, createElement(Flex, {
    justify: "center",
    className: "block-editor-block-list__block-selection-button__content"
  }, createElement(FlexItem, null, createElement(BlockIcon, {
    icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
    showColors: true
  })), createElement(FlexItem, null, createElement(BlockDraggable, {
    clientIds: [clientId]
  }, function (draggableProps) {
    return createElement(Button, _extends({
      icon: dragHandle,
      className: "block-selection-button_drag-handle",
      "aria-hidden": "true",
      label: dragHandleLabel // Should not be able to tab to drag handle as this
      // button can only be used with a pointer device.
      ,
      tabIndex: "-1"
    }, draggableProps));
  })), createElement(FlexItem, null, createElement(Button, {
    ref: ref,
    onClick: function onClick() {
      return setNavigationMode(false);
    },
    onKeyDown: onKeyDown,
    label: label,
    className: "block-selection-button_select-button"
  }, createElement(BlockTitle, {
    clientId: clientId
  })))));
}

export default BlockSelectionButton;
//# sourceMappingURL=block-selection-button.js.map