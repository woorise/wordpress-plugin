import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { AsyncModeProvider, useSelect } from '@wordpress/data';
import { useRef, createContext, useState } from '@wordpress/element';
import { useViewportMatch } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import BlockListBlock from './block';
import BlockListAppender from '../block-list-appender';
import useBlockDropZone from '../use-block-drop-zone';
import useInsertionPoint from './insertion-point';
import BlockPopover from './block-popover';
import { store as blockEditorStore } from '../../store';
import { useScrollSelectionIntoView } from '../selection-scroll-into-view';
import { usePreParsePatterns } from '../../utils/pre-parse-patterns';
import { LayoutProvider, defaultLayout } from './layout';
export var BlockNodes = createContext();
export var SetBlockNodes = createContext();
export default function BlockList(_ref) {
  var className = _ref.className,
      __experimentalLayout = _ref.__experimentalLayout;
  var ref = useRef();

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      blockNodes = _useState2[0],
      setBlockNodes = _useState2[1];

  var insertionPoint = useInsertionPoint(ref);
  useScrollSelectionIntoView(ref);
  usePreParsePatterns();
  var isLargeViewport = useViewportMatch('medium');

  var _useSelect = useSelect(function (select) {
    var _select = select(blockEditorStore),
        _isTyping = _select.isTyping,
        getSettings = _select.getSettings,
        _isNavigationMode = _select.isNavigationMode;

    var _getSettings = getSettings(),
        outlineMode = _getSettings.outlineMode,
        focusMode = _getSettings.focusMode;

    return {
      isTyping: _isTyping(),
      isOutlineMode: outlineMode,
      isFocusMode: focusMode,
      isNavigationMode: _isNavigationMode()
    };
  }, []),
      isTyping = _useSelect.isTyping,
      isOutlineMode = _useSelect.isOutlineMode,
      isFocusMode = _useSelect.isFocusMode,
      isNavigationMode = _useSelect.isNavigationMode;

  return createElement(BlockNodes.Provider, {
    value: blockNodes
  }, insertionPoint, createElement(BlockPopover, null), createElement("div", {
    ref: ref,
    className: classnames('block-editor-block-list__layout is-root-container', className, {
      'is-typing': isTyping,
      'is-outline-mode': isOutlineMode,
      'is-focus-mode': isFocusMode && isLargeViewport,
      'is-navigate-mode': isNavigationMode
    })
  }, createElement(SetBlockNodes.Provider, {
    value: setBlockNodes
  }, createElement(BlockListItems, {
    wrapperRef: ref,
    __experimentalLayout: __experimentalLayout
  }))));
}

function Items(_ref2) {
  var placeholder = _ref2.placeholder,
      rootClientId = _ref2.rootClientId,
      renderAppender = _ref2.renderAppender,
      __experimentalAppenderTagName = _ref2.__experimentalAppenderTagName,
      _ref2$__experimentalL = _ref2.__experimentalLayout,
      layout = _ref2$__experimentalL === void 0 ? defaultLayout : _ref2$__experimentalL,
      wrapperRef = _ref2.wrapperRef;

  function selector(select) {
    var _getBlockListSettings;

    var _select2 = select(blockEditorStore),
        getBlockOrder = _select2.getBlockOrder,
        getBlockListSettings = _select2.getBlockListSettings,
        getSelectedBlockClientId = _select2.getSelectedBlockClientId,
        getMultiSelectedBlockClientIds = _select2.getMultiSelectedBlockClientIds,
        hasMultiSelection = _select2.hasMultiSelection;

    return {
      blockClientIds: getBlockOrder(rootClientId),
      selectedBlockClientId: getSelectedBlockClientId(),
      multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
      orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation,
      hasMultiSelection: hasMultiSelection()
    };
  }

  var _useSelect2 = useSelect(selector, [rootClientId]),
      blockClientIds = _useSelect2.blockClientIds,
      selectedBlockClientId = _useSelect2.selectedBlockClientId,
      multiSelectedBlockClientIds = _useSelect2.multiSelectedBlockClientIds,
      orientation = _useSelect2.orientation,
      hasMultiSelection = _useSelect2.hasMultiSelection;

  var dropTargetIndex = useBlockDropZone({
    element: wrapperRef,
    rootClientId: rootClientId
  });
  var isAppenderDropTarget = dropTargetIndex === blockClientIds.length;
  return createElement(LayoutProvider, {
    value: layout
  }, blockClientIds.map(function (clientId, index) {
    var isBlockInSelection = hasMultiSelection ? multiSelectedBlockClientIds.includes(clientId) : selectedBlockClientId === clientId;
    var isDropTarget = dropTargetIndex === index;
    return createElement(AsyncModeProvider, {
      key: clientId,
      value: !isBlockInSelection
    }, createElement(BlockListBlock, {
      rootClientId: rootClientId,
      clientId: clientId // This prop is explicitely computed and passed down
      // to avoid being impacted by the async mode
      // otherwise there might be a small delay to trigger the animation.
      ,
      index: index,
      className: classnames({
        'is-drop-target': isDropTarget,
        'is-dropping-horizontally': isDropTarget && orientation === 'horizontal'
      })
    }));
  }), blockClientIds.length < 1 && placeholder, createElement(BlockListAppender, {
    tagName: __experimentalAppenderTagName,
    rootClientId: rootClientId,
    renderAppender: renderAppender,
    className: classnames({
      'is-drop-target': isAppenderDropTarget,
      'is-dropping-horizontally': isAppenderDropTarget && orientation === 'horizontal'
    })
  }));
}

export function BlockListItems(props) {
  // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.
  return createElement(AsyncModeProvider, {
    value: false
  }, createElement(Items, props));
}
//# sourceMappingURL=index.js.map