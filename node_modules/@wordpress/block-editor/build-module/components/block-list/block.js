import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { createElement, Fragment } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import classnames from 'classnames';
import { omit } from 'lodash';
/**
 * WordPress dependencies
 */

import { createContext, useMemo, useCallback } from '@wordpress/element';
import { getBlockType, getSaveElement, isUnmodifiedDefaultBlock, hasBlockSupport } from '@wordpress/blocks';
import { withFilters } from '@wordpress/components';
import { withDispatch, withSelect, useDispatch } from '@wordpress/data';
import { compose, pure, ifCondition } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import BlockEdit from '../block-edit';
import BlockInvalidWarning from './block-invalid-warning';
import BlockCrashWarning from './block-crash-warning';
import BlockCrashBoundary from './block-crash-boundary';
import BlockHtml from './block-html';
import { useBlockProps } from './use-block-props';
import { store as blockEditorStore } from '../../store';
export var BlockListBlockContext = createContext();
/**
 * Merges wrapper props with special handling for classNames and styles.
 *
 * @param {Object} propsA
 * @param {Object} propsB
 *
 * @return {Object} Merged props.
 */

function mergeWrapperProps(propsA, propsB) {
  var newProps = _objectSpread(_objectSpread({}, propsA), propsB);

  if (propsA && propsB && propsA.className && propsB.className) {
    newProps.className = classnames(propsA.className, propsB.className);
  }

  if (propsA && propsB && propsA.style && propsB.style) {
    newProps.style = _objectSpread(_objectSpread({}, propsA.style), propsB.style);
  }

  return newProps;
}

function Block(_ref) {
  var children = _ref.children,
      isHtml = _ref.isHtml,
      props = _objectWithoutProperties(_ref, ["children", "isHtml"]);

  return createElement("div", useBlockProps(props, {
    __unstableIsHtml: isHtml
  }), children);
}

function BlockListBlock(_ref2) {
  var mode = _ref2.mode,
      isLocked = _ref2.isLocked,
      clientId = _ref2.clientId,
      isSelected = _ref2.isSelected,
      isSelectionEnabled = _ref2.isSelectionEnabled,
      className = _ref2.className,
      name = _ref2.name,
      isValid = _ref2.isValid,
      attributes = _ref2.attributes,
      wrapperProps = _ref2.wrapperProps,
      setAttributes = _ref2.setAttributes,
      onReplace = _ref2.onReplace,
      onInsertBlocksAfter = _ref2.onInsertBlocksAfter,
      onMerge = _ref2.onMerge,
      toggleSelection = _ref2.toggleSelection,
      index = _ref2.index;

  var _useDispatch = useDispatch(blockEditorStore),
      removeBlock = _useDispatch.removeBlock;

  var onRemove = useCallback(function () {
    return removeBlock(clientId);
  }, [clientId]); // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  var blockEdit = createElement(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: isLocked ? undefined : onReplace,
    onRemove: isLocked ? undefined : onRemove,
    mergeBlocks: isLocked ? undefined : onMerge,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection
  });
  var blockType = getBlockType(name);
  var lightBlockWrapper = blockType.apiVersion > 1 || hasBlockSupport(blockType, 'lightBlockWrapper', false); // Determine whether the block has props to apply to the wrapper.

  if (blockType.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
  }

  var isAligned = wrapperProps && !!wrapperProps['data-align']; // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column.

  if (isAligned) {
    blockEdit = createElement("div", {
      className: "wp-block",
      "data-align": wrapperProps['data-align']
    }, blockEdit);
  }

  var block;

  if (!isValid) {
    block = createElement(Block, {
      className: "has-warning"
    }, createElement(BlockInvalidWarning, {
      clientId: clientId
    }), createElement("div", null, getSaveElement(blockType, attributes)));
  } else if (mode === 'html') {
    // Render blockEdit so the inspector controls don't disappear.
    // See #8969.
    block = createElement(Fragment, null, createElement("div", {
      style: {
        display: 'none'
      }
    }, blockEdit), createElement(Block, {
      isHtml: true
    }, createElement(BlockHtml, {
      clientId: clientId
    })));
  } else if (lightBlockWrapper) {
    block = blockEdit;
  } else {
    block = createElement(Block, wrapperProps, blockEdit);
  }

  var value = {
    clientId: clientId,
    isSelected: isSelected,
    index: index,
    // The wp-block className is important for editor styles.
    className: classnames(className, {
      'wp-block': !isAligned
    }),
    wrapperProps: omit(wrapperProps, ['data-align'])
  };
  var memoizedValue = useMemo(function () {
    return value;
  }, Object.values(value));
  return createElement(BlockListBlockContext.Provider, {
    value: memoizedValue
  }, createElement(BlockCrashBoundary, {
    fallback: createElement(Block, {
      className: "has-warning"
    }, createElement(BlockCrashWarning, null))
  }, block));
}

var applyWithSelect = withSelect(function (select, _ref3) {
  var clientId = _ref3.clientId,
      rootClientId = _ref3.rootClientId;

  var _select = select(blockEditorStore),
      isBlockSelected = _select.isBlockSelected,
      getBlockMode = _select.getBlockMode,
      isSelectionEnabled = _select.isSelectionEnabled,
      getTemplateLock = _select.getTemplateLock,
      __unstableGetBlockWithoutInnerBlocks = _select.__unstableGetBlockWithoutInnerBlocks;

  var block = __unstableGetBlockWithoutInnerBlocks(clientId);

  var isSelected = isBlockSelected(clientId);
  var templateLock = getTemplateLock(rootClientId); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in
  // the state. It happens now because the order in withSelect rendering
  // is not correct.

  var _ref4 = block || {},
      name = _ref4.name,
      attributes = _ref4.attributes,
      isValid = _ref4.isValid; // Do not add new properties here, use `useSelect` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).


  return {
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    isLocked: !!templateLock,
    // Users of the editor.BlockListBlock filter used to be able to
    // access the block prop.
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block: block,
    name: name,
    attributes: attributes,
    isValid: isValid,
    isSelected: isSelected
  };
});
var applyWithDispatch = withDispatch(function (dispatch, ownProps, _ref5) {
  var select = _ref5.select;

  var _dispatch = dispatch(blockEditorStore),
      updateBlockAttributes = _dispatch.updateBlockAttributes,
      insertBlocks = _dispatch.insertBlocks,
      mergeBlocks = _dispatch.mergeBlocks,
      replaceBlocks = _dispatch.replaceBlocks,
      _toggleSelection = _dispatch.toggleSelection,
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent; // Do not add new properties here, use `useDispatch` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).


  return {
    setAttributes: function setAttributes(newAttributes) {
      var _select2 = select(blockEditorStore),
          getMultiSelectedBlockClientIds = _select2.getMultiSelectedBlockClientIds;

      var multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      var clientId = ownProps.clientId;
      var clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      updateBlockAttributes(clientIds, newAttributes);
    },
    onInsertBlocks: function onInsertBlocks(blocks, index) {
      var rootClientId = ownProps.rootClientId;
      insertBlocks(blocks, index, rootClientId);
    },
    onInsertBlocksAfter: function onInsertBlocksAfter(blocks) {
      var clientId = ownProps.clientId,
          rootClientId = ownProps.rootClientId;

      var _select3 = select(blockEditorStore),
          getBlockIndex = _select3.getBlockIndex;

      var index = getBlockIndex(clientId, rootClientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },
    onMerge: function onMerge(forward) {
      var clientId = ownProps.clientId;

      var _select4 = select(blockEditorStore),
          getPreviousBlockClientId = _select4.getPreviousBlockClientId,
          getNextBlockClientId = _select4.getNextBlockClientId;

      if (forward) {
        var nextBlockClientId = getNextBlockClientId(clientId);

        if (nextBlockClientId) {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        var previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        }
      }
    },
    onReplace: function onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !isUnmodifiedDefaultBlock(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect, initialPosition);
    },
    toggleSelection: function toggleSelection(selectionEnabled) {
      _toggleSelection(selectionEnabled);
    }
  };
});
export default compose(pure, applyWithSelect, applyWithDispatch, // block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info
// https://github.com/WordPress/gutenberg/issues/17013
ifCondition(function (_ref6) {
  var block = _ref6.block;
  return !!block;
}), withFilters('editor.BlockListBlock'))(BlockListBlock);
//# sourceMappingURL=block.js.map