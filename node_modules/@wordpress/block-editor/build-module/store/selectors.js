import _typeof from "@babel/runtime/helpers/esm/typeof";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { createElement } from "@wordpress/element";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { castArray, flatMap, first, isArray, isBoolean, last, map, reduce, some, find, filter, mapKeys, orderBy } from 'lodash';
import createSelector from 'rememo';
/**
 * WordPress dependencies
 */

import { getBlockType, getBlockTypes, hasBlockSupport, getPossibleBlockTransformations, parse } from '@wordpress/blocks';
import { SVG, Rect, G, Path } from '@wordpress/components';
import { Platform } from '@wordpress/element';
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */
// Module constants

var MILLISECONDS_PER_HOUR = 3600 * 1000;
var MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
var MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;
var templateIcon = createElement(SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, createElement(Rect, {
  x: "0",
  fill: "none",
  width: "24",
  height: "24"
}), createElement(G, null, createElement(Path, {
  d: "M19 3H5c-1.105 0-2 .895-2 2v14c0 1.105.895 2 2 2h14c1.105 0 2-.895 2-2V5c0-1.105-.895-2-2-2zM6 6h5v5H6V6zm4.5 13C9.12 19 8 17.88 8 16.5S9.12 14 10.5 14s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm3-6l3-5 3 5h-6z"
})));
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */

var EMPTY_ARRAY = [];
/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */

export function getBlockName(state, clientId) {
  var block = state.blocks.byClientId[clientId];
  var socialLinkName = 'core/social-link';

  if (Platform.OS !== 'web' && (block === null || block === void 0 ? void 0 : block.name) === socialLinkName) {
    var attributes = state.blocks.attributes[clientId];
    var service = attributes.service;
    return service ? "".concat(socialLinkName, "-").concat(service) : socialLinkName;
  }

  return block ? block.name : null;
}
/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */

export function isBlockValid(state, clientId) {
  var block = state.blocks.byClientId[clientId];
  return !!block && block.isValid;
}
/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */

export function getBlockAttributes(state, clientId) {
  var block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return state.blocks.attributes[clientId];
}
/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */

export var getBlock = createSelector(function (state, clientId) {
  var block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return _objectSpread(_objectSpread({}, block), {}, {
    attributes: getBlockAttributes(state, clientId),
    innerBlocks: areInnerBlocksControlled(state, clientId) ? EMPTY_ARRAY : getBlocks(state, clientId)
  });
}, function (state, clientId) {
  return [// Normally, we'd have both `getBlockAttributes` dependencies and
  // `getBlocks` (children) dependencies here but for performance reasons
  // we use a denormalized cache key computed in the reducer that takes both
  // the attributes and inner blocks into account. The value of the cache key
  // is being changed whenever one of these dependencies is out of date.
  state.blocks.cache[clientId]];
});
export var __unstableGetBlockWithoutInnerBlocks = createSelector(function (state, clientId) {
  var block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return _objectSpread(_objectSpread({}, block), {}, {
    attributes: getBlockAttributes(state, clientId)
  });
}, function (state, clientId) {
  return [state.blocks.byClientId[clientId], state.blocks.attributes[clientId]];
});
/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * Note: It's important to memoize this selector to avoid return a new instance
 * on each call. We use the block cache state for each top-level block of the
 * given clientID. This way, the selector only refreshes on changes to blocks
 * associated with the given entity, and does not refresh when changes are made
 * to blocks which are part of different inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

export var getBlocks = createSelector(function (state, rootClientId) {
  return map(getBlockOrder(state, rootClientId), function (clientId) {
    return getBlock(state, clientId);
  });
}, function (state, rootClientId) {
  return map(state.blocks.order[rootClientId || ''], function (id) {
    return state.blocks.cache[id];
  });
});
/**
 * Similar to getBlock, except it will include the entire nested block tree as
 * inner blocks. The normal getBlock selector will exclude sections of the block
 * tree which belong to different entities.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} The block with all
 */

export var __unstableGetBlockWithBlockTree = createSelector(function (state, clientId) {
  var block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return _objectSpread(_objectSpread({}, block), {}, {
    attributes: getBlockAttributes(state, clientId),
    innerBlocks: __unstableGetBlockTree(state, clientId)
  });
}, function (state) {
  return [state.blocks.byClientId, state.blocks.order, state.blocks.attributes];
});
/**
 * Similar to getBlocks, except this selector returns the entire block tree
 * represented in the block-editor store from the given root regardless of any
 * inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

export var __unstableGetBlockTree = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return map(getBlockOrder(state, rootClientId), function (clientId) {
    return __unstableGetBlockWithBlockTree(state, clientId);
  });
}, function (state) {
  return [state.blocks.byClientId, state.blocks.order, state.blocks.attributes];
});
/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */

export var __unstableGetClientIdWithClientIdsTree = createSelector(function (state, clientId) {
  return {
    clientId: clientId,
    innerBlocks: __unstableGetClientIdsTree(state, clientId)
  };
}, function (state) {
  return [state.blocks.order];
});
/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */

export var __unstableGetClientIdsTree = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return map(getBlockOrder(state, rootClientId), function (clientId) {
    return __unstableGetClientIdWithClientIdsTree(state, clientId);
  });
}, function (state) {
  return [state.blocks.order];
});
/**
 * Returns an array containing the clientIds of all descendants
 * of the blocks given.
 *
 * @param {Object} state Global application state.
 * @param {Array} clientIds Array of blocks to inspect.
 *
 * @return {Array} ids of descendants.
 */

export var getClientIdsOfDescendants = function getClientIdsOfDescendants(state, clientIds) {
  return flatMap(clientIds, function (clientId) {
    var descendants = getBlockOrder(state, clientId);
    return [].concat(_toConsumableArray(descendants), _toConsumableArray(getClientIdsOfDescendants(state, descendants)));
  });
};
/**
 * Returns an array containing the clientIds of the top-level blocks
 * and their descendants of any depth (for nested blocks).
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */

export var getClientIdsWithDescendants = createSelector(function (state) {
  var topLevelIds = getBlockOrder(state);
  return [].concat(_toConsumableArray(topLevelIds), _toConsumableArray(getClientIdsOfDescendants(state, topLevelIds)));
}, function (state) {
  return [state.blocks.order];
});
/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */

export var getGlobalBlockCount = createSelector(function (state, blockName) {
  var clientIds = getClientIdsWithDescendants(state);

  if (!blockName) {
    return clientIds.length;
  }

  return reduce(clientIds, function (accumulator, clientId) {
    var block = state.blocks.byClientId[clientId];
    return block.name === blockName ? accumulator + 1 : accumulator;
  }, 0);
}, function (state) {
  return [state.blocks.order, state.blocks.byClientId];
});
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */

export var getBlocksByClientId = createSelector(function (state, clientIds) {
  return map(castArray(clientIds), function (clientId) {
    return getBlock(state, clientId);
  });
}, function (state) {
  return [state.blocks.byClientId, state.blocks.order, state.blocks.attributes];
});
/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */

export function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}
/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */

export function getSelectionStart(state) {
  return state.selection.selectionStart;
}
/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */

export function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */

export function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */

export function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */

export function getSelectedBlockCount(state) {
  var multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;

  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }

  return state.selection.selectionStart.clientId ? 1 : 0;
}
/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */

export function hasSelectedBlock(state) {
  var _state$selection = state.selection,
      selectionStart = _state$selection.selectionStart,
      selectionEnd = _state$selection.selectionEnd;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */

export function getSelectedBlockClientId(state) {
  var _state$selection2 = state.selection,
      selectionStart = _state$selection2.selectionStart,
      selectionEnd = _state$selection2.selectionEnd;
  var clientId = selectionStart.clientId;

  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }

  return clientId;
}
/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */

export function getSelectedBlock(state) {
  var clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}
/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */

export function getBlockRootClientId(state, clientId) {
  return state.blocks.parents[clientId] !== undefined ? state.blocks.parents[clientId] : null;
}
/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

export var getBlockParents = createSelector(function (state, clientId) {
  var ascending = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var parents = [];
  var current = clientId;

  while (!!state.blocks.parents[current]) {
    current = state.blocks.parents[current];
    parents.push(current);
  }

  return ascending ? parents : parents.reverse();
}, function (state) {
  return [state.blocks.parents];
});
/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

export var getBlockParentsByBlockName = createSelector(function (state, clientId, blockName) {
  var ascending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var parents = getBlockParents(state, clientId, ascending);
  return map(filter(map(parents, function (id) {
    return {
      id: id,
      name: getBlockName(state, id)
    };
  }), function (_ref) {
    var name = _ref.name;

    if (Array.isArray(blockName)) {
      return blockName.includes(name);
    }

    return name === blockName;
  }), function (_ref2) {
    var id = _ref2.id;
    return id;
  });
}, function (state) {
  return [state.blocks.parents];
});
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */

export function getBlockHierarchyRootClientId(state, clientId) {
  var current = clientId;
  var parent;

  do {
    parent = current;
    current = state.blocks.parents[current];
  } while (current);

  return parent;
}
/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */

export function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  var selectedId = getSelectedBlockClientId(state);
  var clientParents = [].concat(_toConsumableArray(getBlockParents(state, clientId)), [clientId]);
  var selectedParents = [].concat(_toConsumableArray(getBlockParents(state, selectedId)), [selectedId]);
  var lowestCommonAncestor;
  var maxDepth = Math.min(clientParents.length, selectedParents.length);

  for (var index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }

  return lowestCommonAncestor;
}
/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */

export function getAdjacentBlockClientId(state, startClientId) {
  var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = getSelectedBlockClientId(state);
  } // Try multi-selection starting at extent based on modifier.


  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  } // Validate working start client ID.


  if (!startClientId) {
    return null;
  } // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.


  var rootClientId = getBlockRootClientId(state, startClientId);

  if (rootClientId === null) {
    return null;
  }

  var order = state.blocks.order;
  var orderSet = order[rootClientId];
  var index = orderSet.indexOf(startClientId);
  var nextIndex = index + 1 * modifier; // Block was first in set and we're attempting to get previous.

  if (nextIndex < 0) {
    return null;
  } // Block was last in set and we're attempting to get next.


  if (nextIndex === orderSet.length) {
    return null;
  } // Assume incremented index is within the set.


  return orderSet[nextIndex];
}
/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

export function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

export function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */

export function getSelectedBlocksInitialCaretPosition(state) {
  return state.initialPosition;
}
/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

export var getSelectedBlockClientIds = createSelector(function (state) {
  var _state$selection3 = state.selection,
      selectionStart = _state$selection3.selectionStart,
      selectionEnd = _state$selection3.selectionEnd;

  if (selectionStart.clientId === undefined || selectionEnd.clientId === undefined) {
    return EMPTY_ARRAY;
  }

  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  } // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.


  var rootClientId = getBlockRootClientId(state, selectionStart.clientId);

  if (rootClientId === null) {
    return EMPTY_ARRAY;
  }

  var blockOrder = getBlockOrder(state, rootClientId);
  var startIndex = blockOrder.indexOf(selectionStart.clientId);
  var endIndex = blockOrder.indexOf(selectionEnd.clientId);

  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }

  return blockOrder.slice(startIndex, endIndex + 1);
}, function (state) {
  return [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId];
});
/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

export function getMultiSelectedBlockClientIds(state) {
  var _state$selection4 = state.selection,
      selectionStart = _state$selection4.selectionStart,
      selectionEnd = _state$selection4.selectionEnd;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  return getSelectedBlockClientIds(state);
}
/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */

export var getMultiSelectedBlocks = createSelector(function (state) {
  var multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);

  if (!multiSelectedBlockClientIds.length) {
    return EMPTY_ARRAY;
  }

  return multiSelectedBlockClientIds.map(function (clientId) {
    return getBlock(state, clientId);
  });
}, function (state) {
  return [].concat(_toConsumableArray(getSelectedBlockClientIds.getDependants(state)), [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
});
/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */

export function getFirstMultiSelectedBlockClientId(state) {
  return first(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */

export function getLastMultiSelectedBlockClientId(state) {
  return last(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */

export function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}
/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */

export function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */

export var isAncestorMultiSelected = createSelector(function (state, clientId) {
  var ancestorClientId = clientId;
  var isMultiSelected = false;

  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
  }

  return isMultiSelected;
}, function (state) {
  return [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId];
});
/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */

export function getMultiSelectedBlocksStartClientId(state) {
  var _state$selection5 = state.selection,
      selectionStart = _state$selection5.selectionStart,
      selectionEnd = _state$selection5.selectionEnd;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionStart.clientId || null;
}
/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */

export function getMultiSelectedBlocksEndClientId(state) {
  var _state$selection6 = state.selection,
      selectionStart = _state$selection6.selectionStart,
      selectionEnd = _state$selection6.selectionEnd;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionEnd.clientId || null;
}
/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */

export function getBlockOrder(state, rootClientId) {
  return state.blocks.order[rootClientId || ''] || EMPTY_ARRAY;
}
/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     Block client ID.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Index at which block exists in order.
 */

export function getBlockIndex(state, clientId, rootClientId) {
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */

export function isBlockSelected(state, clientId) {
  var _state$selection7 = state.selection,
      selectionStart = _state$selection7.selectionStart,
      selectionEnd = _state$selection7.selectionEnd;

  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }

  return selectionStart.clientId === clientId;
}
/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block as an inner block selected
 */

export function hasSelectedInnerBlock(state, clientId) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return some(getBlockOrder(state, clientId), function (innerClientId) {
    return isBlockSelected(state, innerClientId) || isBlockMultiSelected(state, innerClientId) || deep && hasSelectedInnerBlock(state, innerClientId, deep);
  });
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */

export function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }

  var clientIds = getMultiSelectedBlockClientIds(state);
  var index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */

export function hasMultiSelection(state) {
  var _state$selection8 = state.selection,
      selectionStart = _state$selection8.selectionStart,
      selectionEnd = _state$selection8.selectionEnd;
  return selectionStart.clientId !== selectionEnd.clientId;
}
/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */

export function isMultiSelecting(state) {
  return state.isMultiSelecting;
}
/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */

export function isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */

export function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}
/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */

export function isTyping(state) {
  return state.isTyping;
}
/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */

export function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */

export function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */

export function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */

export function isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }

  var parents = getBlockParents(state, clientId);
  return some(parents, function (parentClientId) {
    return isBlockBeingDragged(state, parentClientId);
  });
}
/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the caret is within formatted text.
 */

export function isCaretWithinFormattedText(state) {
  return state.isCaretWithinFormattedText;
}
/**
 * Returns the insertion point. This will be:
 *
 * 1) The insertion point manually set using setInsertionPoint() or
 *    showInsertionPoint(); or
 * 2) The point after the current block selection, if there is a selection; or
 * 3) The point at the end of the block list.
 *
 * Components like <Inserter> will default to inserting blocks at this point.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object} Insertion point object with `rootClientId` and `index`.
 */

export function getBlockInsertionPoint(state) {
  var rootClientId, index;
  var insertionPoint = state.insertionPoint,
      selectionEnd = state.selection.selectionEnd;

  if (insertionPoint !== null) {
    return insertionPoint;
  }

  var clientId = selectionEnd.clientId;

  if (clientId) {
    rootClientId = getBlockRootClientId(state, clientId) || undefined;
    index = getBlockIndex(state, selectionEnd.clientId, rootClientId) + 1;
  } else {
    index = getBlockOrder(state).length;
  }

  return {
    rootClientId: rootClientId,
    index: index
  };
}
/**
 * Whether or not the insertion point should be shown to users. This is set
 * using showInsertionPoint() or hideInsertionPoint().
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point should be shown.
 */

export function isBlockInsertionPointVisible(state) {
  return state.insertionPointVisibility;
}
/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */

export function isValidTemplate(state) {
  return state.template.isValid;
}
/**
 * Returns the defined block template
 *
 * @param {boolean} state
 * @return {?Array}        Block Template
 */

export function getTemplate(state) {
  return state.settings.template;
}
/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {?string} Block Template Lock
 */

export function getTemplateLock(state, rootClientId) {
  if (!rootClientId) {
    return state.settings.templateLock;
  }

  var blockListSettings = getBlockListSettings(state, rootClientId);

  if (!blockListSettings) {
    return null;
  }

  return blockListSettings.templateLock;
}
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}         state        Editor state.
 * @param {string|Object}  blockName    The block type object, e.g., the response
 *                                      from the block directory; or a string name of
 *                                      an installed block type, e.g.' core/paragraph'.
 * @param {?string}        rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */

var canInsertBlockTypeUnmemoized = function canInsertBlockTypeUnmemoized(state, blockName) {
  var rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var checkAllowList = function checkAllowList(list, item) {
    var defaultResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (isBoolean(list)) {
      return list;
    }

    if (isArray(list)) {
      // TODO: when there is a canonical way to detect that we are editing a post
      // the following check should be changed to something like:
      // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
      if (list.includes('core/post-content') && item === null) {
        return true;
      }

      return list.includes(item);
    }

    return defaultResult;
  };

  var blockType;

  if (blockName && 'object' === _typeof(blockName)) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = getBlockType(blockName);
  }

  if (!blockType) {
    return false;
  }

  var _getSettings = getSettings(state),
      allowedBlockTypes = _getSettings.allowedBlockTypes;

  var isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);

  if (!isBlockAllowedInEditor) {
    return false;
  }

  var isLocked = !!getTemplateLock(state, rootClientId);

  if (isLocked) {
    return false;
  }

  var parentBlockListSettings = getBlockListSettings(state, rootClientId); // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.

  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }

  var parentAllowedBlocks = parentBlockListSettings === null || parentBlockListSettings === void 0 ? void 0 : parentBlockListSettings.allowedBlocks;
  var hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
  var blockAllowedParentBlocks = blockType.parent;
  var parentName = getBlockName(state, rootClientId);
  var hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);

  if (hasParentAllowedBlock !== null && hasBlockAllowedParent !== null) {
    return hasParentAllowedBlock || hasBlockAllowedParent;
  } else if (hasParentAllowedBlock !== null) {
    return hasParentAllowedBlock;
  } else if (hasBlockAllowedParent !== null) {
    return hasBlockAllowedParent;
  }

  return true;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


export var canInsertBlockType = createSelector(canInsertBlockTypeUnmemoized, function (state, blockName, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId], state.settings.allowedBlockTypes, state.settings.templateLock];
});
/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */

export function canInsertBlocks(state, clientIds) {
  var rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return clientIds.every(function (id) {
    return canInsertBlockType(state, getBlockName(state, id), rootClientId);
  });
}
/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */

function getInsertUsage(state, id) {
  var _state$preferences$in, _state$preferences$in2;

  return (_state$preferences$in = (_state$preferences$in2 = state.preferences.insertUsage) === null || _state$preferences$in2 === void 0 ? void 0 : _state$preferences$in2[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}
/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object} state Global State
 * @param {Object} blockType BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */


var canIncludeBlockTypeInInserter = function canIncludeBlockTypeInInserter(state, blockType, rootClientId) {
  if (!hasBlockSupport(blockType, 'inserter', true)) {
    return false;
  }

  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */


var getItemFromVariation = function getItemFromVariation(state, item) {
  return function (variation) {
    var variationId = "".concat(item.id, "/").concat(variation.name);

    var _ref3 = getInsertUsage(state, variationId) || {},
        time = _ref3.time,
        _ref3$count = _ref3.count,
        count = _ref3$count === void 0 ? 0 : _ref3$count;

    return _objectSpread(_objectSpread({}, item), {}, {
      id: variationId,
      icon: variation.icon || item.icon,
      title: variation.title || item.title,
      description: variation.description || item.description,
      category: variation.category || item.category,
      // If `example` is explicitly undefined for the variation, the preview will not be shown.
      example: variation.hasOwnProperty('example') ? variation.example : item.example,
      initialAttributes: _objectSpread(_objectSpread({}, item.initialAttributes), variation.attributes),
      innerBlocks: variation.innerBlocks,
      keywords: variation.keywords || item.keywords,
      frecency: calculateFrecency(time, count)
    });
  };
};
/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */


var calculateFrecency = function calculateFrecency(time, count) {
  if (!time) {
    return count;
  } // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.


  var duration = Date.now() - time;

  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;

    case duration < MILLISECONDS_PER_DAY:
      return count * 2;

    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;

    default:
      return count / 4;
  }
};
/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state Editor state.
 * @param {Object} options Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */


var buildBlockTypeItem = function buildBlockTypeItem(state, _ref4) {
  var _ref4$buildScope = _ref4.buildScope,
      buildScope = _ref4$buildScope === void 0 ? 'inserter' : _ref4$buildScope;
  return function (blockType) {
    var id = blockType.name;
    var isDisabled = false;

    if (!hasBlockSupport(blockType.name, 'multiple', true)) {
      isDisabled = some(getBlocksByClientId(state, getClientIdsWithDescendants(state)), {
        name: blockType.name
      });
    }

    var _ref5 = getInsertUsage(state, id) || {},
        time = _ref5.time,
        _ref5$count = _ref5.count,
        count = _ref5$count === void 0 ? 0 : _ref5$count;

    var blockItemBase = {
      id: id,
      name: blockType.name,
      title: blockType.title,
      icon: blockType.icon,
      isDisabled: isDisabled,
      frecency: calculateFrecency(time, count)
    };
    if (buildScope === 'transform') return blockItemBase;
    var inserterVariations = blockType.variations.filter(function (_ref6) {
      var scope = _ref6.scope;
      return !scope || scope.includes('inserter');
    });
    return _objectSpread(_objectSpread({}, blockItemBase), {}, {
      initialAttributes: {},
      description: blockType.description,
      category: blockType.category,
      keywords: blockType.keywords,
      variations: inserterVariations,
      example: blockType.example,
      utility: 1 // deprecated

    });
  };
};
/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */


export var getInserterItems = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });

  var buildReusableBlockInserterItem = function buildReusableBlockInserterItem(reusableBlock) {
    var id = "core/block/".concat(reusableBlock.id);

    var referencedBlocks = __experimentalGetParsedReusableBlock(state, reusableBlock.id);

    var referencedBlockType;

    if (referencedBlocks.length === 1) {
      referencedBlockType = getBlockType(referencedBlocks[0].name);
    }

    var _ref7 = getInsertUsage(state, id) || {},
        time = _ref7.time,
        _ref7$count = _ref7.count,
        count = _ref7$count === void 0 ? 0 : _ref7$count;

    var frecency = calculateFrecency(time, count);
    return {
      id: id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title.raw,
      icon: referencedBlockType ? referencedBlockType.icon : templateIcon,
      category: 'reusable',
      keywords: [],
      isDisabled: false,
      utility: 1,
      // deprecated
      frecency: frecency
    };
  };

  var blockTypeInserterItems = getBlockTypes().filter(function (blockType) {
    return canIncludeBlockTypeInInserter(state, blockType, rootClientId);
  }).map(buildBlockTypeInserterItem);
  var reusableBlockInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? getReusableBlocks(state).map(buildReusableBlockInserterItem) : []; // Exclude any block type item that is to be replaced by a default
  // variation.

  var visibleBlockTypeInserterItems = blockTypeInserterItems.filter(function (_ref8) {
    var _ref8$variations = _ref8.variations,
        variations = _ref8$variations === void 0 ? [] : _ref8$variations;
    return !variations.some(function (_ref9) {
      var isDefault = _ref9.isDefault;
      return isDefault;
    });
  });
  var blockVariations = []; // Show all available blocks with variations

  var _iterator = _createForOfIteratorHelper(blockTypeInserterItems),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      var _item$variations = item.variations,
          variations = _item$variations === void 0 ? [] : _item$variations;

      if (variations.length) {
        var variationMapper = getItemFromVariation(state, item);
        blockVariations.push.apply(blockVariations, _toConsumableArray(variations.map(variationMapper)));
      }
    } // Prioritize core blocks's display in inserter.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var prioritizeCoreBlocks = function prioritizeCoreBlocks(a, b) {
    var coreBlockNamePrefix = 'core/';
    var firstIsCoreBlock = a.name.startsWith(coreBlockNamePrefix);
    var secondIsCoreBlock = b.name.startsWith(coreBlockNamePrefix);

    if (firstIsCoreBlock && secondIsCoreBlock) {
      return 0;
    }

    return firstIsCoreBlock && !secondIsCoreBlock ? -1 : 1;
  }; // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.


  var sortedBlockTypes = [].concat(_toConsumableArray(visibleBlockTypeInserterItems), blockVariations).sort(prioritizeCoreBlocks);
  return [].concat(_toConsumableArray(sortedBlockTypes), _toConsumableArray(reusableBlockInserterItems));
}, function (state, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), getBlockTypes()];
});
/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */

export var getBlockTransformItems = createSelector(function (state, blocks) {
  var rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  var blockTypeTransformItems = getBlockTypes().filter(function (blockType) {
    return canIncludeBlockTypeInInserter(state, blockType, rootClientId);
  }).map(buildBlockTypeTransformItem);
  var itemsByName = mapKeys(blockTypeTransformItems, function (_ref10) {
    var name = _ref10.name;
    return name;
  });
  var possibleTransforms = getPossibleBlockTransformations(blocks).reduce(function (accumulator, block) {
    if (itemsByName[block === null || block === void 0 ? void 0 : block.name]) {
      accumulator.push(itemsByName[block.name]);
    }

    return accumulator;
  }, []);
  var possibleBlockTransformations = orderBy(possibleTransforms, function (block) {
    return itemsByName[block.name].frecency;
  }, 'desc');
  return possibleBlockTransformations;
}, function (state, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getBlockTypes()];
});
/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */

export var hasInserterItems = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var hasBlockType = some(getBlockTypes(), function (blockType) {
    return canIncludeBlockTypeInInserter(state, blockType, rootClientId);
  });

  if (hasBlockType) {
    return true;
  }

  var hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && getReusableBlocks(state).length > 0;
  return hasReusableBlock;
}, function (state, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), getBlockTypes()];
});
/**
 * Returns the list of allowed inserter blocks for inner blocks children
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */

export var __experimentalGetAllowedBlocks = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!rootClientId) {
    return;
  }

  return filter(getBlockTypes(), function (blockType) {
    return canIncludeBlockTypeInInserter(state, blockType, rootClientId);
  });
}, function (state, rootClientId) {
  return [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getBlockTypes()];
});
export var __experimentalGetParsedPattern = createSelector(function (state, patternName) {
  var patterns = state.settings.__experimentalBlockPatterns;
  var pattern = patterns.find(function (_ref11) {
    var name = _ref11.name;
    return name === patternName;
  });

  if (!pattern) {
    return null;
  }

  return _objectSpread(_objectSpread({}, pattern), {}, {
    blocks: parse(pattern.content)
  });
}, function (state) {
  return [state.settings.__experimentalBlockPatterns];
});
/**
 * Returns the list of allowed patterns for inner blocks children
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed block types.
 */

export var __experimentalGetAllowedPatterns = createSelector(function (state) {
  var rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var patterns = state.settings.__experimentalBlockPatterns;

  if (!rootClientId) {
    return patterns;
  }

  var parsedPatterns = patterns.map(function (_ref12) {
    var name = _ref12.name;
    return __experimentalGetParsedPattern(state, name);
  });
  var patternsAllowed = filter(parsedPatterns, function (_ref13) {
    var blocks = _ref13.blocks;
    return blocks.every(function (_ref14) {
      var name = _ref14.name;
      return canInsertBlockType(state, name, rootClientId);
    });
  });
  return patternsAllowed;
}, function (state, rootClientId) {
  return [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId]];
});
/**
 * Returns the list of patterns based on specific `scope` and
 * a block's name.
 * `inserter` scope should be handled differently, probably in
 * combination with `__experimentalGetAllowedPatterns`.
 * For now `__experimentalGetScopedBlockPatterns` handles properly
 * all other scopes.
 * Since both APIs are experimental we should revisit this.
 *
 * @param {Object} state Editor state.
 * @param {string} scope Block pattern scope.
 * @param {string} blockName Block's name.
 *
 * @return {Array} The list of matched block patterns based on provided scope and block name.
 */

export var __experimentalGetScopedBlockPatterns = createSelector(function (state, scope, blockName) {
  if (!scope && !blockName) return EMPTY_ARRAY;
  var patterns = state.settings.__experimentalBlockPatterns;
  return patterns.filter(function (pattern) {
    var _pattern$scope, _pattern$scope$scope, _pattern$scope$scope$;

    return (_pattern$scope = pattern.scope) === null || _pattern$scope === void 0 ? void 0 : (_pattern$scope$scope = _pattern$scope[scope]) === null || _pattern$scope$scope === void 0 ? void 0 : (_pattern$scope$scope$ = _pattern$scope$scope.includes) === null || _pattern$scope$scope$ === void 0 ? void 0 : _pattern$scope$scope$.call(_pattern$scope$scope, blockName);
  });
}, function (state) {
  return [state.settings.__experimentalBlockPatterns];
});
/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */

export function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */

export function getSettings(state) {
  return state.settings;
}
/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */

export function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */

export var __experimentalGetBlockListSettingsForBlocks = createSelector(function (state) {
  var clientIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return clientIds.reduce(function (blockListSettingsForBlocks, clientId) {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }

    return _objectSpread(_objectSpread({}, blockListSettingsForBlocks), {}, _defineProperty({}, clientId, state.blockListSettings[clientId]));
  }, {});
}, function (state) {
  return [state.blockListSettings];
});
/**
 * Returns the parsed block saved as shared block with the given ID.
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {Object} The parsed block.
 */

export var __experimentalGetParsedReusableBlock = createSelector(function (state, ref) {
  var reusableBlock = find(getReusableBlocks(state), function (block) {
    return block.id === ref;
  });

  if (!reusableBlock) {
    return null;
  } // Only reusableBlock.content.raw should be used here, `reusableBlock.content` is a
  // workaround until #22127 is fixed.


  return parse(typeof reusableBlock.content.raw === 'string' ? reusableBlock.content.raw : reusableBlock.content);
}, function (state) {
  return [getReusableBlocks(state)];
});
/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */

export var __experimentalGetReusableBlockTitle = createSelector(function (state, ref) {
  var _reusableBlock$title;

  var reusableBlock = find(getReusableBlocks(state), function (block) {
    return block.id === ref;
  });

  if (!reusableBlock) {
    return null;
  }

  return (_reusableBlock$title = reusableBlock.title) === null || _reusableBlock$title === void 0 ? void 0 : _reusableBlock$title.raw;
}, function (state) {
  return [getReusableBlocks(state)];
});
/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */

export function __unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}
/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */

export function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
/**
 * Returns the available reusable blocks
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} Reusable blocks
 */

function getReusableBlocks(state) {
  var _state$settings$__exp, _state$settings;

  return (_state$settings$__exp = state === null || state === void 0 ? void 0 : (_state$settings = state.settings) === null || _state$settings === void 0 ? void 0 : _state$settings.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
}
/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean}     Is navigation mode enabled.
 */


export function isNavigationMode(state) {
  return state.isNavigationMode;
}
/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string}     Client Id of moving block.
 */

export function hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}
/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */

export function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */

export function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */

export function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object} state Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */

export var __experimentalGetActiveBlockIdByBlockNames = createSelector(function (state, validBlockNames) {
  if (!validBlockNames.length) {
    return null;
  } // Check if selected block is a valid entity area.


  var selectedBlockClientId = getSelectedBlockClientId(state);

  if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  } // Check if first selected block is a child of a valid entity area.


  var multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  var entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);

  if (entityAreaParents) {
    // Last parent closest/most interior.
    return last(entityAreaParents);
  }

  return null;
}, function (state, validBlockNames) {
  return [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames];
});
//# sourceMappingURL=selectors.js.map