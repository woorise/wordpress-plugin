{"version":3,"sources":["@wordpress/compose/src/hooks/use-merge-refs/index.js"],"names":["useRef","useCallback","useLayoutEffect","useMergeRefs","refs","element","didElementChange","previousRefs","currentRefs","current","forEach","ref","index","previousRef","value","refsToUpdate","hasOwnProperty"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,eAA9B,QAAqD,oBAArD;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAuBC,IAAvB,EAA8B;AAC5C,MAAMC,OAAO,GAAGL,MAAM,CAAE,IAAF,CAAtB;AACA,MAAMM,gBAAgB,GAAGN,MAAM,CAAE,KAAF,CAA/B;AACA,MAAMO,YAAY,GAAGP,MAAM,CAAEI,IAAF,CAA3B;AACA,MAAMI,WAAW,GAAGR,MAAM,CAAEI,IAAF,CAA1B,CAJ4C,CAM5C;AACA;;AACAI,EAAAA,WAAW,CAACC,OAAZ,GAAsBL,IAAtB,CAR4C,CAU5C;AACA;AACA;;AACAF,EAAAA,eAAe,CAAE,YAAM;AACtBE,IAAAA,IAAI,CAACM,OAAL,CAAc,UAAEC,GAAF,EAAOC,KAAP,EAAkB;AAC/B,UAAMC,WAAW,GAAGN,YAAY,CAACE,OAAb,CAAsBG,KAAtB,CAApB;;AAEA,UACC,OAAOD,GAAP,KAAe,UAAf,IACAA,GAAG,KAAKE,WADR,IAEAP,gBAAgB,CAACG,OAAjB,KAA6B,KAH9B,EAIE;AACDI,QAAAA,WAAW,CAAE,IAAF,CAAX;AACAF,QAAAA,GAAG,CAAEN,OAAO,CAACI,OAAV,CAAH;AACA;AACD,KAXD;AAaAF,IAAAA,YAAY,CAACE,OAAb,GAAuBL,IAAvB;AACA,GAfc,EAeZA,IAfY,CAAf,CAb4C,CA8B5C;AACA;;AACAF,EAAAA,eAAe,CAAE,YAAM;AACtBI,IAAAA,gBAAgB,CAACG,OAAjB,GAA2B,KAA3B;AACA,GAFc,CAAf,CAhC4C,CAoC5C;AACA;;AACA,SAAOR,WAAW,CAAE,UAAEa,KAAF,EAAa;AAChC;AACA;AACAT,IAAAA,OAAO,CAACI,OAAR,GAAkBK,KAAlB;AACAR,IAAAA,gBAAgB,CAACG,OAAjB,GAA2B,IAA3B,CAJgC,CAMhC;AACA;;AACA,QAAMM,YAAY,GAAGD,KAAK,GAAGN,WAAW,CAACC,OAAf,GAAyBF,YAAY,CAACE,OAAhE,CARgC,CAUhC;;AACAM,IAAAA,YAAY,CAACL,OAAb,CAAsB,UAAEC,GAAF,EAAW;AAChC,UAAK,OAAOA,GAAP,KAAe,UAApB,EAAiC;AAChCA,QAAAA,GAAG,CAAEG,KAAF,CAAH;AACA,OAFD,MAEO,IAAKH,GAAG,IAAIA,GAAG,CAACK,cAAJ,CAAoB,SAApB,CAAZ,EAA8C;AACpDL,QAAAA,GAAG,CAACF,OAAJ,GAAcK,KAAd;AACA;AACD,KAND;AAOA,GAlBiB,EAkBf,EAlBe,CAAlB;AAmBA","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useRef, useCallback, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('@wordpress/element').RefObject} RefObject */\n/** @typedef {import('@wordpress/element').RefCallback} RefCallback */\n\n/**\n * Merges refs into one ref callback. Ensures the merged ref callbacks are only\n * called when it changes (as a result of a `useCallback` dependency update) or\n * when the ref value changes. If you don't wish a ref callback to be called on\n * every render, wrap it with `useCallback( ref, [] )`.\n * Dependencies can be added, but when a dependency changes, the old ref\n * callback will be called with `null` and the new ref callback will be called\n * with the same node.\n *\n * @param {Array<RefObject|RefCallback>} refs The refs to be merged.\n *\n * @return {RefCallback} The merged ref callback.\n */\nexport default function useMergeRefs( refs ) {\n\tconst element = useRef( null );\n\tconst didElementChange = useRef( false );\n\tconst previousRefs = useRef( refs );\n\tconst currentRefs = useRef( refs );\n\n\t// Update on render before the ref callback is called, so the ref callback\n\t// always has access to the current refs.\n\tcurrentRefs.current = refs;\n\n\t// If any of the refs change, call the previous ref with `null` and the new\n\t// ref with the node, except when the element changes in the same cycle, in\n\t// which case the ref callbacks will already have been called.\n\tuseLayoutEffect( () => {\n\t\trefs.forEach( ( ref, index ) => {\n\t\t\tconst previousRef = previousRefs.current[ index ];\n\n\t\t\tif (\n\t\t\t\ttypeof ref === 'function' &&\n\t\t\t\tref !== previousRef &&\n\t\t\t\tdidElementChange.current === false\n\t\t\t) {\n\t\t\t\tpreviousRef( null );\n\t\t\t\tref( element.current );\n\t\t\t}\n\t\t} );\n\n\t\tpreviousRefs.current = refs;\n\t}, refs );\n\n\t// No dependencies, must be reset after every render so ref callbacks are\n\t// correctly called after a ref change.\n\tuseLayoutEffect( () => {\n\t\tdidElementChange.current = false;\n\t} );\n\n\t// There should be no dependencies so that `callback` is only called when\n\t// the node changes.\n\treturn useCallback( ( value ) => {\n\t\t// Update the element so it can be used when calling ref callbacks on a\n\t\t// dependency change.\n\t\telement.current = value;\n\t\tdidElementChange.current = true;\n\n\t\t// When an element changes, the current ref callback should be called\n\t\t// with the new element and the previous one with `null`.\n\t\tconst refsToUpdate = value ? currentRefs.current : previousRefs.current;\n\n\t\t// Update the latest refs.\n\t\trefsToUpdate.forEach( ( ref ) => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref && ref.hasOwnProperty( 'current' ) ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t}, [] );\n}\n"]}