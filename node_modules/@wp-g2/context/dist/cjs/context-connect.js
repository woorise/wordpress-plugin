"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contextConnect = contextConnect;
exports.getConnectNamespace = getConnectNamespace;
exports.hasConnectNamespace = hasConnectNamespace;
exports.hasNamespace = exports.getNamespace = void 0;

var _createStyles = require("@wp-g2/create-styles");

var _lodash = require("lodash");

var _react = _interopRequireWildcard(require("react"));

var _constants = require("./constants");

/**
 * Forwards ref (React.ForwardRef) and "Connects" (or registers) a component
 * within the Context system under a specified namespace.
 *
 * This is an (experimental) evolution of the initial connect() HOC.
 * The hope is that we can improve render performance by removing functional
 * component wrappers.
 *
 * @template {import('@wp-g2/create-styles').ViewOwnProps<{}, any>} P
 * @param {import('react').ForwardRefRenderFunction<import('@wp-g2/create-styles').ElementTypeFromViewOwnProps<P>, P>} Component The component to register into the Context system.
 * @param {Array<string>|string} namespace The namespace to register the component under.
 * @param {object} options
 * @param {boolean} [options.memo=true]
 * @return {import('@wp-g2/create-styles').PolymorphicComponent<import('@wp-g2/create-styles').ElementTypeFromViewOwnProps<P>, import('@wp-g2/create-styles').PropsFromViewOwnProps<P>>}
 */
function contextConnect(Component, namespace, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$memo = _options.memo,
      memo = _options$memo === void 0 ? true : _options$memo;
  var WrappedComponent = /*#__PURE__*/(0, _react.forwardRef)(Component);

  if (memo) {
    // @ts-ignore
    WrappedComponent = /*#__PURE__*/_react.default.memo(WrappedComponent);
  }

  var displayName = Array.isArray(namespace) ? namespace[0] : namespace || WrappedComponent.name;

  if (process.env.NODE_ENV === 'development') {
    if (typeof namespace === 'undefined') {
      console.warn('contextConnect', 'Please provide a namespace.');
    }
  }

  var mergedNamespace = WrappedComponent[_constants.CONNECT_STATIC_NAMESPACE] || [displayName];
  /**
   * Consolidate (merge) namespaces before attaching it to the WrappedComponent.
   */

  if (Array.isArray(namespace)) {
    mergedNamespace = [].concat(mergedNamespace, namespace);
  }

  if (typeof namespace === 'string') {
    mergedNamespace = [].concat(mergedNamespace, [namespace]);
  }

  WrappedComponent.displayName = displayName;
  WrappedComponent[_constants.CONNECT_STATIC_NAMESPACE] = (0, _lodash.uniq)(mergedNamespace); // @ts-ignore internal property

  WrappedComponent[_createStyles.INTERPOLATION_CLASS_NAME] = (0, _createStyles.getInterpolatedClassName)(displayName); // @ts-ignore

  return WrappedComponent;
}
/**
 * Attempts to retrieve the connected namespace from a component.
 *
 * @param {import('react').ReactChild | undefined | {}} Component The component to retrieve a namespace from.
 * @returns {Array<string>} The connected namespaces.
 */


function getConnectNamespace(Component) {
  if (!Component) return [];
  var namespaces = [];

  if (Component[_constants.CONNECT_STATIC_NAMESPACE]) {
    namespaces = Component[_constants.CONNECT_STATIC_NAMESPACE];
  } // @ts-ignore


  if (Component.type && Component.type[_constants.CONNECT_STATIC_NAMESPACE]) {
    // @ts-ignore
    namespaces = Component.type[_constants.CONNECT_STATIC_NAMESPACE];
  }

  return namespaces;
}
/**
 * Checks to see if a component is connected within the Context system.
 *
 * @param {import('react').ReactNode} Component The component to retrieve a namespace from.
 * @param {Array<string>|string} match The namespace to check.
 * @returns {boolean} The result.
 */


function hasConnectNamespace(Component, match) {
  if (!Component) return false;

  if (typeof match === 'string') {
    return getConnectNamespace(Component).includes(match);
  }

  if (Array.isArray(match)) {
    return match.some(function (result) {
      return getConnectNamespace(Component).includes(result);
    });
  }

  return false;
}

var getNamespace = getConnectNamespace;
exports.getNamespace = getNamespace;
var hasNamespace = hasConnectNamespace;
exports.hasNamespace = hasNamespace;