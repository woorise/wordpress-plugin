"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isColor = isColor;
exports.getOptimalTextColor = getOptimalTextColor;
exports.getOptimalTextShade = getOptimalTextShade;
Object.defineProperty(exports, "colorize", {
  enumerable: true,
  get: function get() {
    return _tinycolor.default;
  }
});
exports.getComputedColor = exports.getComputedBackgroundColor = void 0;

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _memoize = require("./memoize");

/**
 * A library for color manipulation and conversion.
 *
 * See:
 * https://github.com/bgrins/TinyColor
 */

/** @type {HTMLDivElement} */
var __colorComputationNode;
/**
 * @return {HTMLDivElement | undefined} The HTML element for color computation.
 */


function getColorComputationNode() {
  if (typeof document === 'undefined') return;

  if (!__colorComputationNode) {
    // Create a temporary element for style computation.
    var el = document.createElement('div');
    el.setAttribute('data-g2-color-computation-node', ''); // Inject for window computed style.

    document.body.appendChild(el);
    __colorComputationNode = el;
  }

  return __colorComputationNode;
}
/**
 * @param {string | unknown} value
 *
 * @return {boolean} Whether the value is a valid color.
 */


function isColor(value) {
  if (typeof value !== 'string') return false;
  var test = (0, _tinycolor.default)(value);
  return test.isValid();
}
/**
 * Retrieves the computed background color. This is useful for getting the
 * value of a CSS variable color.
 *
 * @param {string | unknown} color The background color to compute.
 *
 * @return {string} The computed background color.
 */


function __getComputedBackgroundColor(color) {
  var _window;

  if (typeof color !== 'string') return '';
  if (isColor(color)) return color;
  if (!color.includes('var(')) return '';
  if (typeof document === 'undefined') return ''; // Attempts to gracefully handle CSS variables color values.

  var el = getColorComputationNode();
  if (!el) return '';
  el.style.background = color; // Grab the style

  var computedColor = (_window = window) == null ? void 0 : _window.getComputedStyle(el).background; // Reset

  el.style.background = '';
  return computedColor || '';
}
/**
 * Retrieves the computed background color. This is useful for getting the
 * value of a CSS variable color.
 *
 * @param {string | unknown} color The background color to compute.
 *
 * @return {string} The computed background color.
 */


var getComputedBackgroundColor = (0, _memoize.memoize)(__getComputedBackgroundColor);
/**
 * Retrieves the computed text color. This is useful for getting the
 * value of a CSS variable color.
 *
 * @param {string | unknown} color
 *
 * @return {string} The computed text color.
 */

exports.getComputedBackgroundColor = getComputedBackgroundColor;

function __getComputedColor(color) {
  var _window2;

  if (typeof color !== 'string') return '';
  if (isColor(color)) return color;
  if (!color.includes('var(')) return '';
  if (typeof document === 'undefined') return ''; // Attempts to gracefully handle CSS variables color values.

  var el = getColorComputationNode();
  if (!el) return '';
  el.style.color = color; // Grab the style

  var computedColor = (_window2 = window) == null ? void 0 : _window2.getComputedStyle(el).color; // Reset

  el.style.color = '';
  return computedColor || '';
}
/**
 * Retrieves the computed text color. This is useful for getting the
 * value of a CSS variable color.
 *
 * @param {string | unknown} color
 *
 * @return {string} The computed text color.
 */


var getComputedColor = (0, _memoize.memoize)(__getComputedColor);
/**
 * Get the text shade optimized for readability, based on a background color.
 *
 * @param {string | unknown} color  The background color.
 *
 * @return {string} The optimized text color (black or white).
 */

exports.getComputedColor = getComputedColor;

function getOptimalTextColor(color) {
  var background = getComputedBackgroundColor(color);

  var isReadableWithBlackText = _tinycolor.default.isReadable(background, '#000000');

  return isReadableWithBlackText ? '#000000' : '#ffffff';
}
/**
 * Get the text shade optimized for readability, based on a background color.
 *
 * @param {string | unknown} color The background color.
 *
 * @return {string} The optimized text shade (dark or light).
 */


function getOptimalTextShade(color) {
  var result = getOptimalTextColor(color);
  return result === '#000000' ? 'dark' : 'light';
}