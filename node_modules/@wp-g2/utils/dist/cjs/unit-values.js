"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParsedValue = getParsedValue;
exports.hasUnits = hasUnits;
exports.parseUnitValue = parseUnitValue;
exports.createUnitValue = createUnitValue;
exports.isValidNumericUnitValue = exports.isValidCSSValueForProp = exports.getParsedCSSValue = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _is = require("./is");

/**
 * Internal dependencies
 */
var __styleTestNode = null;

var getComputedStyledMap = function () {
  // For SSR
  if (typeof window === 'undefined') return {};

  if (!__styleTestNode) {
    __styleTestNode = document.createElement('div');
  }

  return __styleTestNode.style;
};
/**
 * Gets the value to be applied to the CSS Object Model.
 *
 * @param {string} initialValue
 *
 * @return {number | string | undefined} The parsed CSS value.
 */


var getParsedCSSValue = function (initialValue) {
  var _parseUnitValue = parseUnitValue(initialValue),
      _parseUnitValue2 = (0, _slicedToArray2.default)(_parseUnitValue, 2),
      value = _parseUnitValue2[0],
      unit = _parseUnitValue2[1];

  var next = !unit ? value : "" + value + unit;
  return next;
};
/**
 * Checks if a value is valid given a CSS prop.
 *
 * @param {string} prop
 * @param {string} value
 *
 * @return {boolean} Whether the value is a valid CSS value.
 */


exports.getParsedCSSValue = getParsedCSSValue;

var isValidCSSValueForProp = function (prop, value) {
  // For SSR
  if (typeof window === 'undefined') return true;
  if (typeof prop !== 'string') return true;
  var computedStyleMap = getComputedStyledMap();
  if (_is.is.undefined(computedStyleMap[prop])) return true; // 1. Reset current style value.

  computedStyleMap[prop] = ''; // 2. Cache current style value for validation (may not be an empty string).

  var current = computedStyleMap[prop]; // 3. Apply next value.

  var next = getParsedCSSValue(value);
  computedStyleMap[prop] = next; // 4. Check to see if next value was correctly applied.

  return current !== computedStyleMap[prop];
};
/**
 * Checks a value to see if it is a valid numeric unit value.
 *
 * Examples of valid numeric unit values include:
 * 0px, 1em, 0, -1, 12.5px
 *
 * @param {string} value
 *
 * @return {boolean} Whether the value is a valid numeric unit value.
 */


exports.isValidCSSValueForProp = isValidCSSValueForProp;

var isValidNumericUnitValue = function (value) {
  // Disallow values that contains spaces
  if (/ /g.test(value)) {
    return false;
  } // Disallow values that start with 0 that isn't a decimal.


  if (/^0[0-9]/g.test(value)) {
    return false;
  } // Disallow values where the last character is a symbol


  if (/[-!$^&*()_+|~=`{}[\]:";'<>?,./]$/g.test(value)) {
    return false;
  } // Allow numerics.


  if (_is.is.numeric(value)) return true; // Disallow values that do not start with alphanumeric characters.

  if (/^\W/g.test(value)) {
    // Allow for negative numbers, e.g. -1
    if (!/^-\w/g.test(value)) {
      return false;
    }
  } // Disallow values where a dot follows a character, e.g. 1.p


  if (/\.[a-zA-Z]/g.test(value)) {
    return false;
  } // Disable values where there are multiple . chracters.


  if (/\d+\.\d+\.\d+/g.test(value)) {
    return false;
  }

  return true;
};
/**
 * Handles legacy value + unit handling.
 * This component use to manage both incoming value and units separately.
 *
 * Moving forward, ideally the value should be a string that contains both
 * the value and unit, example: '10px'
 *
 * @param {number|string} value Value
 * @param {string} unit Unit value
 *
 * @return {ReturnType<parseUnitValue>} The extracted number and unit.
 */


exports.isValidNumericUnitValue = isValidNumericUnitValue;

function getParsedValue(value, unit) {
  var initialValue = unit ? "" + value + unit : value;
  return parseUnitValue(initialValue);
}
/**
 * Checks if units are defined.
 *
 * @param {any} units Units to check.
 *
 * @return {boolean} Whether units are defined.
 */


function hasUnits(units) {
  return !_is.is.empty(units) && units.length > 1 && units !== false;
}
/**
 * Parses a number and unit from a value.
 *
 * @param {string | number} initialValue Value to parse
 *
 * @return {[number | string | undefined, string | undefined]} The extracted number and unit.
 */


function parseUnitValue(initialValue) {
  if (!_is.is.defined(initialValue)) {
    return [undefined, undefined];
  }

  var value = String(initialValue).trim();
  /** @type {string | number} */

  var num = parseFloat(value);
  num = _is.is.nan(num) ? '' : num;
  var matched = value.match(/[\d.\-+]*\s*(.*)/);

  if (!matched) {
    return [undefined, undefined];
  }

  var _matched = (0, _slicedToArray2.default)(matched, 2),
      unitMatch = _matched[1];

  var unit = _is.is.defined(unitMatch) ? unitMatch : '';
  unit = unit.toLowerCase();
  return [num, unit];
}
/**
 * Combines a value and a unit into a unit value.
 *
 * @param {string | number} value
 * @param {string} [unit]
 *
 * @return {string} The unit value.
 */


function createUnitValue(value, unit) {
  if (!unit || typeof unit !== 'string' || !_is.is.numeric(value)) {
    return value.toString();
  }

  return "" + value + unit;
}