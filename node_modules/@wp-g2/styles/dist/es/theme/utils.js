import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { get } from '@wp-g2/create-styles';
import { REDUCED_MOTION_MODE_ATTR } from '@wp-g2/create-styles';
import { colorize } from '@wp-g2/utils';
/**
 * @template T
 * @param {T | number} value
 * @return {T | string}
 */

export function space(value) {
  return typeof value === 'number' ? "calc(" + get('gridBase') + " * " + value + ")" : value;
}
export function getIsReducedMotion() {
  return !!document.querySelector(REDUCED_MOTION_MODE_ATTR);
}
/**
 * @param {Record<string, import('tinycolor2').ColorInput>} colors
 * @return {Record<string, import('tinycolor2').ColorInput>}
 */

export function createTextColors(colors) {
  /** @type {Record<string, string>} */
  var colorSet = {};
  var entries = Object.entries(colors);
  var light = entries[0][1];
  var lighter = colorize(light).lighten(15).toHexString();
  var dark = entries[entries.length - 1][1];
  var darker = colorize(dark).darken(15).toHexString();

  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
    var _ref3 = _entries[_i];

    var _ref2 = _slicedToArray(_ref3, 2);

    var color = _ref2[0];
    var value = _ref2[1];
    colorSet[color + "Text"] = colorize.mostReadable(value, [lighter, light, dark, darker]).toHexString();
  }

  return colorSet;
}
/**
 *
 * @param {Record<string, import('tinycolor2').ColorInput>} colors
 * @param {boolean} [isDark=false]
 * @return {Record<string, import('tinycolor2').ColorInput>}
 */

export function createRgbaColors(colors, isDark) {
  if (isDark === void 0) {
    isDark = false;
  }

  /** @type {Record<string, import('tinycolor2').ColorInput>} */
  var colorSet = {};
  var entries = Object.entries(colors);

  var _entries$ = _slicedToArray(entries[2], 2),
      baseColorName = _entries$[0],
      baseColorValue = _entries$[1];

  var _baseColorName$split = baseColorName.split(/\d+/),
      _baseColorName$split2 = _slicedToArray(_baseColorName$split, 1),
      colorName = _baseColorName$split2[0];

  var mixBase = isDark ? '#000' : '#fff';
  var readabilityTextBase = isDark ? '#fff' : '#000';
  var adjustMethod = isDark ? 'darken' : 'lighten';
  [10, 20, 30, 40, 50, 60, 70, 80, 90].forEach(function (range, index) {
    var enhancedColorValue = baseColorValue;
    enhancedColorValue = colorize(enhancedColorValue).setAlpha(range / 100).toRgbString();
    var testColor = colorize.mix(baseColorValue, mixBase, index).toRgbString();
    var isReadable = colorize.isReadable(testColor, readabilityTextBase, {});

    if (!isReadable) {
      enhancedColorValue = colorize(enhancedColorValue)[adjustMethod](20).toRgbString();
    }

    colorSet[colorName + "Rgba" + range] = enhancedColorValue;
  });
  return colorSet;
}
/**
 * @param {string} key
 * @param {import('tinycolor2').ColorInput} color
 * @return {Record<string, import('tinycolor2').ColorInput>}
 */

export function generateRgbColors(key, color) {
  var _colorSet;

  /** @type {Record<string, import('tinycolor2').ColorInput>} */
  var colorSet = (_colorSet = {}, _colorSet[key] = color, _colorSet);
  [10, 20, 30, 40, 50, 60, 70, 80, 90].forEach(function (index) {
    colorSet[key + "Rgba" + index] = colorize(color).setAlpha(index / 100).toRgbString();
  });
  return colorSet;
}
/**
 * @param {import('tinycolor2').ColorInput} color
 */

export function generateColorAdminColors(color) {
  return generateRgbColors('colorAdmin', color);
}
/**
 * @param {import('tinycolor2').ColorInput} color
 */

export function generateColorDestructiveColors(color) {
  return generateRgbColors('colorDestructive', color);
}