import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { getDisplayName, hoistNonReactStatics, is } from '@wp-g2/utils';
import React from 'react';
import { INTERPOLATION_CLASS_NAME } from './constants';
import { tags } from './tags';
import { compileInterpolatedStyles, getInterpolatedClassName } from './utils';
/**
 * @typedef CreateStyledComponentsProps
 * @property {import('../create-compiler').Compiler} compiler The (custom) Emotion instance.
 * @property {import('./polymorphic-component').CoreElements} core The collection of coreElements.
 */

/**
 * Creates a set of styled components for the Style system.
 * These styled components are similarly to Emotion's or Styled-Components styled.div``.
 *
 * A big difference is that the Style system's styled components do NOT require
 * context connection at all. This is HUGE for performance as there are far less
 * React.Component nodes within the render tree.
 *
 * This is thanks to how the Style system compiles and coordinates style values.
 *
 * @param {CreateStyledComponentsProps} props Props to create styled components with.
 * @returns {import('./polymorphic-component').CreateStyled} A set of styled components.
 */

export function createStyledComponents(_ref) {
  var compiler = _ref.compiler,
      core = _ref.core;
  var css = compiler.css,
      cx = compiler.cx,
      generateInterpolationName = compiler.generateInterpolationName;
  /**
   * That's all a <Box /> is :). A core.div.
   */

  var Box = core.div;

  function createStyled(tagName, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        extraProps = _options.props;
    return function () {
      for (var _len = arguments.length, interpolatedProps = new Array(_len), _key = 0; _key < _len; _key++) {
        interpolatedProps[_key] = arguments[_key];
      }

      var interpolationClassName = getInterpolatedClassName(generateInterpolationName());
      /** @type {import('react').ForwardRefRenderFunction<any, any>} */

      /** @type {React.ForwardRefExoticComponent<Pick<any, string | number | symbol> & React.RefAttributes<any>> & { withComponent?: ReturnType<createStyled> }} */
      var StyledComponent = /*#__PURE__*/React.forwardRef(function render(_ref2, ref) {
        var asProp = _ref2.as,
            className = _ref2.className,
            props = _objectWithoutProperties(_ref2, ["as", "className"]);

        // Combine all of the props together.
        var mergedProps = _objectSpread(_objectSpread(_objectSpread({}, extraProps), props), {}, {
          ref: ref
        });

        // Resolves prop interpolation.
        var interpolatedStyles = compileInterpolatedStyles(interpolatedProps, props);
        var classes = cx(css.apply(void 0, interpolatedStyles), className, interpolationClassName);
        return /*#__PURE__*/React.createElement(Box, Object.assign({
          as: asProp || tagName
        }, mergedProps, {
          className: classes
        }));
      });
      /*
       * Enhancing the displayName.
       */

      StyledComponent.displayName = typeof tagName === 'string' ? "Styled(" + getDisplayName(tagName) + ")" : is.defined(tagName == null ? void 0 : tagName.displayName) ? tagName.displayName : "Styled(" + getDisplayName(tagName) + ")";
      /*
       * Enhancing .withComponent()
       * https://github.com/emotion-js/emotion/blob/master/packages/styled-base/src/index.js#L210
       *
       * This step is essential as we want styled components generated with
       * .withComponent to have the correct baseStyles.
       */

      StyledComponent.withComponent = function (nextTag, nextOptions) {
        return createStyled(nextTag, nextOptions !== undefined ? _objectSpread(_objectSpread({}, options || {}), nextOptions) : options).apply(void 0, interpolatedProps);
      }; // @ts-ignore internal property


      StyledComponent[INTERPOLATION_CLASS_NAME] = interpolationClassName;

      if (typeof tagName !== 'string') {
        /*
         * Hoisting statics one last time, if the tagName is a Component,
         * rather than an HTML tag, like `div`.
         */
        return hoistNonReactStatics(StyledComponent, tagName);
      } else {
        return StyledComponent;
      }
    };
  } // Bind it to avoid mutating the original function. Just like @emotion/styled:
  // https://github.com/emotion-js/emotion/blob/master/packages/styled/src/index.js


  var styled = createStyled.bind(undefined); // Generating the core collection of styled[tagName], with our enhanced
  // version of styled.

  tags.forEach(function (tagName) {
    styled[tagName] = createStyled(tagName);
  }); // @ts-ignore We cannot convince TypeScript that we've taken care of everything here, we're doing too many JavaScript magics for this to work without an ignore

  return styled;
}