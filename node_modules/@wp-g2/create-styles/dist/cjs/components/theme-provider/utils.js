"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useColorBlindMode = useColorBlindMode;
exports.useDarkMode = useDarkMode;
exports.useHighContrastMode = useHighContrastMode;
exports.useReducedMotionMode = useReducedMotionMode;
exports.useThemeStyles = useThemeStyles;

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteralLoose"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _isShallowEqual = require("@wordpress/is-shallow-equal");

var _utils = require("@wp-g2/utils");

var _react = require("react");

var _utils2 = require("../../create-style-system/utils");

var _hooks = require("../../hooks");

var _useThemeStylesStore3 = _interopRequireWildcard(require("./use-theme-styles-store"));

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", ""]);

  _templateObject = function () {
    return data;
  };

  return data;
}

/**
 * @typedef UseColorBlindModeProps
 * @property {boolean} isGlobal Determines if the theme styles are rendered globally or scoped locally.
 * @property {boolean} isColorBlind Determines if color-blind-mode styles should be rendered.
 * @property {import('react').RefObject<HTMLElement | undefined>} ref React ref.
 */

/**
 * Hook that sets the Style system's color-blind mode.
 * @param {UseColorBlindModeProps} props Props for the hook.
 */
function useColorBlindMode(_ref) {
  var isColorBlind = _ref.isColorBlind,
      _ref$isGlobal = _ref.isGlobal,
      isGlobal = _ref$isGlobal === void 0 ? true : _ref$isGlobal,
      ref = _ref.ref;
  (0, _react.useEffect)(function () {
    if (!_utils.is.defined(isColorBlind)) return;
    var target = document.documentElement;

    if (!isGlobal && ref.current) {
      target = ref.current;
    }

    if (isColorBlind) {
      target.setAttribute('data-system-ui-color-blind-mode', 'true');
    } else {
      target.setAttribute('data-system-ui-color-blind-mode', 'false');
    }
  }, [isGlobal, isColorBlind, ref]);
}
/**
 * @typedef UseDarkModeProps
 * @property {boolean} isGlobal Determines if the theme styles are rendered globally or scoped locally.
 * @property {boolean} isDark Determines if dark-mode styles should be rendered.
 * @property {import('react').RefObject<HTMLElement | undefined>} ref React ref.
 */

/**
 * Hook that sets the Style system's dark mode.
 * @param {UseDarkModeProps} props Props for the hook.
 */


function useDarkMode(_ref2) {
  var isDark = _ref2.isDark,
      _ref2$isGlobal = _ref2.isGlobal,
      isGlobal = _ref2$isGlobal === void 0 ? true : _ref2$isGlobal,
      ref = _ref2.ref;
  (0, _react.useEffect)(function () {
    if (!_utils.is.defined(isDark)) return;
    var target = document.documentElement;

    if (!isGlobal && ref.current) {
      target = ref.current;
    }

    if (isDark) {
      target.setAttribute('data-system-ui-mode', 'dark');
    } else {
      target.setAttribute('data-system-ui-mode', 'light');
    }
  }, [isGlobal, isDark, ref]);
}
/**
 * @typedef UseHighContrastMode
 * @property {boolean} isGlobal Determines if the theme styles are rendered globally or scoped locally.
 * @property {boolean} isHighContrast Determines if high-contrast styles should be rendered.
 * @property {import('react').RefObject<HTMLElement | undefined>} ref React ref.
 */

/**
 * Hook that sets the Style system's high-contrast mode.
 * @param {UseHighContrastMode} props Props for the hook.
 */


function useHighContrastMode(_ref3) {
  var _ref3$isGlobal = _ref3.isGlobal,
      isGlobal = _ref3$isGlobal === void 0 ? true : _ref3$isGlobal,
      isHighContrast = _ref3.isHighContrast,
      ref = _ref3.ref;
  (0, _react.useEffect)(function () {
    if (!_utils.is.defined(isHighContrast)) return;
    var target = document.documentElement;

    if (!isGlobal && ref.current) {
      target = ref.current;
    }

    if (isHighContrast) {
      target.setAttribute('data-system-ui-contrast-mode', 'high');
    } else {
      target.setAttribute('data-system-ui-contrast-mode', 'normal');
    }
  }, [isGlobal, isHighContrast, ref]);
}
/**
 * @typedef UseReducedMotionProps
 * @property {boolean} isGlobal Determines if the theme styles are rendered globally or scoped locally.
 * @property {boolean} isReducedMotion Determines if reduced-motion styles should be rendered.
 * @property {import('react').RefObject<HTMLElement | undefined>} ref React ref.
 */

/**
 * Hook that sets the Style system's reduced-motion mode.
 * @param {UseReducedMotionProps} props Props for the hook.
 */


function useReducedMotionMode(_ref4) {
  var _ref4$isGlobal = _ref4.isGlobal,
      isGlobal = _ref4$isGlobal === void 0 ? true : _ref4$isGlobal,
      isReducedMotion = _ref4.isReducedMotion,
      ref = _ref4.ref;

  var _useReducedMotion = (0, _hooks.useReducedMotion)(),
      _useReducedMotion2 = (0, _slicedToArray2.default)(_useReducedMotion, 2),
      setIsReducedMotion = _useReducedMotion2[1];

  (0, _react.useEffect)(function () {
    if (isGlobal) {
      setIsReducedMotion(!!isReducedMotion);
    }
  }, [isGlobal, isReducedMotion, setIsReducedMotion]);
  (0, _react.useEffect)(function () {
    if (!_utils.is.defined(isReducedMotion)) return;
    var target = document.documentElement;

    if (!isGlobal && ref.current) {
      target = ref.current;
    }

    if (isReducedMotion) {
      target.setAttribute('data-system-ui-reduced-motion-mode', 'true');
    } else {
      target.setAttribute('data-system-ui-reduced-motion-mode', 'false');
    }
  }, [isGlobal, isReducedMotion, ref]);
}
/**
 * @typedef UseThemeStyles
 * @property {import('create-emotion').Emotion['injectGlobal']} injectGlobal
 * @property {boolean} isGlobal Determines if the theme styles are rendered globally or scoped locally.
 * @property {Record<string, string>} theme Custom theme values.
 * @property {string} selector
 */

/**
 * Hook that sets the Style system's theme.
 * @param {UseThemeStyles} props Props for the hook.
 * @return {string}
 */


function useThemeStyles(_ref5) {
  var injectGlobal = _ref5.injectGlobal,
      _ref5$isGlobal = _ref5.isGlobal,
      isGlobal = _ref5$isGlobal === void 0 ? true : _ref5$isGlobal,
      _ref5$theme = _ref5.theme,
      theme = _ref5$theme === void 0 ? {} : _ref5$theme,
      _ref5$selector = _ref5.selector,
      selector = _ref5$selector === void 0 ? ':root' : _ref5$selector;

  var _useThemeStylesStore = (0, _useThemeStylesStore3.default)(),
      _useThemeStylesStore2 = (0, _slicedToArray2.default)(_useThemeStylesStore, 2),
      themeStyles = _useThemeStylesStore2[0].theme,
      dispatch = _useThemeStylesStore2[1];
  /**
   * Used to track/compare changes for theme prop changes.
   */

  /** @type {import('react').MutableRefObject<object | undefined>} */


  var themeRef = (0, _react.useRef)();
  /**
   * Work-around to inject a global theme style. This makes it compatible with
   * SSR solutions, as injectGlobal is understood by Emotion's SSR flow.
   */

  var didInjectGlobalStyles = (0, _react.useRef)(false);

  if (!didInjectGlobalStyles.current && isGlobal && theme) {
    if (typeof injectGlobal === 'function') {
      try {
        var globalStyles = (0, _utils2.transformValuesToVariablesString)(selector, theme, isGlobal);
        injectGlobal(_templateObject(), globalStyles);
      } catch (err) {// eslint-disable-next-line
      }
    }

    didInjectGlobalStyles.current = true;
  }

  (0, _utils.useIsomorphicLayoutEffect)(function () {
    /**
     * We only want to update + set the theme if there's a change.
     * Since themes (potentially) be nested, we need to do a shallowEqual check.
     */
    if (themeRef.current && theme && (0, _isShallowEqual.isShallowEqualObjects)(themeRef.current, theme)) return;
    themeRef.current = theme;
    /**
     * This compiles the theme config (object) into CSS variables that
     * the Style system understands and can be retrieved using the get() function.
     */

    var styleNode = getStyleNode();
    var nextThemeHtml = (0, _utils2.transformValuesToVariablesString)(selector, theme, isGlobal);

    if (isGlobal) {
      /**
       * If isGlobal is preferred, we need to set the custom CSS variables onto
       * the root element.
       */
      if (styleNode) {
        styleNode.innerHTML = nextThemeHtml;
      }
    } else {
      /**
       * Otherwise, we can set it to the themeStyles state, which will be
       * rendered as custom properties on the ThemeProvider (HTMLDivElement).
       */
      dispatch((0, _useThemeStylesStore3.setTheme)(nextThemeHtml));
    }
  }, [injectGlobal, isGlobal, dispatch, theme]);
  return themeStyles;
}

function getStyleNode() {
  var id = 'StyleSystemThemeProviderStyleNode';
  var node = document.getElementById(id);
  if (node) return node;
  node = document.createElement('style');
  node.id = id;
  node.setAttribute('data-g2-theme-provider', 'theme');
  var headNode = document.querySelector('head');

  if (headNode) {
    headNode.appendChild(node);
  }

  return node;
}