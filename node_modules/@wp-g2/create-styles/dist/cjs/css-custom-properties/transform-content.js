"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFallbackDeclaration = getFallbackDeclaration;
exports.baseTransformContent = baseTransformContent;
exports.transformContent = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _utils = require("@wp-g2/utils");

var _getPropValue3 = require("./get-prop-value");

var _utils2 = require("./utils");

/**
 * Interprets and retrieves the CSS fallback value of a declaration rule.
 *
 * @param {string} declaration A CSS declaration rule to parse.
 * @param {object} rootStore A store for CSS root variables.
 * @returns {string | undefined} A CSS declaration rule with a fallback (if applicable).
 */
function getFallbackDeclaration(declaration, rootStore) {
  if (!(0, _utils2.hasVariable)(declaration) && !(0, _utils2.isCustomProperty)(declaration)) return undefined;

  var _getPropValue = (0, _getPropValue3.getPropValue)(declaration, rootStore),
      _getPropValue2 = (0, _slicedToArray2.default)(_getPropValue, 2),
      prop = _getPropValue2[0],
      value = _getPropValue2[1];

  return value ? [prop, value].join(':') : undefined;
}
/**
 * Parses the incoming content from stylis to add fallback CSS values for
 * variables.
 *
 * @param {string} content Stylis content to parse.
 * @param {object} rootStore A store for CSS root variables.
 * @return {string | undefined} The transformed content with CSS variable fallbacks.
 */


function baseTransformContent(content, rootStore) {
  /*
   * Attempts to deconstruct the content to retrieve prop/value
   * CSS declaration pairs.
   *
   * Before:
   * 'background-color:var(--bg, black); font-size:14px;'
   *
   * After:
   * ['background-color:var(--bg, black)', ' font-size:14px']
   */
  var declarations = content.split(';').filter(Boolean);
  var didTransform = false;
  /*
   * With the declaration collection, we'll iterate over every declaration
   * to provide fallbacks (if applicable.)
   */

  var parsed = declarations.reduce(function (
  /** @type {string[]} */
  styles,
  /** @type {string} */
  declaration) {
    // If no CSS variable is used, we return the declaration untouched.
    if (!(0, _utils2.hasVariable)(declaration)) {
      return [].concat(styles, [declaration]);
    } // Retrieve the fallback a CSS variable is used in this declaration.


    var fallback = getFallbackDeclaration(declaration, rootStore);
    /*
     * Prepend the fallback in our styles set.
     *
     * Before:
     * [
     * 	 ...styles,
     *   'background-color:var(--bg, black);'
     * ]
     *
     * After:
     * [
     * 	 ...styles,
     *   'background:black;',
     *   'background-color:var(--bg, black);'
     * ]
     */

    if (fallback) {
      didTransform = true;
      return [].concat(styles, [fallback, declaration]);
    }

    return [].concat(styles, [declaration]);
  }, []);
  /*
   * We'll rejoin our declarations with a ; separator.
   * Note: We need to add a ; at the end for stylis to interpret correctly.
   */

  var result = parsed.join(';').concat(';'); // We only want to return a value if we're able to locate a fallback value.

  return didTransform ? result : undefined;
}

var transformContent = (0, _utils.memoize)(baseTransformContent);
exports.transformContent = transformContent;