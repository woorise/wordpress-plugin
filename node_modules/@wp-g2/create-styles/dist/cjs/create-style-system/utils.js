"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createToken = createToken;
exports.get = get;
exports.transformValuesToReferences = transformValuesToReferences;
exports.transformValuesToVariables = transformValuesToVariables;
exports.transformValuesToVariablesString = transformValuesToVariablesString;
exports.compileInterpolatedStyles = compileInterpolatedStyles;
exports.getInterpolatedClassName = getInterpolatedClassName;
exports.DEFAULT_STYLE_SYSTEM_OPTIONS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _hash = _interopRequireDefault(require("@emotion/hash"));

var _utils = require("@wp-g2/utils");

var _lodash = require("lodash");

var _constants = require("./constants");

/**
 * @type {{
	baseStyles: any;
	config: any;
	darkModeConfig: any;
	highContrastModeConfig: any;
	darkHighContrastModeConfig: any;
	compilerOptions: any;
	}}
 */
var DEFAULT_STYLE_SYSTEM_OPTIONS = {
  baseStyles: {},
  config: {},
  darkModeConfig: {},
  highContrastModeConfig: {},
  darkHighContrastModeConfig: {},
  compilerOptions: undefined
};
/**
 * Creates the (CSS Variable) design token used by the Style system.
 *
 * @param {string} key The variable (key).
 * @returns {string} The token (CSS variable).
 */

exports.DEFAULT_STYLE_SYSTEM_OPTIONS = DEFAULT_STYLE_SYSTEM_OPTIONS;

function createToken(key) {
  return _constants.NAMESPACE + "-" + (0, _lodash.kebabCase)(key);
}
/**
 * The primary mechanism to retrieve Style system configs values - values that
 * have been transformed into CSS variables with a dedicated namespace.
 *
 * @example
 * ```js
 * get('colorAdmin'); // var(--wp-g2-color-admin, 'blue');
 * ```
 * @template {Record<string, string | number>} TConfig
 * @template {Record<string, string | number>} TDarkConfig
 * @template {Record<string, string | number>} THCConfig
 * @template {Record<string, string | number>} TDarkHCConfig
 * @template {string} TGeneratedTokens
 * @param {keyof (TConfig & TDarkConfig & THCConfig & TDarkHCConfig) | TGeneratedTokens} key The config variable to retrieve.
 * @returns {string} The compiled CSS variable associated with the config key.
 */


function get(key) {
  return "var(" + createToken(key.toString()) + ")";
}
/** @typedef {Record<string, string | number>} StyleConfigValues */

/** @typedef {Record<string, string>} StyleConfig */

/**
 * Transforms a series of config values into set of namespaced CSS
 * references for the Style system.
 *
 * @param {StyleConfigValues} values Style config values to transform into CSS variables.
 * @returns {StyleConfig} The set of CSS variables, transformed from config values.
 */


function transformValuesToReferences(values) {
  if (values === void 0) {
    values = {};
  }

  /** @type {StyleConfig} */
  var next = {};

  for (var _i = 0, _Object$entries = Object.entries(values); _i < _Object$entries.length; _i++) {
    var _ref3 = _Object$entries[_i];

    var _ref2 = (0, _slicedToArray2.default)(_ref3, 2);

    var key = _ref2[0];
    var value = _ref2[1];
    var ref = "var(" + createToken(key) + ", " + value + ")";
    next[key] = ref;
  }

  return next;
}
/**
 * Transforms a series of config values into set of namespaced CSS
 * variables for the Style system. These values can then be safely and predictable
 * retrieved using the get() function.
 *
 * @param {StyleConfigValues} values Style config values to transform into CSS variables.
 * @returns {StyleConfig} The set of CSS variables, transformed from config values.
 */


function transformValuesToVariables(values) {
  if (values === void 0) {
    values = {};
  }

  /** @type {StyleConfig} */
  var next = {};

  for (var _i2 = 0, _Object$entries2 = Object.entries(values); _i2 < _Object$entries2.length; _i2++) {
    var _ref6 = _Object$entries2[_i2];

    var _ref5 = (0, _slicedToArray2.default)(_ref6, 2);

    var key = _ref5[0];
    var value = _ref5[1];
    var ref = value;
    next["" + createToken(key)] = ref == null ? void 0 : ref.toString();
  }

  return next;
}
/**
 * Transforms a series of config values into set of namespaced CSS
 * references for the Style system. These values are then transformed into
 * a CSS style value (`string`) that can be injected into the DOM, within a
 * <style> tag.
 *
 * @param {string} [selector=':root'] The selector to attach the config values to.
 * @param {StyleConfigValues} values Style config values to transform into CSS variables.
 * @returns {string} Compiled innerHTML styles to be injected into a <style /> tag.
 */


function transformValuesToVariablesString(selector, values, isGlobal) {
  if (selector === void 0) {
    selector = ':root';
  }

  if (values === void 0) {
    values = {};
  }

  if (isGlobal === void 0) {
    isGlobal = true;
  }

  var variables = transformValuesToVariables(values);
  var next = [];
  var needsTerminator = false;

  if (isGlobal) {
    next.push(selector + " {");
    needsTerminator = true;
  } else {
    if (selector !== ':root') {
      next.push("&" + selector + " {");
      needsTerminator = true;
    }
  }

  for (var _i3 = 0, _Object$entries3 = Object.entries(variables); _i3 < _Object$entries3.length; _i3++) {
    var _ref9 = _Object$entries3[_i3];

    var _ref8 = (0, _slicedToArray2.default)(_ref9, 2);

    var key = _ref8[0];
    var value = _ref8[1];
    var ref = value;

    if (_utils.is.defined(ref) && !_utils.is.boolean(ref)) {
      next.push(key + ": " + ref + ";");
    }
  }

  if (needsTerminator) {
    next.push('}');
  }

  return next.join('');
}
/**
 *
 * @param {any} value
 * @return {value is import('../create-style-system/polymorphic-component').PolymorphicComponent<any, any>}
 */


function isPolymorphicComponent(value) {
  return value && typeof value[_constants.INTERPOLATION_CLASS_NAME] !== 'undefined';
}
/**
 * Resolves and compiles interpolated CSS styles for styled-components.
 * Allows for prop (function) interpolation within the style rules.
 *
 * For more information on tagged template literals, check out:
 * https://mxstbr.blog/2016/11/styled-components-magic-explained/
 *
 * @template TProps
 * @param {(string | ((props: TProps) => string) | import('../create-style-system/polymorphic-component').PolymorphicComponent<any, any>)[]} interpolatedStyles The interpolated styles from a Styled component.
 * @param {TProps} props Incoming component props.
 * @returns {string[]} Compiled CSS style rules.
 */


function compileInterpolatedStyles(interpolatedStyles, props) {
  var compiledStyles = interpolatedStyles.map(function (a) {
    if (isPolymorphicComponent(a)) {
      return "." + a[_constants.INTERPOLATION_CLASS_NAME];
    }

    return typeof a === 'function' ? a(props) : a;
  });
  return compiledStyles;
}
/**
 * Creates an interpolated className. This is used when styled components are
 * interpolated in the template literal.
 *
 * @param {string} displayName The displayName of the component.
 * @returns {string} The interpolated className.
 */


function getInterpolatedClassName(displayName) {
  return typeof displayName === 'string' ? "ic-" + (0, _hash.default)(displayName) : '';
}