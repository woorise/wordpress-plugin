import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { useContextSystem } from '@wp-g2/context';
import { simpleEqual, useSealedState, useUpdateEffect } from '@wp-g2/utils';
import { noop, uniq } from 'lodash';
import { useCallback, useMemo, useReducer } from 'react';
import { useAccordionContext } from './Accordion.Context';
/**
 * @param {any} current
 * @returns {current is any[] | string}
 */

var isCurrentValid = function (current) {
  return Array.isArray(current) || typeof current === 'string';
};
/**
 * @param {string[]} next
 */


var sanitizeState = function (next) {
  return uniq(next.filter(Boolean));
};
/**
 * @param {string[]} prev
 * @param {string | string[]} next
 */


var setCurrentState = function (prev, next) {
  if (prev === void 0) {
    prev = [];
  }

  if (!isCurrentValid(next)) return prev;
  var nextState = Array.isArray(next) ? [].concat(prev, next) : [].concat(prev, [next]);
  return sanitizeState(nextState);
};
/**
 * @typedef State
 * @property {boolean} allowMultiple
 * @property {string[]} current
 * @property {boolean} isWithinContext
 */

/**
 * @param {State} initialState
 * @returns {State}
 */


function useInitialState(_ref) {
  var _ref$allowMultiple = _ref.allowMultiple,
      allowMultiple = _ref$allowMultiple === void 0 ? false : _ref$allowMultiple,
      current = _ref.current;
  var initialState = useSealedState({
    allowMultiple: allowMultiple,
    current: setCurrentState([], current),
    isWithinContext: true
  });
  return initialState;
}
/** @typedef {string | string[]} Payload */

/** @typedef {{ type: 'add', payload: Payload }} AddAction */

/** @typedef {{ type: 'remove', payload: Payload }} RemoveAction */

/** @typedef {{ type: 'set', payload: Payload }} SetAction */

/**
 * @typedef {
	| AddAction
	| RemoveAction
	| SetAction
} Action
 */

/** @typedef {import('react').Dispatch<Action>} AccordionDispatch */

/**
 * @param {State} state
 * @param {Action} action
 *
 * @returns {State}
 */


function reducer(state, action) {
  var current = state.current;

  switch (action.type) {
    case 'add':
      {
        var next = action.payload;
        if (!isCurrentValid(next)) return state;
        if (!simpleEqual(current, next)) return state;
        return _objectSpread(_objectSpread({}, state), {}, {
          current: setCurrentState(current, next)
        });
      }

    case 'remove':
      {
        var _next = action.payload;
        if (!isCurrentValid(_next)) return state;
        return _objectSpread(_objectSpread({}, state), {}, {
          current: sanitizeState(current.filter(function (id) {
            return id === _next;
          }))
        });
      }

    case 'set':
      {
        var _next2 = action.payload;
        if (!isCurrentValid(_next2)) return state;
        if (simpleEqual(current, _next2)) return state;
        var nextState = Array.isArray(_next2) ? [_next2[0]] : [_next2];
        return _objectSpread(_objectSpread({}, state), {}, {
          current: sanitizeState(nextState)
        });
      }

    default:
      {
        return state;
      }
  }
}
/**
 * @param {AccordionDispatch} dispatch
 * @param {Payload} payload
 */


export function add(dispatch, payload) {
  dispatch({
    type: 'add',
    payload: payload
  });
}
/**
 * @param {AccordionDispatch} dispatch
 * @param {Payload} payload
 */

export function remove(dispatch, payload) {
  dispatch({
    type: 'remove',
    payload: payload
  });
}
/**
 * @param {AccordionDispatch} dispatch
 * @param {Payload} payload
 * @param {boolean} allowMultiple
 */

export function set(dispatch, payload, allowMultiple) {
  if (allowMultiple) {
    add(dispatch, payload);
  } else {
    dispatch({
      type: 'set',
      payload: payload
    });
  }
}
/**
 * @typedef {State & { onChange: (current: State['current']) => void }} OwnProps
 */

/**
 * @param {OwnProps} props
 * @returns {import('./Accordion.Context').AccordionContext}
 */

export function useAccordionState(props) {
  var _useContextSystem = useContextSystem(props, 'Accordion'),
      _useContextSystem$onC = _useContextSystem.onChange,
      onChange = _useContextSystem$onC === void 0 ? noop : _useContextSystem$onC,
      otherProps = _objectWithoutProperties(_useContextSystem, ["onChange"]);

  var initialState = useInitialState(otherProps);

  var _useReducer = useReducer(reducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      _useReducer2$ = _useReducer2[0],
      allowMultiple = _useReducer2$.allowMultiple,
      current = _useReducer2$.current,
      isWithinContext = _useReducer2$.isWithinContext,
      dispatch = _useReducer2[1]; // Selectors


  // Synchronize props + state
  useUpdateEffect(function () {
    // @todo: Handle sync for collapsing items for an incoming `current` prop change.
    set(dispatch, props.current, allowMultiple);
  }, [props.current]);
  useUpdateEffect(function () {
    onChange(current);
  }, [current, onChange]);
  return {
    allowMultiple: allowMultiple,
    current: current,
    getIsVisible: function getIsVisible(
    /** @type {string} */
    id) {
      return !!id && (current == null ? void 0 : current.includes(id));
    },
    isWithinContext: isWithinContext,
    dispatch: dispatch
  };
}
/**
 * @typedef Props
 * @property {boolean} [allowMultiple=false]
 * @property {(current: string[] | null) => void} [onChange]
 * @property {string[]} [current]
 * @property {import('react').ReactNode} [children]
 */

/**
 * @param {Props} props
 */

export function useAccordionProps(props) {
  var children = props.children,
      otherProps = _objectWithoutProperties(props, ["children"]);

  var accordionState = useAccordionState(otherProps);
  var contextValue = useMemo(function () {
    return accordionState;
  }, [accordionState]);
  return _objectSpread({
    children: children,
    contextValue: contextValue
  }, otherProps);
}
/**
 * @param {object} props
 * @param {string} props.id
 * @param {boolean} props.visible
 * @return {[boolean, (id: string) => boolean ]}
 */

export function useAccordion(_ref2) {
  var id = _ref2.id,
      visibleProp = _ref2.visible;

  var _useAccordionContext = useAccordionContext(),
      allowMultiple = _useAccordionContext.allowMultiple,
      dispatch = _useAccordionContext.dispatch,
      getIsVisible = _useAccordionContext.getIsVisible,
      isWithinContext = _useAccordionContext.isWithinContext;

  var visible = isWithinContext ? getIsVisible(id) : visibleProp;
  var setVisible = useCallback(function (
  /** @type {boolean} */
  nextVisible) {
    if (!isWithinContext) return;
    if (!id) return;

    if (nextVisible) {
      if (allowMultiple) {
        add(dispatch, id);
      } else {
        set(dispatch, id, allowMultiple);
      }
    } else {
      if (allowMultiple) {
        remove(dispatch, id);
      }
    }
  }, [id, allowMultiple, dispatch, isWithinContext]);
  useUpdateEffect(function () {
    setVisible(visibleProp);
  }, [setVisible, visibleProp]);
  return [visible, setVisible];
}