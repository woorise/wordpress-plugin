"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.truncateMiddle = truncateMiddle;
exports.truncateContent = truncateContent;
exports.TRUNCATE_DEFAULT_PROPS = exports.TRUNCATE_TYPE = exports.TRUNCATE_ELLIPSIS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("@wp-g2/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TRUNCATE_ELLIPSIS = 'â€¦';
exports.TRUNCATE_ELLIPSIS = TRUNCATE_ELLIPSIS;
var TRUNCATE_TYPE = {
  auto: 'auto',
  head: 'head',
  middle: 'middle',
  tail: 'tail',
  none: 'none'
};
exports.TRUNCATE_TYPE = TRUNCATE_TYPE;
var TRUNCATE_DEFAULT_PROPS = {
  ellipsis: TRUNCATE_ELLIPSIS,
  ellipsizeMode: TRUNCATE_TYPE.auto,
  limit: 0,
  numberOfLines: 0
}; // Source
// https://github.com/kahwee/truncate-middle

exports.TRUNCATE_DEFAULT_PROPS = TRUNCATE_DEFAULT_PROPS;

function truncateMiddle(word, headLength, tailLength, ellipsis) {
  if (typeof word !== 'string') {
    return '';
  }

  var wordLength = word.length; // Setting default values

  var frontLength = ~~headLength; // will cast to integer

  var backLength = ~~tailLength;
  /* istanbul ignore next */

  var truncateStr = _utils.is.defined(ellipsis) ? ellipsis : TRUNCATE_ELLIPSIS;

  if (frontLength === 0 && backLength === 0 || frontLength >= wordLength || backLength >= wordLength || frontLength + backLength >= wordLength) {
    return word;
  } else if (backLength === 0) {
    return word.slice(0, frontLength) + truncateStr;
  } else {
    return word.slice(0, frontLength) + truncateStr + word.slice(wordLength - backLength);
  }
}

function truncateContent(words, props) {
  if (words === void 0) {
    words = '';
  }

  var mergedProps = _objectSpread(_objectSpread({}, TRUNCATE_DEFAULT_PROPS), props);

  var ellipsis = mergedProps.ellipsis,
      ellipsizeMode = mergedProps.ellipsizeMode,
      limit = mergedProps.limit;

  if (ellipsizeMode === TRUNCATE_TYPE.none) {
    return words;
  }

  var truncateHead;
  var truncateTail;

  switch (ellipsizeMode) {
    case TRUNCATE_TYPE.head:
      truncateHead = 0;
      truncateTail = limit;
      break;

    case TRUNCATE_TYPE.middle:
      truncateHead = Math.floor(limit / 2);
      truncateTail = Math.floor(limit / 2);
      break;

    default:
      truncateHead = limit;
      truncateTail = 0;
  }

  var truncatedContent = ellipsizeMode !== TRUNCATE_TYPE.auto ? truncateMiddle(words, truncateHead, truncateTail, ellipsis) : words;
  return truncatedContent;
}