"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSelectDropdown = useSelectDropdown;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _context = require("@wp-g2/context");

var _styles = require("@wp-g2/styles");

var _utils = require("@wp-g2/utils");

var _downshift = require("downshift");

var _react = require("react");

var _FormGroup = require("../FormGroup");

var _positioner = require("../positioner");

var styles = _interopRequireWildcard(require("./select-dropdown-styles"));

var _selectDropdownUtils = require("./select-dropdown-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var CONTROL_BORDER_WIDTH = -1;
var OFFSET = [CONTROL_BORDER_WIDTH, 4];

function useSelectDropdownPositioner(_ref) {
  var _ref$unstable_offset = _ref.unstable_offset,
      unstable_offset = _ref$unstable_offset === void 0 ? OFFSET : _ref$unstable_offset,
      _ref$isOpen = _ref.isOpen,
      isOpen = _ref$isOpen === void 0 ? false : _ref$isOpen,
      otherProps = (0, _objectWithoutProperties2.default)(_ref, ["unstable_offset", "isOpen"]);

  var _useResizeAware = (0, _utils.useResizeAware)(),
      _useResizeAware2 = (0, _slicedToArray2.default)(_useResizeAware, 2),
      resizer = _useResizeAware2[0],
      sizes = _useResizeAware2[1];

  var _usePositioner = (0, _positioner.usePositioner)(_objectSpread(_objectSpread({}, otherProps), {}, {
    unstable_offset: OFFSET
  })),
      popoverRef = _usePositioner.popoverRef,
      popper = _usePositioner.popper,
      referenceRef = _usePositioner.referenceRef; // Ensure that the popover will be correctly positioned with an additional
  // update.
  // https://github.com/reakit/reakit/blob/master/packages/reakit/src/Popover/PopoverState.ts


  (0, _react.useEffect)(function () {
    if (!isOpen) return undefined;
    var id = window.requestAnimationFrame(function () {
      popper.current.forceUpdate();
    });
    return function () {
      window.cancelAnimationFrame(id);
    };
  }, [isOpen, popper]);
  return {
    resizer: resizer,
    sizes: sizes,
    popoverRef: popoverRef,
    popper: popper,
    referenceRef: referenceRef
  };
}

function useSelectDropdown(props) {
  var _useContextSystem = (0, _context.useContextSystem)(props, 'SelectDropdown'),
      className = _useContextSystem.className,
      error = _useContextSystem.error,
      hideLabelFromVision = _useContextSystem.hideLabelFromVision,
      idProp = _useContextSystem.id,
      _useContextSystem$isP = _useContextSystem.isPreviewable,
      isPreviewable = _useContextSystem$isP === void 0 ? false : _useContextSystem$isP,
      isInline = _useContextSystem.isInline,
      isSubtle = _useContextSystem.isSubtle,
      isOpenProp = _useContextSystem.isOpen,
      label = _useContextSystem.label,
      _useContextSystem$max = _useContextSystem.maxWidth,
      maxWidthProp = _useContextSystem$max === void 0 ? 280 : _useContextSystem$max,
      _useContextSystem$min = _useContextSystem.minWidth,
      minWidth = _useContextSystem$min === void 0 ? 200 : _useContextSystem$min,
      _useContextSystem$onO = _useContextSystem.onOpen,
      onOpen = _useContextSystem$onO === void 0 ? _utils.noop : _useContextSystem$onO,
      _useContextSystem$onC = _useContextSystem.onClose,
      onClose = _useContextSystem$onC === void 0 ? _utils.noop : _useContextSystem$onC,
      _useContextSystem$onC2 = _useContextSystem.onChange,
      onChange = _useContextSystem$onC2 === void 0 ? _utils.noop : _useContextSystem$onC2,
      _useContextSystem$opt = _useContextSystem.options,
      items = _useContextSystem$opt === void 0 ? [] : _useContextSystem$opt,
      placeholder = _useContextSystem.placeholder,
      prefix = _useContextSystem.prefix,
      renderItem = _useContextSystem.renderItem,
      size = _useContextSystem.size,
      suffix = _useContextSystem.suffix,
      textAlign = _useContextSystem.textAlign,
      initialValue = _useContextSystem.value,
      variant = _useContextSystem.variant,
      otherProps = (0, _objectWithoutProperties2.default)(_useContextSystem, ["className", "error", "hideLabelFromVision", "id", "isPreviewable", "isInline", "isSubtle", "isOpen", "label", "maxWidth", "minWidth", "onOpen", "onClose", "onChange", "options", "placeholder", "prefix", "renderItem", "size", "suffix", "textAlign", "value", "variant"]);

  var _useState = (0, _react.useState)(initialValue),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      actualValue = _useState2[0],
      setActualValue = _useState2[1];

  var currentItem = (0, _selectDropdownUtils.getSelectedItem)(items, actualValue);
  /** @type {import('react').MutableRefObject<HTMLSelectElement>} */

  var selectRef = (0, _react.useRef)();
  var handleOnChange = (0, _react.useCallback)(function (next) {
    onChange(next);
  }, [onChange]);
  var handleOnHighlightChange = (0, _react.useCallback)(function (_ref2) {
    var highlightedIndex = _ref2.highlightedIndex;
    if (!isPreviewable) return;
    var item = items[highlightedIndex];
    if (item) onChange({
      selectedItem: item
    });
  }, [isPreviewable, items, onChange]);
  /**
   * Sets up Downshift, the library used for the SelectDropdown component.
   */

  var _useSelect = (0, _downshift.useSelect)({
    initialSelectedItem: items[0],
    items: items,
    isOpen: isOpenProp,
    itemToString: _selectDropdownUtils.itemToString,
    onHighlightedIndexChange: handleOnHighlightChange,
    onSelectedItemChange: handleOnChange,
    selectedItem: currentItem,
    stateReducer: _selectDropdownUtils.stateReducer
  }),
      getItemProps = _useSelect.getItemProps,
      getLabelProps = _useSelect.getLabelProps,
      getMenuProps = _useSelect.getMenuProps,
      getToggleButtonProps = _useSelect.getToggleButtonProps,
      isOpen = _useSelect.isOpen,
      selectedItem = _useSelect.selectedItem;

  (0, _react.useEffect)(function () {
    if (isPreviewable && isOpen) return;
    setActualValue(initialValue);
  }, [initialValue, isOpen, isPreviewable]);
  /**
   * Sets up DOM render effects.
   */

  var _useSelectDropdownPos = useSelectDropdownPositioner(_objectSpread(_objectSpread({}, otherProps), {}, {
    unstable_offset: OFFSET,
    isOpen: isOpen
  })),
      popoverRef = _useSelectDropdownPos.popoverRef,
      referenceRef = _useSelectDropdownPos.referenceRef,
      resizer = _useSelectDropdownPos.resizer,
      sizes = _useSelectDropdownPos.sizes;

  var id = (0, _FormGroup.useFormGroupContextId)(idProp);
  var focusSelectButton = (0, _react.useCallback)(function () {
    if (selectRef.current) {
      selectRef.current.focus();
    }
  }, []);
  var handleOnOpen = (0, _react.useCallback)(function () {
    onOpen();
  }, [onOpen]);
  var handleOnClose = (0, _react.useCallback)(function () {
    focusSelectButton();
    onClose();
  }, [focusSelectButton, onClose]);
  var menuProps = getMenuProps({
    className: styles.MenuWrapper,
    'aria-hidden': !isOpen
  }); // We need this here, because the null active descendant is not
  // fully ARIA compliant.

  if (menuProps['aria-activedescendant'] && menuProps['aria-activedescendant'].slice(0, 'downshift-null'.length) === 'downshift-null') {
    delete menuProps['aria-activedescendant'];
  }

  var popoverProps = _objectSpread(_objectSpread({}, _styles.ui.$('SelectDropdownPopover')), {}, {
    'aria-hidden': !isOpen,
    className: (0, _styles.cx)(styles.Popover, !isOpen && styles.popoverHidden),
    ref: popoverRef,
    style: {
      maxWidth: isInline ? maxWidthProp : sizes.width,
      width: isInline ? null : '100%'
    }
  });

  var _referenceProps = getToggleButtonProps({
    // This is needed because some speech recognition software don't support `aria-labelledby`.
    'aria-label': label,
    'aria-labelledby': undefined
  });

  var referenceProps = _objectSpread(_objectSpread(_objectSpread({}, _styles.ui.$('SelectDropdownReference')), _referenceProps), {}, {
    'aria-expanded': !!isOpen,
    children: (0, _selectDropdownUtils.itemToString)(selectedItem) || placeholder,
    error: error,
    id: id,
    isSubtle: isSubtle,
    prefix: prefix,
    suffix: suffix,
    ref: (0, _utils.mergeRefs)([_referenceProps.ref, referenceRef, selectRef]),
    size: size,
    textAlign: textAlign,
    variant: variant
  });

  var labelProps = _objectSpread(_objectSpread({}, getLabelProps()), {}, {
    as: 'label',
    children: label
  });

  var enhancedItems = items.map(function (item, index) {
    return _objectSpread(_objectSpread({}, item), {}, {
      index: index,
      renderItem: renderItem
    }, getItemProps({
      item: item,
      index: index,
      key: item.id || item.value || index,
      style: item.style,
      isSelected: item === selectedItem
    }));
  });
  var classes = (0, _styles.cx)(styles.SelectDropdown, isInline && styles.inline, className);

  var dropdownMenuProps = _objectSpread(_objectSpread({}, _styles.ui.$('SelectDropdownMenu')), {}, {
    className: (0, _styles.cx)(!isOpen && styles.hidden, styles.DropdownMenu, (0, _styles.css)({
      minWidth: minWidth
    }))
  });
  /**
   * Syncs isOpen state (Downshift) with the internal store.
   */


  (0, _utils.useUpdateEffect)(function () {
    if (isOpen) {
      handleOnOpen();
    } else {
      handleOnClose();
    }
  }, [isOpen]);
  return _objectSpread({
    className: classes,
    dropdownMenuProps: dropdownMenuProps,
    labelProps: labelProps,
    popoverProps: popoverProps,
    resizer: resizer,
    menuProps: menuProps,
    referenceProps: referenceProps,
    items: enhancedItems,
    isOpen: isOpen,
    hideLabelFromVision: hideLabelFromVision
  }, otherProps);
}